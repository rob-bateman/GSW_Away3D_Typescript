var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var away;
(function (away) {
    (function (errors) {
        var AnimationSetError = (function (_super) {
            __extends(AnimationSetError, _super);
            function AnimationSetError(message) {
                _super.call(this, message);
            }
            return AnimationSetError;
        })(errors.Error);
        errors.AnimationSetError = AnimationSetError;
    })(away.errors || (away.errors = {}));
    var errors = away.errors;
})(away || (away = {}));
///<reference path="../_definitions.ts" />
var away;
(function (away) {
    /**
    * @module away.events
    */
    (function (events) {
        var LightEvent = (function (_super) {
            __extends(LightEvent, _super);
            function LightEvent(type) {
                _super.call(this, type);
            }
            //@override
            LightEvent.prototype.clone = function () {
                return new away.events.LightEvent(this.type);
            };
            LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";
            return LightEvent;
        })(away.events.Event);
        events.LightEvent = LightEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (events) {
        /**
        * Dispatched to notify changes in an animation state's state.
        */
        var AnimationStateEvent = (function (_super) {
            __extends(AnimationStateEvent, _super);
            /**
            * Create a new <code>AnimatonStateEvent</code>
            *
            * @param type The event type.
            * @param animator The animation state object that is the subject of this event.
            * @param animationNode The animation node inside the animation state from which the event originated.
            */
            function AnimationStateEvent(type, animator, animationState, animationNode) {
                _super.call(this, type);

                this._animator = animator;
                this._animationState = animationState;
                this._animationNode = animationNode;
            }
            Object.defineProperty(AnimationStateEvent.prototype, "animator", {
                /**
                * The animator object that is the subject of this event.
                */
                get: function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationStateEvent.prototype, "animationState", {
                /**
                * The animation state object that is the subject of this event.
                */
                get: function () {
                    return this._animationState;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationStateEvent.prototype, "animationNode", {
                /**
                * The animation node inside the animation state from which the event originated.
                */
                get: function () {
                    return this._animationNode;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the event.
            *
            * @return An exact duplicate of the current object.
            */
            AnimationStateEvent.prototype.clone = function () {
                return new AnimationStateEvent(this.type, this._animator, this._animationState, this._animationNode);
            };
            AnimationStateEvent.PLAYBACK_COMPLETE = "playbackComplete";

            AnimationStateEvent.TRANSITION_COMPLETE = "transitionComplete";
            return AnimationStateEvent;
        })(events.Event);
        events.AnimationStateEvent = AnimationStateEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (events) {
        /**
        * Dispatched to notify changes in an animator's state.
        */
        var AnimatorEvent = (function (_super) {
            __extends(AnimatorEvent, _super);
            /**
            * Create a new <code>AnimatorEvent</code> object.
            *
            * @param type The event type.
            * @param animator The animator object that is the subject of this event.
            */
            function AnimatorEvent(type, animator) {
                _super.call(this, type);
                this._animator = animator;
            }
            Object.defineProperty(AnimatorEvent.prototype, "animator", {
                get: function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the event.
            *
            * @return An exact duplicate of the current event object.
            */
            AnimatorEvent.prototype.clone = function () {
                return new AnimatorEvent(this.type, this._animator);
            };
            AnimatorEvent.START = "start";

            AnimatorEvent.STOP = "stop";

            AnimatorEvent.CYCLE_COMPLETE = "cycle_complete";
            return AnimatorEvent;
        })(events.Event);
        events.AnimatorEvent = AnimatorEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        //import flash.events.Event;
        var ShadingMethodEvent = (function (_super) {
            __extends(ShadingMethodEvent, _super);
            function ShadingMethodEvent(type) {
                _super.call(this, type);
            }
            ShadingMethodEvent.SHADER_INVALIDATED = "ShaderInvalidated";
            return ShadingMethodEvent;
        })(away.events.Event);
        events.ShadingMethodEvent = ShadingMethodEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * @class away.base.ParticleGeometry
        */
        var ParticleGeometry = (function (_super) {
            __extends(ParticleGeometry, _super);
            function ParticleGeometry() {
                _super.apply(this, arguments);
            }
            return ParticleGeometry;
        })(base.Geometry);
        base.ParticleGeometry = ParticleGeometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.pool
    */
    (function (_pool) {
        var SubGeometryEvent = away.events.SubGeometryEvent;

        /**
        * @class away.pool.RenderableListItem
        */
        var RenderableBase = (function () {
            /**
            *
            * @param sourceEntity
            * @param materialOwner
            * @param subGeometry
            * @param animationSubGeometry
            */
            function RenderableBase(pool, sourceEntity, materialOwner, level, indexOffset) {
                if (typeof level === "undefined") { level = 0; }
                if (typeof indexOffset === "undefined") { indexOffset = 0; }
                var _this = this;
                this._geometryDirty = true;
                this._vertexData = new Object();
                this._pVertexDataDirty = new Object();
                this._vertexOffset = new Object();
                this._onIndicesUpdatedDelegate = function (event) {
                    return _this._onIndicesUpdated(event);
                };
                this._onVerticesUpdatedDelegate = function (event) {
                    return _this._onVerticesUpdated(event);
                };

                //store a reference to the pool for later disposal
                this._pool = pool;

                //reference to level of overflow
                this._level = level;

                //reference to the offset on indices (if this is an overflow renderable)
                this._indexOffset = indexOffset;

                this.sourceEntity = sourceEntity;
                this.materialOwner = materialOwner;
            }
            Object.defineProperty(RenderableBase.prototype, "overflow", {
                /**
                *
                */
                get: function () {
                    if (this._geometryDirty)
                        this._updateGeometry();

                    if (this._indexDataDirty)
                        this._updateIndexData();

                    return this._overflow;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RenderableBase.prototype, "numTriangles", {
                /**
                *
                */
                get: function () {
                    return this._numTriangles;
                },
                enumerable: true,
                configurable: true
            });

            /**
            *
            */
            RenderableBase.prototype.getIndexData = function () {
                if (this._indexDataDirty)
                    this._updateIndexData();

                return this._indexData;
            };

            /**
            *
            */
            RenderableBase.prototype.getVertexData = function (dataType) {
                if (this._pVertexDataDirty[dataType])
                    this._updateVertexData(dataType);

                return this._vertexData[this._concatenateArrays ? away.base.TriangleSubGeometry.VERTEX_DATA : dataType];
            };

            /**
            *
            */
            RenderableBase.prototype.getVertexOffset = function (dataType) {
                if (this._pVertexDataDirty[dataType])
                    this._updateVertexData(dataType);

                return this._vertexOffset[dataType];
            };

            RenderableBase.prototype.dispose = function () {
                this._pool.disposeItem(this.materialOwner);

                this._indexData.dispose();
                this._indexData = null;

                for (var dataType in this._vertexData) {
                    this._vertexData[dataType].dispose();
                    this._vertexData[dataType] = null;
                }

                if (this._overflow) {
                    this._overflow.dispose();
                    this._overflow = null;
                }
            };

            RenderableBase.prototype.invalidateGeometry = function () {
                this._geometryDirty = true;

                if (this._overflow)
                    this._overflow.invalidateGeometry();
            };

            /**
            *
            */
            RenderableBase.prototype.invalidateIndexData = function () {
                this._indexDataDirty = true;
            };

            /**
            * //TODO
            *
            * @param dataType
            */
            RenderableBase.prototype.invalidateVertexData = function (dataType) {
                this._pVertexDataDirty[dataType] = true;
            };

            RenderableBase.prototype._pGetSubGeometry = function () {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * //TODO
            *
            * @param subGeometry
            * @param offset
            * @internal
            */
            RenderableBase.prototype._iFillIndexData = function (indexOffset) {
                if (this._geometryDirty)
                    this._updateGeometry();

                this._indexData = away.pool.IndexDataPool.getItem(this._subGeometry, this._level, indexOffset);

                this._numTriangles = this._indexData.data.length / 3;

                indexOffset = this._indexData.offset;

                //check if there is more to split
                if (indexOffset < this._subGeometry.indices.length) {
                    if (!this._overflow)
                        this._overflow = this._pGetOverflowRenderable(this._pool, this.materialOwner, indexOffset, this._level + 1);

                    this._overflow._iFillIndexData(indexOffset);
                } else if (this._overflow) {
                    this._overflow.dispose();
                    this._overflow = null;
                }
            };

            RenderableBase.prototype._pGetOverflowRenderable = function (pool, materialOwner, level, indexOffset) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * //TODO
            *
            * @private
            */
            RenderableBase.prototype._updateGeometry = function () {
                if (this._subGeometry) {
                    if (this._level == 0)
                        this._subGeometry.removeEventListener(SubGeometryEvent.INDICES_UPDATED, this._onIndicesUpdatedDelegate);
                    this._subGeometry.removeEventListener(SubGeometryEvent.VERTICES_UPDATED, this._onVerticesUpdatedDelegate);
                }

                this._subGeometry = this._pGetSubGeometry();

                this._concatenateArrays = this._subGeometry.concatenateArrays;

                if (this._subGeometry) {
                    if (this._level == 0)
                        this._subGeometry.addEventListener(SubGeometryEvent.INDICES_UPDATED, this._onIndicesUpdatedDelegate);
                    this._subGeometry.addEventListener(SubGeometryEvent.VERTICES_UPDATED, this._onVerticesUpdatedDelegate);
                }

                //dispose
                //			if (this._indexData) {
                //				this._indexData.dispose(); //TODO where is a good place to dispose?
                //				this._indexData = null;
                //			}
                //			for (var dataType in this._vertexData) {
                //				(<away.pool.VertexData> this._vertexData[dataType]).dispose(); //TODO where is a good place to dispose?
                //				this._vertexData[dataType] = null;
                //			}
                this._geometryDirty = false;

                //invalidate indices
                if (this._level == 0)
                    this._indexDataDirty = true;
                //specific vertex data types have to be invalidated in the specific renderable
            };

            /**
            * //TODO
            *
            * @private
            */
            RenderableBase.prototype._updateIndexData = function () {
                this._iFillIndexData(this._indexOffset);

                this._indexDataDirty = false;
            };

            /**
            * //TODO
            *
            * @param dataType
            * @private
            */
            RenderableBase.prototype._updateVertexData = function (dataType) {
                this._vertexOffset[dataType] = this._subGeometry.getOffset(dataType);

                if (this._subGeometry.concatenateArrays)
                    dataType = away.base.SubGeometryBase.VERTEX_DATA;

                this._vertexData[dataType] = away.pool.VertexDataPool.getItem(this._subGeometry, this.getIndexData(), dataType);

                this._pVertexDataDirty[dataType] = false;
            };

            /**
            * //TODO
            *
            * @param event
            * @private
            */
            RenderableBase.prototype._onIndicesUpdated = function (event) {
                this.invalidateIndexData();
            };

            /**
            * //TODO
            *
            * @param event
            * @private
            */
            RenderableBase.prototype._onVerticesUpdated = function (event) {
                this._concatenateArrays = event.target.concatenateArrays;

                this.invalidateVertexData(event.dataType);
            };
            return RenderableBase;
        })();
        _pool.RenderableBase = RenderableBase;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.pool
    */
    (function (_pool) {
        var TriangleSubGeometry = away.base.TriangleSubGeometry;

        /**
        * @class away.pool.RenderableListItem
        */
        var BillboardRenderable = (function (_super) {
            __extends(BillboardRenderable, _super);
            /**
            * //TODO
            *
            * @param pool
            * @param billboard
            */
            function BillboardRenderable(pool, billboard) {
                _super.call(this, pool, billboard, billboard);

                this._billboard = billboard;
            }
            /**
            * //TODO
            *
            * @returns {away.base.TriangleSubGeometry}
            */
            BillboardRenderable.prototype._pGetSubGeometry = function () {
                var material = this._billboard.material;

                var geometry = BillboardRenderable._materialGeometry[material.id];

                if (!geometry) {
                    geometry = BillboardRenderable._materialGeometry[material.id] = new TriangleSubGeometry(true);
                    geometry.autoDeriveNormals = false;
                    geometry.autoDeriveTangents = false;
                    geometry.updateIndices(Array(0, 1, 2, 0, 2, 3));
                    geometry.updatePositions(Array(0, material.height, 0, material.width, material.height, 0, material.width, 0, 0, 0, 0, 0));
                    geometry.updateVertexNormals(Array(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0));
                    geometry.updateVertexTangents(Array(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1));
                    geometry.updateUVs(Array(0, 0, 1, 0, 1, 1, 0, 1));
                } else {
                    geometry.updatePositions(Array(0, material.height, 0, material.width, material.height, 0, material.width, 0, 0, 0, 0, 0));
                }

                this._pVertexDataDirty[TriangleSubGeometry.POSITION_DATA] = true;
                this._pVertexDataDirty[TriangleSubGeometry.NORMAL_DATA] = true;
                this._pVertexDataDirty[TriangleSubGeometry.TANGENT_DATA] = true;
                this._pVertexDataDirty[TriangleSubGeometry.UV_DATA] = true;

                return geometry;
            };
            BillboardRenderable._materialGeometry = new Object();

            BillboardRenderable.id = "billboard";
            return BillboardRenderable;
        })(_pool.RenderableBase);
        _pool.BillboardRenderable = BillboardRenderable;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.pool
    */
    (function (_pool) {
        var LineSubGeometry = away.base.LineSubGeometry;

        /**
        * @class away.pool.LineSubMeshRenderable
        */
        var LineSubMeshRenderable = (function (_super) {
            __extends(LineSubMeshRenderable, _super);
            /**
            * //TODO
            *
            * @param pool
            * @param subMesh
            * @param level
            * @param dataOffset
            */
            function LineSubMeshRenderable(pool, subMesh, level, indexOffset) {
                if (typeof level === "undefined") { level = 0; }
                if (typeof indexOffset === "undefined") { indexOffset = 0; }
                _super.call(this, pool, subMesh.parentMesh, subMesh, level, indexOffset);

                this.subMesh = subMesh;
            }
            /**
            * //TODO
            *
            * @returns {base.LineSubGeometry}
            * @protected
            */
            LineSubMeshRenderable.prototype._pGetSubGeometry = function () {
                var subGeometry = this.subMesh.subGeometry;

                this._pVertexDataDirty[LineSubGeometry.START_POSITION_DATA] = true;
                this._pVertexDataDirty[LineSubGeometry.END_POSITION_DATA] = true;

                if (subGeometry.thickness)
                    this._pVertexDataDirty[LineSubGeometry.THICKNESS_DATA] = true;

                if (subGeometry.startColors)
                    this._pVertexDataDirty[LineSubGeometry.COLOR_DATA] = true;

                return subGeometry;
            };

            /**
            * //TODO
            *
            * @param pool
            * @param materialOwner
            * @param level
            * @param indexOffset
            * @returns {away.pool.LineSubMeshRenderable}
            * @private
            */
            LineSubMeshRenderable.prototype._pGetOverflowRenderable = function (pool, materialOwner, level, indexOffset) {
                return new LineSubMeshRenderable(pool, materialOwner, level, indexOffset);
            };
            LineSubMeshRenderable.id = "linesubmesh";
            return LineSubMeshRenderable;
        })(_pool.RenderableBase);
        _pool.LineSubMeshRenderable = LineSubMeshRenderable;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.pool
    */
    (function (_pool) {
        var TriangleSubGeometry = away.base.TriangleSubGeometry;

        /**
        * @class away.pool.SkyboxRenderable
        */
        var SkyboxRenderable = (function (_super) {
            __extends(SkyboxRenderable, _super);
            /**
            * //TODO
            *
            * @param pool
            * @param skybox
            */
            function SkyboxRenderable(pool, skybox) {
                _super.call(this, pool, skybox, skybox);
            }
            /**
            * //TODO
            *
            * @returns {away.base.TriangleSubGeometry}
            * @private
            */
            SkyboxRenderable.prototype._pGetSubGeometry = function () {
                var geometry = SkyboxRenderable._geometry;

                if (!geometry) {
                    geometry = SkyboxRenderable._geometry = new TriangleSubGeometry(true);
                    geometry.autoDeriveNormals = false;
                    geometry.autoDeriveTangents = false;
                    geometry.updateIndices(Array(0, 1, 2, 2, 3, 0, 6, 5, 4, 4, 7, 6, 2, 6, 7, 7, 3, 2, 4, 5, 1, 1, 0, 4, 4, 0, 3, 3, 7, 4, 2, 1, 5, 5, 6, 2));
                    geometry.updatePositions(Array(-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1));
                }

                this._pVertexDataDirty[TriangleSubGeometry.POSITION_DATA] = true;

                return geometry;
            };
            SkyboxRenderable.id = "skybox";
            return SkyboxRenderable;
        })(_pool.RenderableBase);
        _pool.SkyboxRenderable = SkyboxRenderable;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.pool
    */
    (function (_pool) {
        var TriangleSubGeometry = away.base.TriangleSubGeometry;

        /**
        * @class away.pool.TriangleSubMeshRenderable
        */
        var TriangleSubMeshRenderable = (function (_super) {
            __extends(TriangleSubMeshRenderable, _super);
            /**
            * //TODO
            *
            * @param pool
            * @param subMesh
            * @param level
            * @param indexOffset
            */
            function TriangleSubMeshRenderable(pool, subMesh, level, indexOffset) {
                if (typeof level === "undefined") { level = 0; }
                if (typeof indexOffset === "undefined") { indexOffset = 0; }
                _super.call(this, pool, subMesh.parentMesh, subMesh, level, indexOffset);

                this.subMesh = subMesh;
            }
            /**
            *
            * @returns {away.base.SubGeometryBase}
            * @protected
            */
            TriangleSubMeshRenderable.prototype._pGetSubGeometry = function () {
                var subGeometry;

                if (this.subMesh.animator)
                    subGeometry = this.subMesh.animator.getRenderableSubGeometry(this, this.subMesh.subGeometry);
                else
                    subGeometry = this.subMesh.subGeometry;

                this._pVertexDataDirty[TriangleSubGeometry.POSITION_DATA] = true;

                if (subGeometry.vertexNormals)
                    this._pVertexDataDirty[TriangleSubGeometry.NORMAL_DATA] = true;

                if (subGeometry.vertexTangents)
                    this._pVertexDataDirty[TriangleSubGeometry.TANGENT_DATA] = true;

                if (subGeometry.uvs)
                    this._pVertexDataDirty[TriangleSubGeometry.UV_DATA] = true;

                if (subGeometry.secondaryUVs)
                    this._pVertexDataDirty[TriangleSubGeometry.SECONDARY_UV_DATA] = true;

                if (subGeometry.jointIndices)
                    this._pVertexDataDirty[TriangleSubGeometry.JOINT_INDEX_DATA] = true;

                if (subGeometry.jointWeights)
                    this._pVertexDataDirty[TriangleSubGeometry.JOINT_WEIGHT_DATA] = true;

                switch (subGeometry.jointsPerVertex) {
                    case 1:
                        this.JOINT_INDEX_FORMAT = this.JOINT_WEIGHT_FORMAT = away.stagegl.ContextGLVertexBufferFormat.FLOAT_1;
                        break;
                    case 2:
                        this.JOINT_INDEX_FORMAT = this.JOINT_WEIGHT_FORMAT = away.stagegl.ContextGLVertexBufferFormat.FLOAT_2;
                        break;
                    case 3:
                        this.JOINT_INDEX_FORMAT = this.JOINT_WEIGHT_FORMAT = away.stagegl.ContextGLVertexBufferFormat.FLOAT_3;
                        break;
                    case 4:
                        this.JOINT_INDEX_FORMAT = this.JOINT_WEIGHT_FORMAT = away.stagegl.ContextGLVertexBufferFormat.FLOAT_4;
                        break;
                    default:
                }

                return subGeometry;
            };

            /**
            * //TODO
            *
            * @param pool
            * @param materialOwner
            * @param level
            * @param indexOffset
            * @returns {away.pool.TriangleSubMeshRenderable}
            * @protected
            */
            TriangleSubMeshRenderable.prototype._pGetOverflowRenderable = function (pool, materialOwner, level, indexOffset) {
                return new TriangleSubMeshRenderable(pool, materialOwner, level, indexOffset);
            };
            TriangleSubMeshRenderable.id = "trianglesubmesh";
            return TriangleSubMeshRenderable;
        })(_pool.RenderableBase);
        _pool.TriangleSubMeshRenderable = TriangleSubMeshRenderable;
    })(away.pool || (away.pool = {}));
    var pool = away.pool;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.traverse
    */
    (function (traverse) {
        /**
        * @class away.traverse.EntityCollector
        */
        var EntityCollector = (function (_super) {
            __extends(EntityCollector, _super);
            function EntityCollector() {
                _super.call(this);
                this._pNumLights = 0;
                this._numDirectionalLights = 0;
                this._numPointLights = 0;
                this._numLightProbes = 0;

                this._pLights = new Array();
                this._directionalLights = new Array();
                this._pointLights = new Array();
                this._lightProbes = new Array();
            }
            Object.defineProperty(EntityCollector.prototype, "directionalLights", {
                /**
                *
                */
                get: function () {
                    return this._directionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "lightProbes", {
                /**
                *
                */
                get: function () {
                    return this._lightProbes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "lights", {
                /**
                *
                */
                get: function () {
                    return this._pLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "pointLights", {
                /**
                *
                */
                get: function () {
                    return this._pointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "skyBox", {
                /**
                *
                */
                get: function () {
                    return this._pSkybox;
                },
                enumerable: true,
                configurable: true
            });

            /**
            *
            * @param entity
            */
            EntityCollector.prototype.applyDirectionalLight = function (entity) {
                this._directionalLights[this._numDirectionalLights++] = entity;
            };

            /**
            *
            * @param entity
            */
            EntityCollector.prototype.applyLightProbe = function (entity) {
                this._lightProbes[this._numLightProbes++] = entity;
            };

            /**
            *
            * @param entity
            */
            EntityCollector.prototype.applyPointLight = function (entity) {
                this._pointLights[this._numPointLights++] = entity;
            };

            /**
            *
            */
            EntityCollector.prototype.clear = function () {
                _super.prototype.clear.call(this);

                this._pSkybox = null;

                if (this._pNumLights > 0)
                    this._pLights.length = this._pNumLights = 0;

                if (this._numDirectionalLights > 0)
                    this._directionalLights.length = this._numDirectionalLights = 0;

                if (this._numPointLights > 0)
                    this._pointLights.length = this._numPointLights = 0;

                if (this._numLightProbes > 0)
                    this._lightProbes.length = this._numLightProbes = 0;
            };
            return EntityCollector;
        })(traverse.CollectorBase);
        traverse.EntityCollector = EntityCollector;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.traverse
    */
    (function (traverse) {
        /**
        * @class away.traverse.ShadowCasterCollector
        */
        var ShadowCasterCollector = (function (_super) {
            __extends(ShadowCasterCollector, _super);
            function ShadowCasterCollector() {
                _super.call(this);
            }
            /**
            *
            */
            ShadowCasterCollector.prototype.enterNode = function (node) {
                var enter = this.scene._iCollectionMark != node._iCollectionMark && node.isCastingShadow();

                if (!enter) {
                    node._iCollectionMark = this.scene._iCollectionMark;

                    return false;
                }

                return _super.prototype.enterNode.call(this, node);
            };
            return ShadowCasterCollector;
        })(traverse.CollectorBase);
        traverse.ShadowCasterCollector = ShadowCasterCollector;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.partition
    */
    (function (partition) {
        /**
        * @class away.partition.DirectionalLightNode
        */
        var DirectionalLightNode = (function (_super) {
            __extends(DirectionalLightNode, _super);
            /**
            *
            * @param directionalLight
            */
            function DirectionalLightNode(directionalLight) {
                _super.call(this, directionalLight);

                this._directionalLight = directionalLight;
            }
            /**
            * @inheritDoc
            */
            DirectionalLightNode.prototype.acceptTraverser = function (traverser) {
                //do not run frustum checks on lights
                traverser.applyDirectionalLight(this._directionalLight);
            };

            /**
            *
            * @returns {boolean}
            */
            DirectionalLightNode.prototype.isCastingShadow = function () {
                return false;
            };
            return DirectionalLightNode;
        })(partition.EntityNode);
        partition.DirectionalLightNode = DirectionalLightNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.partition
    */
    (function (partition) {
        /**
        * @class away.partition.LightProbeNode
        */
        var LightProbeNode = (function (_super) {
            __extends(LightProbeNode, _super);
            /**
            *
            * @param lightProbe
            */
            function LightProbeNode(lightProbe) {
                _super.call(this, lightProbe);

                this._lightProbe = lightProbe;
            }
            /**
            * @inheritDoc
            */
            LightProbeNode.prototype.acceptTraverser = function (traverser) {
                //do not run frustum checks on lights
                traverser.applyLightProbe(this._lightProbe);
            };

            /**
            *
            * @returns {boolean}
            */
            LightProbeNode.prototype.isCastingShadow = function () {
                return false;
            };
            return LightProbeNode;
        })(partition.EntityNode);
        partition.LightProbeNode = LightProbeNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.partition
    */
    (function (partition) {
        /**
        * @class away.partition.PointLightNode
        */
        var PointLightNode = (function (_super) {
            __extends(PointLightNode, _super);
            /**
            *
            * @param pointLight
            */
            function PointLightNode(pointLight) {
                _super.call(this, pointLight);

                this._pointLight = pointLight;
            }
            /**
            * @inheritDoc
            */
            PointLightNode.prototype.acceptTraverser = function (traverser) {
                //do not run frustum checks on lights
                traverser.applyPointLight(this._pointLight);
            };

            /**
            *
            * @returns {boolean}
            */
            PointLightNode.prototype.isCastingShadow = function () {
                return false;
            };
            return PointLightNode;
        })(partition.EntityNode);
        partition.PointLightNode = PointLightNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.pick
    */
    (function (pick) {
        /**
        * An abstract base class for all picking collider classes. It should not be instantiated directly.
        *
        * @class away.pick.PickingColliderBase
        */
        var PickingColliderBase = (function () {
            function PickingColliderBase() {
                this._billboardRenderablePool = away.pool.RenderablePool.getPool(away.pool.BillboardRenderable);
                this._subMeshRenderablePool = away.pool.RenderablePool.getPool(away.pool.TriangleSubMeshRenderable);
            }
            PickingColliderBase.prototype._pPetCollisionNormal = function (indexData /*uint*/ , vertexData, triangleIndex) {
                var normal = new away.geom.Vector3D();
                var i0 = indexData[triangleIndex] * 3;
                var i1 = indexData[triangleIndex + 1] * 3;
                var i2 = indexData[triangleIndex + 2] * 3;
                var p0 = new away.geom.Vector3D(vertexData[i0], vertexData[i0 + 1], vertexData[i0 + 2]);
                var p1 = new away.geom.Vector3D(vertexData[i1], vertexData[i1 + 1], vertexData[i1 + 2]);
                var p2 = new away.geom.Vector3D(vertexData[i2], vertexData[i2 + 1], vertexData[i2 + 2]);
                var side0 = p1.subtract(p0);
                var side1 = p2.subtract(p0);
                normal = side0.crossProduct(side1);
                normal.normalize();
                return normal;
            };

            PickingColliderBase.prototype._pGetCollisionUV = function (indexData /*uint*/ , uvData, triangleIndex, v, w, u, uvOffset, uvStride) {
                var uv = new away.geom.Point();
                var uIndex = indexData[triangleIndex] * uvStride + uvOffset;
                var uv0 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uIndex = indexData[triangleIndex + 1] * uvStride + uvOffset;
                var uv1 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uIndex = indexData[triangleIndex + 2] * uvStride + uvOffset;
                var uv2 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uv.x = u * uv0.x + v * uv1.x + w * uv2.x;
                uv.y = u * uv0.y + v * uv1.y + w * uv2.y;
                return uv;
            };

            /**
            * @inheritDoc
            */
            PickingColliderBase.prototype._pTestRenderableCollision = function (renderable, pickingCollisionVO, shortestCollisionDistance) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            PickingColliderBase.prototype.setLocalRay = function (localPosition, localDirection) {
                this.rayPosition = localPosition;
                this.rayDirection = localDirection;
            };

            /**
            * Tests a <code>Billboard</code> object for a collision with the picking ray.
            *
            * @param billboard The billboard instance to be tested.
            * @param pickingCollisionVO The collision object used to store the collision results
            * @param shortestCollisionDistance The current value of the shortest distance to a detected collision along the ray.
            * @param findClosest
            */
            PickingColliderBase.prototype.testBillboardCollision = function (billboard, pickingCollisionVO, shortestCollisionDistance) {
                this.setLocalRay(pickingCollisionVO.localRayPosition, pickingCollisionVO.localRayDirection);
                pickingCollisionVO.materialOwner = null;

                if (this._pTestRenderableCollision(this._billboardRenderablePool.getItem(billboard), pickingCollisionVO, shortestCollisionDistance)) {
                    shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;

                    pickingCollisionVO.materialOwner = billboard;

                    return true;
                }

                return false;
            };

            /**
            * Tests a <code>Mesh</code> object for a collision with the picking ray.
            *
            * @param mesh The mesh instance to be tested.
            * @param pickingCollisionVO The collision object used to store the collision results
            * @param shortestCollisionDistance The current value of the shortest distance to a detected collision along the ray.
            * @param findClosest
            */
            PickingColliderBase.prototype.testMeshCollision = function (mesh, pickingCollisionVO, shortestCollisionDistance, findClosest) {
                this.setLocalRay(pickingCollisionVO.localRayPosition, pickingCollisionVO.localRayDirection);
                pickingCollisionVO.materialOwner = null;

                var subMesh;

                var len = mesh.subMeshes.length;
                for (var i = 0; i < len; ++i) {
                    subMesh = mesh.subMeshes[i];

                    if (this._pTestRenderableCollision(this._subMeshRenderablePool.getItem(subMesh), pickingCollisionVO, shortestCollisionDistance)) {
                        shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;

                        pickingCollisionVO.materialOwner = subMesh;

                        if (!findClosest)
                            return true;
                    }
                }

                return pickingCollisionVO.materialOwner != null;
            };
            return PickingColliderBase;
        })();
        pick.PickingColliderBase = PickingColliderBase;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.pick
    */
    (function (pick) {
        var SubGeometry = away.base.TriangleSubGeometry;

        /**
        * Pure JS picking collider for display objects. Used with the <code>RaycastPicker</code> picking object.
        *
        * @see away.base.DisplayObject#pickingCollider
        * @see away.pick.RaycastPicker
        *
        * @class away.pick.JSPickingCollider
        */
        var JSPickingCollider = (function (_super) {
            __extends(JSPickingCollider, _super);
            /**
            * Creates a new <code>JSPickingCollider</code> object.
            *
            * @param findClosestCollision Determines whether the picking collider searches for the closest collision along the ray. Defaults to false.
            */
            function JSPickingCollider(findClosestCollision) {
                if (typeof findClosestCollision === "undefined") { findClosestCollision = false; }
                _super.call(this);

                this._findClosestCollision = findClosestCollision;
            }
            /**
            * @inheritDoc
            */
            JSPickingCollider.prototype._pTestRenderableCollision = function (renderable, pickingCollisionVO, shortestCollisionDistance) {
                var t;
                var i0, i1, i2;
                var rx, ry, rz;
                var nx, ny, nz;
                var cx, cy, cz;
                var coeff, u, v, w;
                var p0x, p0y, p0z;
                var p1x, p1y, p1z;
                var p2x, p2y, p2z;
                var s0x, s0y, s0z;
                var s1x, s1y, s1z;
                var nl, nDotV, D, disToPlane;
                var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
                var indexData = renderable.getIndexData().data;
                var collisionTriangleIndex = -1;
                var bothSides = renderable.materialOwner.material.bothSides;

                var positionData = renderable.getVertexData(SubGeometry.POSITION_DATA).data;
                var positionStride = renderable.getVertexData(SubGeometry.POSITION_DATA).dataPerVertex;
                var positionOffset = renderable.getVertexOffset(SubGeometry.POSITION_DATA);
                var uvData = renderable.getVertexData(SubGeometry.UV_DATA).data;
                var uvStride = renderable.getVertexData(SubGeometry.UV_DATA).dataPerVertex;
                var uvOffset = renderable.getVertexOffset(SubGeometry.UV_DATA);
                var numIndices = indexData.length;

                for (var index = 0; index < numIndices; index += 3) {
                    // evaluate triangle indices
                    i0 = positionOffset + indexData[index] * positionStride;
                    i1 = positionOffset + indexData[(index + 1)] * positionStride;
                    i2 = positionOffset + indexData[(index + 2)] * positionStride;

                    // evaluate triangle positions
                    p0x = positionData[i0];
                    p0y = positionData[(i0 + 1)];
                    p0z = positionData[(i0 + 2)];
                    p1x = positionData[i1];
                    p1y = positionData[(i1 + 1)];
                    p1z = positionData[(i1 + 2)];
                    p2x = positionData[i2];
                    p2y = positionData[(i2 + 1)];
                    p2z = positionData[(i2 + 2)];

                    // evaluate sides and triangle normal
                    s0x = p1x - p0x; // s0 = p1 - p0
                    s0y = p1y - p0y;
                    s0z = p1z - p0z;
                    s1x = p2x - p0x; // s1 = p2 - p0
                    s1y = p2y - p0y;
                    s1z = p2z - p0z;
                    nx = s0y * s1z - s0z * s1y; // n = s0 x s1
                    ny = s0z * s1x - s0x * s1z;
                    nz = s0x * s1y - s0y * s1x;
                    nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz); // normalize n
                    nx *= nl;
                    ny *= nl;
                    nz *= nl;

                    // -- plane intersection test --
                    nDotV = nx * this.rayDirection.x + ny * +this.rayDirection.y + nz * this.rayDirection.z; // rayDirection . normal
                    if ((!bothSides && nDotV < 0.0) || (bothSides && nDotV != 0.0)) {
                        // find collision t
                        D = -(nx * p0x + ny * p0y + nz * p0z);
                        disToPlane = -(nx * this.rayPosition.x + ny * this.rayPosition.y + nz * this.rayPosition.z + D);
                        t = disToPlane / nDotV;

                        // find collision point
                        cx = this.rayPosition.x + t * this.rayDirection.x;
                        cy = this.rayPosition.y + t * this.rayDirection.y;
                        cz = this.rayPosition.z + t * this.rayDirection.z;

                        // collision point inside triangle? ( using barycentric coordinates )
                        Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                        Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                        Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                        rx = cx - p0x;
                        ry = cy - p0y;
                        rz = cz - p0z;
                        RQ1 = rx * s0x + ry * s0y + rz * s0z;
                        RQ2 = rx * s1x + ry * s1y + rz * s1z;
                        coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                        v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                        w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                        if (v < 0)
                            continue;
                        if (w < 0)
                            continue;
                        u = 1 - v - w;
                        if (!(u < 0) && t > 0 && t < shortestCollisionDistance) {
                            shortestCollisionDistance = t;
                            collisionTriangleIndex = index / 3;
                            pickingCollisionVO.rayEntryDistance = t;
                            pickingCollisionVO.localPosition = new away.geom.Vector3D(cx, cy, cz);
                            pickingCollisionVO.localNormal = new away.geom.Vector3D(nx, ny, nz);
                            pickingCollisionVO.uv = this._pGetCollisionUV(indexData, uvData, index, v, w, u, uvOffset, uvStride);
                            pickingCollisionVO.index = index;

                            //						pickingCollisionVO.subGeometryIndex = this.pGetMeshSubMeshIndex(renderable);
                            // if not looking for best hit, first found will do...
                            if (!this._findClosestCollision)
                                return true;
                        }
                    }
                }

                if (collisionTriangleIndex >= 0)
                    return true;

                return false;
            };
            return JSPickingCollider;
        })(pick.PickingColliderBase);
        pick.JSPickingCollider = JSPickingCollider;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.pick
    */
    (function (pick) {
        /**
        * Picks a 3d object from a view or scene by performing a separate render pass on the scene around the area being picked using key color values,
        * then reading back the color value of the pixel in the render representing the picking ray. Requires multiple passes and readbacks for retriving details
        * on an entity that has its shaderPickingDetails property set to true.
        *
        * A read-back operation from any GPU is not a very efficient process, and the amount of processing used can vary significantly between different hardware.
        *
        * @see away.entities.Entity#shaderPickingDetails
        *
        * @class away.pick.ShaderPicker
        */
        var ShaderPicker = (function () {
            /**
            * Creates a new <code>ShaderPicker</code> object.
            *
            * @param shaderPickingDetails Determines whether the picker includes a second pass to calculate extra
            * properties such as uv and normal coordinates.
            */
            function ShaderPicker(shaderPickingDetails) {
                if (typeof shaderPickingDetails === "undefined") { shaderPickingDetails = false; }
                this._onlyMouseEnabled = true;
                this._interactives = new Array();
                this._localHitPosition = new away.geom.Vector3D();
                this._hitUV = new away.geom.Point();
                this._localHitNormal = new away.geom.Vector3D();
                this._rayPos = new away.geom.Vector3D();
                this._rayDir = new away.geom.Vector3D();
                this._shaderPickingDetails = shaderPickingDetails;

                this._id = new Array(4);
                this._viewportData = new Array(4); // first 2 contain scale, last 2 translation
                this._boundOffsetScale = new Array(8); // first 2 contain scale, last 2 translation
                this._boundOffsetScale[3] = 0;
                this._boundOffsetScale[7] = 1;
            }
            Object.defineProperty(ShaderPicker.prototype, "onlyMouseEnabled", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this._onlyMouseEnabled;
                },
                set: function (value) {
                    this._onlyMouseEnabled = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShaderPicker.prototype.getViewCollision = function (x, y, view) {
                var collector = view.iEntityCollector;

                this._stageGL = view.renderer.stageGL;

                if (!this._stageGL)
                    return null;

                this._context = this._stageGL.contextGL;

                this._viewportData[0] = view.width;
                this._viewportData[1] = view.height;
                this._viewportData[2] = -(this._projX = 2 * x / view.width - 1);
                this._viewportData[3] = this._projY = 2 * y / view.height - 1;

                // _potentialFound will be set to true if any object is actually rendered
                this._potentialFound = false;

                //reset head values
                this._blendedRenderableHead = null;
                this._opaqueRenderableHead = null;

                this.pDraw(collector, null);

                // clear buffers
                this._context.setVertexBufferAt(0, null);

                if (!this._context || !this._potentialFound)
                    return null;

                if (!this._bitmapData)
                    this._bitmapData = new away.base.BitmapData(1, 1, false, 0);

                this._context.drawToBitmapData(this._bitmapData);
                this._hitColor = this._bitmapData.getPixel(0, 0);

                if (!this._hitColor) {
                    this._context.present();
                    return null;
                }

                this._hitRenderable = this._interactives[this._hitColor - 1];
                this._hitEntity = this._hitRenderable.sourceEntity;

                if (this._onlyMouseEnabled && !this._hitEntity._iIsMouseEnabled())
                    return null;

                var _collisionVO = this._hitEntity._iPickingCollisionVO;
                if (this._shaderPickingDetails) {
                    this.getHitDetails(view.camera);
                    _collisionVO.localPosition = this._localHitPosition;
                    _collisionVO.localNormal = this._localHitNormal;
                    _collisionVO.uv = this._hitUV;
                    _collisionVO.index = this._faceIndex;
                    //_collisionVO.subGeometryIndex = this._subGeometryIndex;
                } else {
                    _collisionVO.localPosition = null;
                    _collisionVO.localNormal = null;
                    _collisionVO.uv = null;
                    _collisionVO.index = 0;
                    //_collisionVO.subGeometryIndex = 0;
                }

                return _collisionVO;
            };

            //*/
            /**
            * @inheritDoc
            */
            ShaderPicker.prototype.getSceneCollision = function (position, direction, scene) {
                return null;
            };

            /**
            * @inheritDoc
            */
            ShaderPicker.prototype.pDraw = function (entityCollector, target) {
                var camera = entityCollector.camera;

                this._context.clear(0, 0, 0, 1);
                this._stageGL.scissorRect = ShaderPicker.MOUSE_SCISSOR_RECT;

                this._interactives.length = this._interactiveId = 0;

                if (!this._objectProgram)
                    this.initObjectProgram();

                this._context.setBlendFactors(away.stagegl.ContextGLBlendFactor.ONE, away.stagegl.ContextGLBlendFactor.ZERO);
                this._context.setDepthTest(true, away.stagegl.ContextGLCompareMode.LESS);
                this._context.setProgram(this._objectProgram);
                this._context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 4, this._viewportData, 1);
                //this.drawRenderables(entityCollector.opaqueRenderableHead, camera);
                //this.drawRenderables(entityCollector.blendedRenderableHead, camera);
                //TODO: reimplement ShaderPicker inheriting from RendererBase
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param camera The camera for which to render.
            */
            ShaderPicker.prototype.drawRenderables = function (renderable, camera) {
                var matrix = away.geom.Matrix3DUtils.CALCULATION_MATRIX;
                var viewProjection = camera.viewProjection;

                while (renderable) {
                    // it's possible that the renderable was already removed from the scene
                    if (!renderable.sourceEntity.scene || !renderable.sourceEntity._iIsMouseEnabled()) {
                        renderable = renderable.next;
                        continue;
                    }

                    this._potentialFound = true;

                    this._context.setCulling(renderable.materialOwner.material.bothSides ? away.stagegl.ContextGLTriangleFace.NONE : away.stagegl.ContextGLTriangleFace.BACK, camera.projection.coordinateSystem);

                    this._interactives[this._interactiveId++] = renderable;

                    // color code so that reading from bitmapdata will contain the correct value
                    this._id[1] = (this._interactiveId >> 8) / 255; // on green channel
                    this._id[2] = (this._interactiveId & 0xff) / 255; // on blue channel

                    matrix.copyFrom(renderable.sourceEntity.getRenderSceneTransform(camera));
                    matrix.append(viewProjection);
                    this._context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 0, matrix, true);
                    this._context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.FRAGMENT, 0, this._id, 1);
                    this._stageGL.activateBuffer(0, renderable.getVertexData(away.base.TriangleSubGeometry.POSITION_DATA), renderable.getVertexOffset(away.base.TriangleSubGeometry.POSITION_DATA), away.base.TriangleSubGeometry.POSITION_FORMAT);
                    this._context.drawTriangles(this._stageGL.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);

                    renderable = renderable.next;
                }
            };

            ShaderPicker.prototype.updateRay = function (camera) {
                this._rayPos = camera.scenePosition;

                this._rayDir = camera.getRay(this._projX, this._projY, 1);
                this._rayDir.normalize();
            };

            /**
            * Creates the Program that color-codes objects.
            */
            ShaderPicker.prototype.initObjectProgram = function () {
                var vertexCode;
                var fragmentCode;

                this._objectProgram = this._context.createProgram();

                vertexCode = "m44 vt0, va0, vc0			\n" + "mul vt1.xy, vt0.w, vc4.zw	\n" + "add vt0.xy, vt0.xy, vt1.xy	\n" + "mul vt0.xy, vt0.xy, vc4.xy	\n" + "mov op, vt0	\n";
                fragmentCode = "mov oc, fc0"; // write identifier

                away.Debug.throwPIR('ShaderPicker', 'initTriangleProgram', 'Dependency: initObjectProgram');
                //_objectProgram.upload(new AGALMiniAssembler().assemble(ContextGLProgramType.VERTEX, vertexCode),new AGALMiniAssembler().assemble(ContextGLProgramType.FRAGMENT, fragmentCode));
            };

            /**
            * Creates the Program that renders positions.
            */
            ShaderPicker.prototype.initTriangleProgram = function () {
                var vertexCode;
                var fragmentCode;

                this._triangleProgram = this._context.createProgram();

                // todo: add animation code
                vertexCode = "add vt0, va0, vc5 			\n" + "mul vt0, vt0, vc6 			\n" + "mov v0, vt0				\n" + "m44 vt0, va0, vc0			\n" + "mul vt1.xy, vt0.w, vc4.zw	\n" + "add vt0.xy, vt0.xy, vt1.xy	\n" + "mul vt0.xy, vt0.xy, vc4.xy	\n" + "mov op, vt0	\n";
                fragmentCode = "mov oc, v0"; // write identifier

                var vertexByteCode = (new aglsl.assembler.AGALMiniAssembler().assemble("part vertex 1\n" + vertexCode + "endpart"))['vertex'].data;
                var fragmentByteCode = (new aglsl.assembler.AGALMiniAssembler().assemble("part fragment 1\n" + fragmentCode + "endpart"))['fragment'].data;
                this._triangleProgram.upload(vertexByteCode, fragmentByteCode);
            };

            /**
            * Gets more detailed information about the hir position, if required.
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getHitDetails = function (camera) {
                this.getApproximatePosition(camera);
                this.getPreciseDetails(camera);
            };

            /**
            * Finds a first-guess approximate position about the hit position.
            *
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getApproximatePosition = function (camera) {
                var bounds = this._hitRenderable.sourceEntity.bounds.aabb;
                var col;
                var scX, scY, scZ;
                var offsX, offsY, offsZ;
                var localViewProjection = away.geom.Matrix3DUtils.CALCULATION_MATRIX;

                localViewProjection.copyFrom(this._hitRenderable.sourceEntity.getRenderSceneTransform(camera));
                localViewProjection.append(camera.viewProjection);
                if (!this._triangleProgram) {
                    this.initTriangleProgram();
                }

                this._boundOffsetScale[4] = 1 / (scX = bounds.width);
                this._boundOffsetScale[5] = 1 / (scY = bounds.height);
                this._boundOffsetScale[6] = 1 / (scZ = bounds.depth);
                this._boundOffsetScale[0] = offsX = -bounds.x;
                this._boundOffsetScale[1] = offsY = -bounds.y;
                this._boundOffsetScale[2] = offsZ = -bounds.z;

                this._context.setProgram(this._triangleProgram);
                this._context.clear(0, 0, 0, 0, 1, 0, away.stagegl.ContextGLClearMask.DEPTH);
                this._context.setScissorRectangle(ShaderPicker.MOUSE_SCISSOR_RECT);
                this._context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 0, localViewProjection, true);
                this._context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 5, this._boundOffsetScale, 2);

                this._stageGL.activateBuffer(0, this._hitRenderable.getVertexData(away.base.TriangleSubGeometry.POSITION_DATA), this._hitRenderable.getVertexOffset(away.base.TriangleSubGeometry.POSITION_DATA), away.base.TriangleSubGeometry.POSITION_FORMAT);
                this._context.drawTriangles(this._stageGL.getIndexBuffer(this._hitRenderable.getIndexData()), 0, this._hitRenderable.numTriangles);

                this._context.drawToBitmapData(this._bitmapData);

                col = this._bitmapData.getPixel(0, 0);

                this._localHitPosition.x = ((col >> 16) & 0xff) * scX / 255 - offsX;
                this._localHitPosition.y = ((col >> 8) & 0xff) * scY / 255 - offsY;
                this._localHitPosition.z = (col & 0xff) * scZ / 255 - offsZ;
            };

            /**
            * Use the approximate position info to find the face under the mouse position from which we can derive the precise
            * ray-face intersection point, then use barycentric coordinates to figure out the uv coordinates, etc.
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getPreciseDetails = function (camera) {
                var len = indices.length;
                var x1, y1, z1;
                var x2, y2, z2;
                var x3, y3, z3;
                var i = 0, j = 1, k = 2;
                var t1, t2, t3;
                var v0x, v0y, v0z;
                var v1x, v1y, v1z;
                var v2x, v2y, v2z;
                var ni1, ni2, ni3;
                var n1, n2, n3, nLength;
                var dot00, dot01, dot02, dot11, dot12;
                var s, t, invDenom;
                var x = this._localHitPosition.x, y = this._localHitPosition.y, z = this._localHitPosition.z;
                var u, v;
                var ui1, ui2, ui3;
                var s0x, s0y, s0z;
                var s1x, s1y, s1z;
                var nl;
                var indices = this._hitRenderable.getIndexData().data;

                var positions = this._hitRenderable.getVertexData(away.base.TriangleSubGeometry.POSITION_DATA).data;
                var positionStride = this._hitRenderable.getVertexData(away.base.TriangleSubGeometry.POSITION_DATA).dataPerVertex;
                var positionOffset = this._hitRenderable.getVertexOffset(away.base.TriangleSubGeometry.POSITION_DATA);

                var uvs = this._hitRenderable.getVertexData(away.base.TriangleSubGeometry.UV_DATA).data;
                var uvStride = this._hitRenderable.getVertexData(away.base.TriangleSubGeometry.UV_DATA).dataPerVertex;
                var uvOffset = this._hitRenderable.getVertexOffset(away.base.TriangleSubGeometry.UV_DATA);

                var normals = this._hitRenderable.getVertexData(away.base.TriangleSubGeometry.NORMAL_DATA).data;
                var normalStride = this._hitRenderable.getVertexData(away.base.TriangleSubGeometry.NORMAL_DATA).dataPerVertex;
                var normalOffset = this._hitRenderable.getVertexOffset(away.base.TriangleSubGeometry.NORMAL_DATA);

                this.updateRay(camera);

                while (i < len) {
                    t1 = positionOffset + indices[i] * positionStride;
                    t2 = positionOffset + indices[j] * positionStride;
                    t3 = positionOffset + indices[k] * positionStride;
                    x1 = positions[t1];
                    y1 = positions[t1 + 1];
                    z1 = positions[t1 + 2];
                    x2 = positions[t2];
                    y2 = positions[t2 + 1];
                    z2 = positions[t2 + 2];
                    x3 = positions[t3];
                    y3 = positions[t3 + 1];
                    z3 = positions[t3 + 2];

                    // if within bounds
                    if (!((x < x1 && x < x2 && x < x3) || (y < y1 && y < y2 && y < y3) || (z < z1 && z < z2 && z < z3) || (x > x1 && x > x2 && x > x3) || (y > y1 && y > y2 && y > y3) || (z > z1 && z > z2 && z > z3))) {
                        // calculate barycentric coords for approximated position
                        v0x = x3 - x1;
                        v0y = y3 - y1;
                        v0z = z3 - z1;
                        v1x = x2 - x1;
                        v1y = y2 - y1;
                        v1z = z2 - z1;
                        v2x = x - x1;
                        v2y = y - y1;
                        v2z = z - z1;
                        dot00 = v0x * v0x + v0y * v0y + v0z * v0z;
                        dot01 = v0x * v1x + v0y * v1y + v0z * v1z;
                        dot02 = v0x * v2x + v0y * v2y + v0z * v2z;
                        dot11 = v1x * v1x + v1y * v1y + v1z * v1z;
                        dot12 = v1x * v2x + v1y * v2y + v1z * v2z;
                        invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                        s = (dot11 * dot02 - dot01 * dot12) * invDenom;
                        t = (dot00 * dot12 - dot01 * dot02) * invDenom;

                        // if inside the current triangle, fetch details hit information
                        if (s >= 0 && t >= 0 && (s + t) <= 1) {
                            ni1 = normalOffset + indices[i] * normalStride;
                            ni2 = normalOffset + indices[j] * normalStride;
                            ni3 = normalOffset + indices[k] * normalStride;

                            n1 = indices[ni1] + indices[ni2] + indices[ni3];
                            n2 = indices[ni1 + 1] + indices[ni2 + 1] + indices[ni3 + 1];
                            n3 = indices[ni1 + 2] + indices[ni2 + 2] + indices[ni3 + 2];

                            nLength = Math.sqrt(n1 * n1 + n2 * n2 + n3 * n3);

                            n1 /= nLength;
                            n2 /= nLength;
                            n3 /= nLength;

                            // this is def the triangle, now calculate precise coords
                            this.getPrecisePosition(this._hitRenderable.sourceEntity.inverseSceneTransform, n1, n2, n3, x1, y1, z1);

                            v2x = this._localHitPosition.x - x1;
                            v2y = this._localHitPosition.y - y1;
                            v2z = this._localHitPosition.z - z1;

                            s0x = x2 - x1; // s0 = p1 - p0
                            s0y = y2 - y1;
                            s0z = z2 - z1;
                            s1x = x3 - x1; // s1 = p2 - p0
                            s1y = y3 - y1;
                            s1z = z3 - z1;
                            this._localHitNormal.x = s0y * s1z - s0z * s1y; // n = s0 x s1
                            this._localHitNormal.y = s0z * s1x - s0x * s1z;
                            this._localHitNormal.z = s0x * s1y - s0y * s1x;
                            nl = 1 / Math.sqrt(this._localHitNormal.x * this._localHitNormal.x + this._localHitNormal.y * this._localHitNormal.y + this._localHitNormal.z * this._localHitNormal.z); // normalize n
                            this._localHitNormal.x *= nl;
                            this._localHitNormal.y *= nl;
                            this._localHitNormal.z *= nl;

                            dot02 = v0x * v2x + v0y * v2y + v0z * v2z;
                            dot12 = v1x * v2x + v1y * v2y + v1z * v2z;
                            s = (dot11 * dot02 - dot01 * dot12) * invDenom;
                            t = (dot00 * dot12 - dot01 * dot02) * invDenom;

                            ui1 = uvOffset + indices[i] * uvStride;
                            ui2 = uvOffset + indices[j] * uvStride;
                            ui3 = uvOffset + indices[k] * uvStride;

                            u = uvs[ui1];
                            v = uvs[ui1 + 1];
                            this._hitUV.x = u + t * (uvs[ui2] - u) + s * (uvs[ui3] - u);
                            this._hitUV.y = v + t * (uvs[ui2 + 1] - v) + s * (uvs[ui3 + 1] - v);

                            this._faceIndex = i;

                            //TODO add back subGeometryIndex value
                            //this._subGeometryIndex = away.utils.GeometryUtils.getMeshSubGeometryIndex(subGeom);
                            return;
                        }
                    }

                    i += 3;
                    j += 3;
                    k += 3;
                }
            };

            /**
            * Finds the precise hit position by unprojecting the screen coordinate back unto the hit face's plane and
            * calculating the intersection point.
            * @param camera The camera used to render the object.
            * @param invSceneTransform The inverse scene transformation of the hit object.
            * @param nx The x-coordinate of the face's plane normal.
            * @param ny The y-coordinate of the face plane normal.
            * @param nz The z-coordinate of the face plane normal.
            * @param px The x-coordinate of a point on the face's plane (ie a face vertex)
            * @param py The y-coordinate of a point on the face's plane (ie a face vertex)
            * @param pz The z-coordinate of a point on the face's plane (ie a face vertex)
            */
            ShaderPicker.prototype.getPrecisePosition = function (invSceneTransform, nx, ny, nz, px, py, pz) {
                // calculate screen ray and find exact intersection position with triangle
                var rx, ry, rz;
                var ox, oy, oz;
                var t;
                var raw = away.geom.Matrix3DUtils.RAW_DATA_CONTAINER;
                var cx = this._rayPos.x, cy = this._rayPos.y, cz = this._rayPos.z;

                // unprojected projection point, gives ray dir in cam space
                ox = this._rayDir.x;
                oy = this._rayDir.y;
                oz = this._rayDir.z;

                // transform ray dir and origin (cam pos) to object space
                //invSceneTransform.copyRawDataTo( raw  );
                invSceneTransform.copyRawDataTo(raw);
                rx = raw[0] * ox + raw[4] * oy + raw[8] * oz;
                ry = raw[1] * ox + raw[5] * oy + raw[9] * oz;
                rz = raw[2] * ox + raw[6] * oy + raw[10] * oz;

                ox = raw[0] * cx + raw[4] * cy + raw[8] * cz + raw[12];
                oy = raw[1] * cx + raw[5] * cy + raw[9] * cz + raw[13];
                oz = raw[2] * cx + raw[6] * cy + raw[10] * cz + raw[14];

                t = ((px - ox) * nx + (py - oy) * ny + (pz - oz) * nz) / (rx * nx + ry * ny + rz * nz);

                this._localHitPosition.x = ox + rx * t;
                this._localHitPosition.y = oy + ry * t;
                this._localHitPosition.z = oz + rz * t;
            };

            ShaderPicker.prototype.dispose = function () {
                this._bitmapData.dispose();
                if (this._triangleProgram)
                    this._triangleProgram.dispose();

                if (this._objectProgram)
                    this._objectProgram.dispose();

                this._triangleProgram = null;
                this._objectProgram = null;
                this._bitmapData = null;
                this._hitRenderable = null;
                this._hitEntity = null;
            };
            ShaderPicker.MOUSE_SCISSOR_RECT = new away.geom.Rectangle(0, 0, 1, 1);
            return ShaderPicker;
        })();
        pick.ShaderPicker = ShaderPicker;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.render
    */
    (function (render) {
        /**
        * RendererBase forms an abstract base class for classes that are used in the rendering pipeline to render the
        * contents of a partition
        *
        * @class away.render.RendererBase
        */
        var RendererBase = (function (_super) {
            __extends(RendererBase, _super);
            /**
            * Creates a new RendererBase object.
            */
            function RendererBase() {
                _super.call(this);
                this._viewPort = new away.geom.Rectangle();
                this._pBackBufferInvalid = true;
                this._pDepthTextureInvalid = true;
                this._depthPrepass = false;
                this._backgroundR = 0;
                this._backgroundG = 0;
                this._backgroundB = 0;
                this._backgroundAlpha = 1;
                this._shareContext = false;
                this.textureRatioX = 1;
                this.textureRatioY = 1;
                this._pRttViewProjectionMatrix = new away.geom.Matrix3D();
                this._localPos = new away.geom.Point();
                this._globalPos = new away.geom.Point();
                this._pScissorRect = new away.geom.Rectangle();
                this._pNumTriangles = 0;

                this._onViewportUpdatedDelegate = away.utils.Delegate.create(this, this.onViewportUpdated);

                this._billboardRenderablePool = away.pool.RenderablePool.getPool(away.pool.BillboardRenderable);
                this._skyboxRenderablePool = away.pool.RenderablePool.getPool(away.pool.SkyboxRenderable);
                this._triangleSubMeshRenderablePool = away.pool.RenderablePool.getPool(away.pool.TriangleSubMeshRenderable);
                this._lineSubMeshRenderablePool = away.pool.RenderablePool.getPool(away.pool.LineSubMeshRenderable);

                this._onContextUpdateDelegate = away.utils.Delegate.create(this, this.onContextUpdate);

                //default sorting algorithm
                this.renderableSorter = new away.sort.RenderableMergeSort();
            }
            Object.defineProperty(RendererBase.prototype, "numTriangles", {
                /**
                *
                */
                get: function () {
                    return this._pNumTriangles;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RendererBase.prototype, "viewPort", {
                /**
                * A viewPort rectangle equivalent of the StageGL size and position.
                */
                get: function () {
                    return this._viewPort;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RendererBase.prototype, "scissorRect", {
                /**
                * A scissor rectangle equivalent of the view size and position.
                */
                get: function () {
                    return this._pScissorRect;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RendererBase.prototype, "x", {
                /**
                *
                */
                get: function () {
                    return this._localPos.x;
                },
                set: function (value) {
                    if (this.x == value)
                        return;

                    this._globalPos.x = this._localPos.x = value;

                    this.updateGlobalPos();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "y", {
                /**
                *
                */
                get: function () {
                    return this._localPos.y;
                },
                set: function (value) {
                    if (this.y == value)
                        return;

                    this._globalPos.y = this._localPos.y = value;

                    this.updateGlobalPos();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "width", {
                /**
                *
                */
                get: function () {
                    return this._width;
                },
                set: function (value) {
                    if (this._width == value)
                        return;

                    this._width = value;
                    this._pScissorRect.width = value;

                    if (this._pRttBufferManager)
                        this._pRttBufferManager.viewWidth = value;

                    this._pBackBufferInvalid = true;
                    this._pDepthTextureInvalid = true;

                    this.notifyScissorUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "height", {
                /**
                *
                */
                get: function () {
                    return this._height;
                },
                set: function (value) {
                    if (this._height == value)
                        return;

                    this._height = value;
                    this._pScissorRect.height = value;

                    if (this._pRttBufferManager)
                        this._pRttBufferManager.viewHeight = value;

                    this._pBackBufferInvalid = true;
                    this._pDepthTextureInvalid = true;

                    this.notifyScissorUpdate();
                },
                enumerable: true,
                configurable: true
            });


            RendererBase.prototype._iCreateEntityCollector = function () {
                return new away.traverse.EntityCollector();
            };

            Object.defineProperty(RendererBase.prototype, "_iBackgroundR", {
                /**
                * The background color's red component, used when clearing.
                *
                * @private
                */
                get: function () {
                    return this._backgroundR;
                },
                set: function (value) {
                    if (this._backgroundR == value)
                        return;

                    this._backgroundR = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "_iBackgroundG", {
                /**
                * The background color's green component, used when clearing.
                *
                * @private
                */
                get: function () {
                    return this._backgroundG;
                },
                set: function (value) {
                    if (this._backgroundG == value)
                        return;

                    this._backgroundG = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "_iBackgroundB", {
                /**
                * The background color's blue component, used when clearing.
                *
                * @private
                */
                get: function () {
                    return this._backgroundB;
                },
                set: function (value) {
                    if (this._backgroundB == value)
                        return;

                    this._backgroundB = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "stageGL", {
                /**
                * The StageGL that will provide the ContextGL used for rendering.
                */
                get: function () {
                    return this._pStageGL;
                },
                set: function (value) {
                    if (value == this._pStageGL)
                        return;

                    this.iSetStageGL(value);
                },
                enumerable: true,
                configurable: true
            });


            RendererBase.prototype.iSetStageGL = function (value) {
                if (this._pStageGL) {
                    this._pStageGL.removeEventListener(away.events.StageGLEvent.CONTEXTGL_CREATED, this._onContextUpdateDelegate);
                    this._pStageGL.removeEventListener(away.events.StageGLEvent.CONTEXTGL_RECREATED, this._onContextUpdateDelegate);
                    this._pStageGL.removeEventListener(away.events.StageGLEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
                }

                if (!value) {
                    this._pStageGL = null;
                    this._pContext = null;
                } else {
                    this._pStageGL = value;
                    this._pStageGL.addEventListener(away.events.StageGLEvent.CONTEXTGL_CREATED, this._onContextUpdateDelegate);
                    this._pStageGL.addEventListener(away.events.StageGLEvent.CONTEXTGL_RECREATED, this._onContextUpdateDelegate);
                    this._pStageGL.addEventListener(away.events.StageGLEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);

                    /*
                    if (_backgroundImageRenderer)
                    _backgroundImageRenderer.stageGL = value;
                    */
                    if (this._pStageGL.contextGL)
                        this._pContext = this._pStageGL.contextGL;
                }

                this._pBackBufferInvalid = true;

                this.updateGlobalPos();
            };

            Object.defineProperty(RendererBase.prototype, "shareContext", {
                /**
                * Defers control of ContextGL clear() and present() calls to StageGL, enabling multiple StageGL frameworks
                * to share the same ContextGL object.
                */
                get: function () {
                    return this._shareContext;
                },
                set: function (value) {
                    if (this._shareContext == value)
                        return;

                    this._shareContext = value;

                    this.updateGlobalPos();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Disposes the resources used by the RendererBase.
            */
            RendererBase.prototype.dispose = function () {
                if (this._pRttBufferManager)
                    this._pRttBufferManager.dispose();

                this._pRttBufferManager = null;

                this._pStageGL.removeEventListener(away.events.StageGLEvent.CONTEXTGL_CREATED, this._onContextUpdateDelegate);
                this._pStageGL.removeEventListener(away.events.StageGLEvent.CONTEXTGL_RECREATED, this._onContextUpdateDelegate);
                this._pStageGL.removeEventListener(away.events.StageGLEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);

                this._pStageGL = null;
                /*
                if (_backgroundImageRenderer) {
                _backgroundImageRenderer.dispose();
                _backgroundImageRenderer = null;
                }
                */
            };

            RendererBase.prototype.render = function (entityCollector) {
                this._viewportDirty = false;
                this._scissorDirty = false;
            };

            /**
            * Renders the potentially visible geometry to the back buffer or texture.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            * @param target An option target texture to render to.
            * @param surfaceSelector The index of a CubeTexture's face to render to.
            * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
            */
            RendererBase.prototype._iRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                if (!this._pStageGL || !this._pContext || !entityCollector.entityHead)
                    return;

                this._pRttViewProjectionMatrix.copyFrom(entityCollector.camera.viewProjection);
                this._pRttViewProjectionMatrix.appendScale(this.textureRatioX, this.textureRatioY, 1);

                this.pExecuteRender(entityCollector, target, scissorRect, surfaceSelector);

                for (var i = 0; i < 8; ++i) {
                    this._pContext.setVertexBufferAt(i, null);
                    this._pContext.setTextureAt(i, null);
                }
            };

            RendererBase.prototype.pCollectRenderables = function (entityCollector) {
                //reset head values
                this._pBlendedRenderableHead = null;
                this._pOpaqueRenderableHead = null;
                this._pNumTriangles = 0;

                //grab entity head
                var item = entityCollector.entityHead;

                //set temp values for entry point and camera forward vector
                this._pCamera = entityCollector.camera;
                this._iEntryPoint = this._pCamera.scenePosition;
                this._pCameraForward = this._pCamera.transform.forwardVector;

                while (item) {
                    item.entity._iCollectRenderables(this);
                    item = item.next;
                }

                //sort the resulting renderables
                this._pOpaqueRenderableHead = this.renderableSorter.sortOpaqueRenderables(this._pOpaqueRenderableHead);
                this._pBlendedRenderableHead = this.renderableSorter.sortBlendedRenderables(this._pBlendedRenderableHead);
            };

            /**
            * Renders the potentially visible geometry to the back buffer or texture. Only executed if everything is set up.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            * @param target An option target texture to render to.
            * @param surfaceSelector The index of a CubeTexture's face to render to.
            * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
            */
            RendererBase.prototype.pExecuteRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                this._pStageGL.setRenderTarget(target, true, surfaceSelector);

                if ((target || !this._shareContext) && !this._depthPrepass)
                    this._pContext.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);

                this._pContext.setDepthTest(false, away.stagegl.ContextGLCompareMode.ALWAYS);

                this._pStageGL.scissorRect = scissorRect;

                /*
                if (_backgroundImageRenderer)
                _backgroundImageRenderer.render();
                */
                this.pDraw(entityCollector, target);

                //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
                //this._pContext.setDepthTest(false, away.stagegl.ContextGLCompareMode.LESS_EQUAL); //oopsie
                if (!this._shareContext) {
                    if (this._snapshotRequired && this._snapshotBitmapData) {
                        this._pContext.drawToBitmapData(this._snapshotBitmapData);
                        this._snapshotRequired = false;
                    }
                }

                this._pStageGL.scissorRect = null;
            };

            /*
            * Will draw the renderer's output on next render to the provided bitmap data.
            * */
            RendererBase.prototype.queueSnapshot = function (bmd) {
                this._snapshotRequired = true;
                this._snapshotBitmapData = bmd;
            };

            /**
            * Performs the actual drawing of geometry to the target.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            */
            RendererBase.prototype.pDraw = function (entityCollector, target) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Assign the context once retrieved
            */
            RendererBase.prototype.onContextUpdate = function (event) {
                this._pContext = this._pStageGL.contextGL;
            };

            Object.defineProperty(RendererBase.prototype, "_iBackgroundAlpha", {
                get: function () {
                    return this._backgroundAlpha;
                },
                set: function (value) {
                    if (this._backgroundAlpha == value)
                        return;

                    this._backgroundAlpha = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            /*
            public get iBackground():away.textures.Texture2DBase
            {
            return this._background;
            }
            */
            /*
            public set iBackground(value:away.textures.Texture2DBase)
            {
            if (this._backgroundImageRenderer && !value) {
            this._backgroundImageRenderer.dispose();
            this._backgroundImageRenderer = null;
            }
            
            if (!this._backgroundImageRenderer && value)
            {
            
            this._backgroundImageRenderer = new BackgroundImageRenderer(this._pStageGL);
            
            }
            
            
            this._background = value;
            
            if (this._backgroundImageRenderer)
            this._backgroundImageRenderer.texture = value;
            }
            */
            /*
            public get backgroundImageRenderer():BackgroundImageRenderer
            {
            return _backgroundImageRenderer;
            }
            */
            /**
            * @private
            */
            RendererBase.prototype.notifyScissorUpdate = function () {
                if (this._scissorDirty)
                    return;

                this._scissorDirty = true;

                if (!this._scissorUpdated)
                    this._scissorUpdated = new away.events.RendererEvent(away.events.RendererEvent.SCISSOR_UPDATED);

                this.dispatchEvent(this._scissorUpdated);
            };

            /**
            * @private
            */
            RendererBase.prototype.notifyViewportUpdate = function () {
                if (this._viewportDirty)
                    return;

                this._viewportDirty = true;

                if (!this._viewPortUpdated)
                    this._viewPortUpdated = new away.events.RendererEvent(away.events.RendererEvent.VIEWPORT_UPDATED);

                this.dispatchEvent(this._viewPortUpdated);
            };

            /**
            *
            */
            RendererBase.prototype.onViewportUpdated = function (event) {
                this._viewPort = this._pStageGL.viewPort;

                //TODO stop firing viewport updated for every stagegl viewport change
                if (this._shareContext) {
                    this._pScissorRect.x = this._globalPos.x - this._pStageGL.x;
                    this._pScissorRect.y = this._globalPos.y - this._pStageGL.y;
                    this.notifyScissorUpdate();
                }

                this.notifyViewportUpdate();
            };

            /**
            *
            */
            RendererBase.prototype.updateGlobalPos = function () {
                if (this._shareContext) {
                    this._pScissorRect.x = this._globalPos.x - this._viewPort.x;
                    this._pScissorRect.y = this._globalPos.y - this._viewPort.y;
                } else {
                    this._pScissorRect.x = 0;
                    this._pScissorRect.y = 0;
                    this._viewPort.x = this._globalPos.x;
                    this._viewPort.y = this._globalPos.y;
                }

                this.notifyScissorUpdate();
            };

            /**
            *
            * @param billboard
            * @protected
            */
            RendererBase.prototype.applyBillboard = function (billboard) {
                this._applyRenderable(this._billboardRenderablePool.getItem(billboard));
            };

            /**
            *
            * @param triangleSubMesh
            */
            RendererBase.prototype.applyTriangleSubMesh = function (triangleSubMesh) {
                this._applyRenderable(this._triangleSubMeshRenderablePool.getItem(triangleSubMesh));
            };

            /**
            *
            * @param lineSubMesh
            */
            RendererBase.prototype.applyLineSubMesh = function (lineSubMesh) {
                this._applyRenderable(this._lineSubMeshRenderablePool.getItem(lineSubMesh));
            };

            /**
            *
            * @param skybox
            */
            RendererBase.prototype.applySkybox = function (skybox) {
                this._applyRenderable(this._skyboxRenderablePool.getItem(skybox));
            };

            /**
            *
            * @param renderable
            * @protected
            */
            RendererBase.prototype._applyRenderable = function (renderable) {
                var material = renderable.materialOwner.material;
                var entity = renderable.sourceEntity;
                var position = entity.scenePosition;

                if (!material)
                    material = away.materials.DefaultMaterialManager.getDefaultMaterial(renderable.materialOwner);

                //set ids for faster referencing
                renderable.material = material;
                renderable.materialId = material._iMaterialId;
                renderable.renderOrderId = material._iRenderOrderId;
                renderable.cascaded = false;

                // project onto camera's z-axis
                position = this._iEntryPoint.subtract(position);
                renderable.zIndex = entity.zOffset + position.dotProduct(this._pCameraForward);

                //store reference to scene transform
                renderable.renderSceneTransform = renderable.sourceEntity.getRenderSceneTransform(this._pCamera);

                if (material.requiresBlending) {
                    renderable.next = this._pBlendedRenderableHead;
                    this._pBlendedRenderableHead = renderable;
                } else {
                    renderable.next = this._pOpaqueRenderableHead;
                    this._pOpaqueRenderableHead = renderable;
                }

                this._pNumTriangles += renderable.numTriangles;

                //handle any overflow for renderables with data that exceeds GPU limitations
                if (renderable.overflow)
                    this._applyRenderable(renderable.overflow);
            };
            return RendererBase;
        })(away.events.EventDispatcher);
        render.RendererBase = RendererBase;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.render
    */
    (function (render) {
        /**
        * The DepthRenderer class renders 32-bit depth information encoded as RGBA
        *
        * @class away.render.DepthRenderer
        */
        var DepthRenderer = (function (_super) {
            __extends(DepthRenderer, _super);
            /**
            * Creates a new DepthRenderer object.
            * @param renderBlended Indicates whether semi-transparent objects should be rendered.
            * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
            */
            function DepthRenderer(renderBlended, distanceBased) {
                if (typeof renderBlended === "undefined") { renderBlended = false; }
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                _super.call(this);

                this._renderBlended = renderBlended;
                this._distanceBased = distanceBased;
                this._iBackgroundR = 1;
                this._iBackgroundG = 1;
                this._iBackgroundB = 1;
            }
            Object.defineProperty(DepthRenderer.prototype, "disableColor", {
                get: function () {
                    return this._disableColor;
                },
                set: function (value) {
                    this._disableColor = value;
                },
                enumerable: true,
                configurable: true
            });


            DepthRenderer.prototype.iRenderCascades = function (entityCollector, target, numCascades, scissorRects, cameras) {
                this.pCollectRenderables(entityCollector);

                this._pStageGL.setRenderTarget(target, true, 0);
                this._pContext.clear(1, 1, 1, 1, 1, 0);

                this._pContext.setBlendFactors(away.stagegl.ContextGLBlendFactor.ONE, away.stagegl.ContextGLBlendFactor.ZERO);
                this._pContext.setDepthTest(true, away.stagegl.ContextGLCompareMode.LESS);

                var head = this._pOpaqueRenderableHead;

                var first = true;

                for (var i = numCascades - 1; i >= 0; --i) {
                    this._pStageGL.scissorRect = scissorRects[i];
                    this.drawCascadeRenderables(head, cameras[i], first ? null : cameras[i].frustumPlanes);
                    first = false;
                }

                if (this._activeMaterial)
                    this._activeMaterial.iDeactivateForDepth(this._pStageGL);

                this._activeMaterial = null;

                //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
                this._pContext.setDepthTest(false, away.stagegl.ContextGLCompareMode.LESS_EQUAL);

                this._pStageGL.scissorRect = null;
            };

            DepthRenderer.prototype.drawCascadeRenderables = function (renderable, camera, cullPlanes) {
                var material;

                while (renderable) {
                    if (renderable.cascaded) {
                        renderable = renderable.next;
                        continue;
                    }

                    var entity = renderable.sourceEntity;

                    // if completely in front, it will fall in a different cascade
                    // do not use near and far planes
                    if (!cullPlanes || entity.worldBounds.isInFrustum(cullPlanes, 4)) {
                        material = renderable.materialOwner.material;

                        if (this._activeMaterial != material) {
                            if (this._activeMaterial)
                                this._activeMaterial.iDeactivateForDepth(this._pStageGL);

                            this._activeMaterial = material;
                            this._activeMaterial.iActivateForDepth(this._pStageGL, camera, false);
                        }

                        this._activeMaterial.iRenderDepth(renderable, this._pStageGL, camera, camera.viewProjection);
                    } else {
                        renderable.cascaded = true;
                    }

                    renderable = renderable.next;
                }
            };

            /**
            * @inheritDoc
            */
            DepthRenderer.prototype.pDraw = function (entityCollector, target) {
                this.pCollectRenderables(entityCollector);

                this._pContext.setBlendFactors(away.stagegl.ContextGLBlendFactor.ONE, away.stagegl.ContextGLBlendFactor.ZERO);

                this._pContext.setDepthTest(true, away.stagegl.ContextGLCompareMode.LESS);

                this.drawRenderables(this._pOpaqueRenderableHead, entityCollector);

                if (this._disableColor)
                    this._pContext.setColorMask(false, false, false, false);

                if (this._renderBlended)
                    this.drawRenderables(this._pBlendedRenderableHead, entityCollector);

                if (this._activeMaterial)
                    this._activeMaterial.iDeactivateForDepth(this._pStageGL);

                if (this._disableColor)
                    this._pContext.setColorMask(true, true, true, true);

                this._activeMaterial = null;
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DepthRenderer.prototype.drawRenderables = function (renderable, entityCollector) {
                var camera = entityCollector.camera;
                var renderable2;

                while (renderable) {
                    this._activeMaterial = renderable.materialOwner.material;

                    // otherwise this would result in depth rendered anyway because fragment shader kil is ignored
                    if (this._disableColor && this._activeMaterial.iHasDepthAlphaThreshold()) {
                        renderable2 = renderable;

                        do {
                            renderable2 = renderable2.next;
                        } while(renderable2 && renderable2.materialOwner.material == this._activeMaterial);
                    } else {
                        this._activeMaterial.iActivateForDepth(this._pStageGL, camera, this._distanceBased);
                        renderable2 = renderable;
                        do {
                            this._activeMaterial.iRenderDepth(renderable2, this._pStageGL, camera, this._pRttViewProjectionMatrix);
                            renderable2 = renderable2.next;
                        } while(renderable2 && renderable2.materialOwner.material == this._activeMaterial);

                        this._activeMaterial.iDeactivateForDepth(this._pStageGL);
                    }

                    renderable = renderable2;
                }
            };
            return DepthRenderer;
        })(render.RendererBase);
        render.DepthRenderer = DepthRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.render
    */
    (function (render) {
        /**
        * The DefaultRenderer class provides the default rendering method. It renders the scene graph objects using the
        * materials assigned to them.
        *
        * @class away.render.DefaultRenderer
        */
        var DefaultRenderer = (function (_super) {
            __extends(DefaultRenderer, _super);
            /**
            * Creates a new DefaultRenderer object.
            *
            * @param antiAlias The amount of anti-aliasing to use.
            * @param renderMode The render mode to use.
            */
            function DefaultRenderer(forceSoftware, profile, mode) {
                if (typeof forceSoftware === "undefined") { forceSoftware = false; }
                if (typeof profile === "undefined") { profile = "baseline"; }
                if (typeof mode === "undefined") { mode = "auto"; }
                _super.call(this);
                this._skyboxProjection = new away.geom.Matrix3D();

                this._pDepthRenderer = new render.DepthRenderer();
                this._pDistanceRenderer = new render.DepthRenderer(false, true);

                if (this._pStageGL == null)
                    this.stageGL = away.managers.StageGLManager.getInstance().getFreeStageGL(forceSoftware, profile, mode);

                this._pRttBufferManager = away.managers.RTTBufferManager.getInstance(this._pStageGL);

                if (this._width == 0)
                    this.width = window.innerWidth;
                else
                    this._pRttBufferManager.viewWidth = this._width;

                if (this._height == 0)
                    this.height = window.innerHeight;
                else
                    this._pRttBufferManager.viewHeight = this._height;
            }
            Object.defineProperty(DefaultRenderer.prototype, "antiAlias", {
                get: function () {
                    return this._antiAlias;
                },
                set: function (value) {
                    if (this._antiAlias == value)
                        return;

                    this._antiAlias = value;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DefaultRenderer.prototype, "depthPrepass", {
                /**
                *
                */
                get: function () {
                    return this._depthPrepass;
                },
                set: function (value) {
                    this._depthPrepass = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DefaultRenderer.prototype, "filters3d", {
                /**
                *
                * @returns {*}
                */
                get: function () {
                    return this._pFilter3DRenderer ? this._pFilter3DRenderer.filters : null;
                },
                set: function (value) {
                    if (value && value.length == 0)
                        value = null;

                    if (this._pFilter3DRenderer && !value) {
                        this._pFilter3DRenderer.dispose();
                        this._pFilter3DRenderer = null;
                    } else if (!this._pFilter3DRenderer && value) {
                        this._pFilter3DRenderer = new render.Filter3DRenderer(this._pStageGL);
                        this._pFilter3DRenderer.filters = value;
                    }

                    if (this._pFilter3DRenderer) {
                        this._pFilter3DRenderer.filters = value;
                        this._pRequireDepthRender = this._pFilter3DRenderer.requireDepthRender;
                    } else {
                        this._pRequireDepthRender = false;

                        if (this._pDepthRender) {
                            this._pDepthRender.dispose();
                            this._pDepthRender = null;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            DefaultRenderer.prototype.render = function (entityCollector) {
                _super.prototype.render.call(this, entityCollector);

                if (!this._pStageGL.recoverFromDisposal()) {
                    this._pBackBufferInvalid = true;
                    return;
                }

                if (this._pBackBufferInvalid)
                    this.pUpdateBackBuffer();

                if (this._shareContext)
                    this._pStageGL.clearDepthBuffer();

                if (this._pFilter3DRenderer) {
                    this.textureRatioX = this._pRttBufferManager.textureRatioX;
                    this.textureRatioY = this._pRttBufferManager.textureRatioY;
                } else {
                    this.textureRatioX = 1;
                    this.textureRatioY = 1;
                }

                if (this._pRequireDepthRender)
                    this.pRenderSceneDepthToTexture(entityCollector);

                if (this._depthPrepass)
                    this.pRenderDepthPrepass(entityCollector);

                if (this._pFilter3DRenderer && this._pStageGL.contextGL) {
                    //this._iRender(entityCollector, this._pFilter3DRenderer.getMainInputTexture(this._pStageGL), this._pRttBufferManager.renderToTextureRect);
                    //this._pFilter3DRenderer.render(this._pStageGL, entityCollector.camera, this._pDepthRender);
                } else {
                    if (this._shareContext)
                        this._iRender(entityCollector, null, this._pScissorRect);
                    else
                        this._iRender(entityCollector);
                }

                _super.prototype.render.call(this, entityCollector);

                if (!this._shareContext)
                    this._pStageGL.present();

                // register that a view has been rendered
                this._pStageGL.bufferClear = false;
            };

            DefaultRenderer.prototype.pExecuteRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                this.updateLights(entityCollector);

                // otherwise RTT will interfere with other RTTs
                if (target) {
                    this.pCollectRenderables(entityCollector);

                    this.drawRenderables(this._pOpaqueRenderableHead, entityCollector, DefaultRenderer.RTT_PASSES);
                    this.drawRenderables(this._pBlendedRenderableHead, entityCollector, DefaultRenderer.RTT_PASSES);
                }

                _super.prototype.pExecuteRender.call(this, entityCollector, target, scissorRect, surfaceSelector);
            };

            DefaultRenderer.prototype.updateLights = function (entityCollector) {
                var dirLights = entityCollector.directionalLights;
                var pointLights = entityCollector.pointLights;
                var len, i;
                var light;
                var shadowMapper;

                len = dirLights.length;
                for (i = 0; i < len; ++i) {
                    light = dirLights[i];

                    shadowMapper = light.shadowMapper;

                    if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
                        shadowMapper.iRenderDepthMap(this._pStageGL, entityCollector, this._pDepthRenderer);
                }

                len = pointLights.length;
                for (i = 0; i < len; ++i) {
                    light = pointLights[i];

                    shadowMapper = light.shadowMapper;

                    if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
                        shadowMapper.iRenderDepthMap(this._pStageGL, entityCollector, this._pDistanceRenderer);
                }
            };

            /**
            * @inheritDoc
            */
            DefaultRenderer.prototype.pDraw = function (entityCollector, target) {
                if (!target)
                    this.pCollectRenderables(entityCollector);

                this._pContext.setBlendFactors(away.stagegl.ContextGLBlendFactor.ONE, away.stagegl.ContextGLBlendFactor.ZERO);

                if (entityCollector.skyBox) {
                    if (this._activeMaterial)
                        this._activeMaterial.iDeactivate(this._pStageGL);

                    this._activeMaterial = null;

                    this._pContext.setDepthTest(false, away.stagegl.ContextGLCompareMode.ALWAYS);
                    this.drawSkybox(entityCollector);
                }

                this._pContext.setDepthTest(true, away.stagegl.ContextGLCompareMode.LESS_EQUAL);

                var which = target ? DefaultRenderer.SCREEN_PASSES : DefaultRenderer.ALL_PASSES;

                this.drawRenderables(this._pOpaqueRenderableHead, entityCollector, which);
                this.drawRenderables(this._pBlendedRenderableHead, entityCollector, which);

                this._pContext.setDepthTest(false, away.stagegl.ContextGLCompareMode.LESS_EQUAL);

                if (this._activeMaterial)
                    this._activeMaterial.iDeactivate(this._pStageGL);

                this._activeMaterial = null;
            };

            /**
            * Draw the skybox if present.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DefaultRenderer.prototype.drawSkybox = function (entityCollector) {
                var skyBox = entityCollector.skyBox;

                var material = skyBox.material;

                var camera = entityCollector.camera;

                this.updateSkyboxProjection(camera);

                material.iActivatePass(0, this._pStageGL, camera);
                material.iRenderPass(0, skyBox, this._pStageGL, entityCollector, this._skyboxProjection);
                material.iDeactivatePass(0, this._pStageGL);
            };

            DefaultRenderer.prototype.updateSkyboxProjection = function (camera) {
                var near = new away.geom.Vector3D();

                this._skyboxProjection.copyFrom(this._pRttViewProjectionMatrix);
                this._skyboxProjection.copyRowTo(2, near);

                var camPos = camera.scenePosition;

                var cx = near.x;
                var cy = near.y;
                var cz = near.z;
                var cw = -(near.x * camPos.x + near.y * camPos.y + near.z * camPos.z + Math.sqrt(cx * cx + cy * cy + cz * cz));

                var signX = cx >= 0 ? 1 : -1;
                var signY = cy >= 0 ? 1 : -1;

                var p = new away.geom.Vector3D(signX, signY, 1, 1);

                var inverse = this._skyboxProjection.clone();
                inverse.invert();

                var q = inverse.transformVector(p);

                this._skyboxProjection.copyRowTo(3, p);

                var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);

                this._skyboxProjection.copyRowFrom(2, new away.geom.Vector3D(cx * a, cy * a, cz * a, cw * a));
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DefaultRenderer.prototype.drawRenderables = function (renderable, entityCollector, which) {
                var numPasses;
                var j;
                var camera = entityCollector.camera;
                var renderable2;

                while (renderable) {
                    this._activeMaterial = renderable.material;

                    this._activeMaterial.iUpdateMaterial(this._pContext);

                    numPasses = this._activeMaterial._iNumPasses;

                    j = 0;

                    do {
                        renderable2 = renderable;

                        var rttMask = this._activeMaterial.iPassRendersToTexture(j) ? 1 : 2;

                        if ((rttMask & which) != 0) {
                            this._activeMaterial.iActivatePass(j, this._pStageGL, camera);

                            do {
                                this._activeMaterial.iRenderPass(j, renderable2, this._pStageGL, entityCollector, this._pRttViewProjectionMatrix);

                                renderable2 = renderable2.next;
                            } while(renderable2 && renderable2.material == this._activeMaterial);

                            this._activeMaterial.iDeactivatePass(j, this._pStageGL);
                        } else {
                            do {
                                renderable2 = renderable2.next;
                            } while(renderable2 && renderable2.material == this._activeMaterial);
                        }
                    } while(++j < numPasses);

                    renderable = renderable2;
                }
            };

            DefaultRenderer.prototype.dispose = function () {
                if (!this._shareContext)
                    this._pStageGL.dispose();

                this._pDepthRenderer.dispose();
                this._pDistanceRenderer.dispose();
                this._pDepthRenderer = null;
                this._pDistanceRenderer = null;

                this._pDepthRender = null;

                _super.prototype.dispose.call(this);
            };

            /**
            *
            */
            DefaultRenderer.prototype.pRenderDepthPrepass = function (entityCollector) {
                this._pDepthRenderer.disableColor = true;

                if (this._pFilter3DRenderer) {
                    //				this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
                    //				this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
                    //				this._pDepthRenderer._iRender(entityCollector, this._pFilter3DRenderer.getMainInputTexture(this._pStageGL), this._pRttBufferManager.renderToTextureRect);
                } else {
                    this._pDepthRenderer.textureRatioX = 1;
                    this._pDepthRenderer.textureRatioY = 1;
                    this._pDepthRenderer._iRender(entityCollector);
                }

                this._pDepthRenderer.disableColor = false;
            };

            /**
            *
            */
            DefaultRenderer.prototype.pRenderSceneDepthToTexture = function (entityCollector) {
                if (this._pDepthTextureInvalid || !this._pDepthRender)
                    this.initDepthTexture(this._pStageGL.contextGL);

                this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
                this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
                this._pDepthRenderer._iRender(entityCollector, this._pDepthRender);
            };

            /**
            * Updates the backbuffer dimensions.
            */
            DefaultRenderer.prototype.pUpdateBackBuffer = function () {
                // No reason trying to configure back buffer if there is no context available.
                // Doing this anyway (and relying on _stageGL to cache width/height for
                // context does get available) means usesSoftwareRendering won't be reliable.
                if (this._pStageGL.contextGL && !this._shareContext) {
                    if (this._width && this._height) {
                        this._pStageGL.configureBackBuffer(this._width, this._height, this._antiAlias, true);
                        this._pBackBufferInvalid = false;
                    }
                }
            };

            DefaultRenderer.prototype.iSetStageGL = function (value) {
                _super.prototype.iSetStageGL.call(this, value);

                this._pDistanceRenderer.iSetStageGL(value);
                this._pDepthRenderer.iSetStageGL(value);
            };

            /**
            *
            */
            DefaultRenderer.prototype.initDepthTexture = function (context) {
                this._pDepthTextureInvalid = false;

                if (this._pDepthRender)
                    this._pDepthRender.dispose();

                this._pDepthRender = new away.textures.RenderTexture(this._pRttBufferManager.textureWidth, this._pRttBufferManager.textureHeight);
            };
            DefaultRenderer.RTT_PASSES = 1;
            DefaultRenderer.SCREEN_PASSES = 2;
            DefaultRenderer.ALL_PASSES = 3;
            return DefaultRenderer;
        })(render.RendererBase);
        render.DefaultRenderer = DefaultRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    * @module away.render
    */
    (function (render) {
        /**
        * @class away.render.Filter3DRenderer
        */
        var Filter3DRenderer = (function () {
            function Filter3DRenderer(stageGL) {
                this._filterSizesInvalid = true;
                this._onRTTResizeDelegate = away.utils.Delegate.create(this, this.onRTTResize);

                this._stageGL = stageGL;
                this._rttManager = away.managers.RTTBufferManager.getInstance(stageGL);
                this._rttManager.addEventListener(away.events.Event.RESIZE, this._onRTTResizeDelegate);
            }
            Filter3DRenderer.prototype.onRTTResize = function (event) {
                this._filterSizesInvalid = true;
            };

            Object.defineProperty(Filter3DRenderer.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DRenderer.prototype.getMainInputTexture = function (stageGL) {
                if (this._filterTasksInvalid) {
                    this.updateFilterTasks(stageGL);
                }

                return this._mainInputTexture;
            };

            Object.defineProperty(Filter3DRenderer.prototype, "filters", {
                get: function () {
                    return this._filters;
                },
                set: function (value) {
                    this._filters = value;

                    this._filterTasksInvalid = true;

                    this._requireDepthRender = false;

                    if (!this._filters) {
                        return;
                    }

                    for (var i = 0; i < this._filters.length; ++i) {
                        // TODO: check logic:
                        // this._requireDepthRender ||=  Boolean ( this._filters[i].requireDepthRender )
                        var s = this._filters[i];
                        var b = (s.requireDepthRender == null) ? false : s.requireDepthRender;

                        this._requireDepthRender = this._requireDepthRender || b;
                    }

                    this._filterSizesInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Filter3DRenderer.prototype.updateFilterTasks = function (stageGL) {
                var len;

                if (this._filterSizesInvalid) {
                    this.updateFilterSizes();
                }

                if (!this._filters) {
                    this._tasks = null;
                    return;
                }

                this._tasks = new Array();

                len = this._filters.length - 1;

                var filter;

                for (var i = 0; i <= len; ++i) {
                    // make sure all internal tasks are linked together
                    filter = this._filters[i];

                    // TODO: check logic
                    // filter.setRenderTargets(i == len? null : Filter3DBase(_filters[i + 1]).getMainInputTexture(stageGL), stageGL);
                    filter.setRenderTargets(i == len ? null : this._filters[i + 1].getMainInputTexture(stageGL), stageGL);

                    this._tasks = this._tasks.concat(filter.tasks);
                }

                this._mainInputTexture = this._filters[0].getMainInputTexture(stageGL);
            };

            Filter3DRenderer.prototype.render = function (stageGL, camera, depthTexture) {
                var len;
                var i;
                var task;
                var context = stageGL.contextGL;

                var indexBuffer = this._rttManager.indexBuffer;

                var vertexBuffer = this._rttManager.renderToTextureVertexBuffer;

                if (!this._filters) {
                    return;
                }

                if (this._filterSizesInvalid) {
                    this.updateFilterSizes();
                }

                if (this._filterTasksInvalid) {
                    this.updateFilterTasks(stageGL);
                }

                len = this._filters.length;

                for (i = 0; i < len; ++i) {
                    this._filters[i].update(stageGL, camera);
                }

                len = this._tasks.length;

                if (len > 1) {
                    context.setVertexBufferAt(0, vertexBuffer, 0, away.stagegl.ContextGLVertexBufferFormat.FLOAT_2);
                    context.setVertexBufferAt(1, vertexBuffer, 2, away.stagegl.ContextGLVertexBufferFormat.FLOAT_2);
                }

                for (i = 0; i < len; ++i) {
                    task = this._tasks[i];

                    //stageGL.setRenderTarget(task.target); //TODO
                    if (!task.target) {
                        stageGL.scissorRect = null;
                        vertexBuffer = this._rttManager.renderToScreenVertexBuffer;
                        context.setVertexBufferAt(0, vertexBuffer, 0, away.stagegl.ContextGLVertexBufferFormat.FLOAT_2);
                        context.setVertexBufferAt(1, vertexBuffer, 2, away.stagegl.ContextGLVertexBufferFormat.FLOAT_2);
                    }

                    context.setTextureAt(0, task.getMainInputTexture(stageGL));
                    context.setProgram(task.getProgram(stageGL));
                    context.clear(0.0, 0.0, 0.0, 0.0);

                    task.activate(stageGL, camera, depthTexture);

                    context.setBlendFactors(away.stagegl.ContextGLBlendFactor.ONE, away.stagegl.ContextGLBlendFactor.ZERO);
                    context.drawTriangles(indexBuffer, 0, 2);

                    task.deactivate(stageGL);
                }

                context.setTextureAt(0, null);
                context.setVertexBufferAt(0, null);
                context.setVertexBufferAt(1, null);
            };

            Filter3DRenderer.prototype.updateFilterSizes = function () {
                for (var i = 0; i < this._filters.length; ++i) {
                    this._filters[i].textureWidth = this._rttManager.textureWidth;
                    this._filters[i].textureHeight = this._rttManager.textureHeight;
                }

                this._filterSizesInvalid = true;
            };

            Filter3DRenderer.prototype.dispose = function () {
                this._rttManager.removeEventListener(away.events.Event.RESIZE, this._onRTTResizeDelegate);
                this._rttManager = null;
                this._stageGL = null;
            };
            return Filter3DRenderer;
        })();
        render.Filter3DRenderer = Filter3DRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var DefaultMaterialManager = (function () {
            function DefaultMaterialManager() {
            }
            DefaultMaterialManager.getDefaultMaterial = function (materialOwner) {
                if (typeof materialOwner === "undefined") { materialOwner = null; }
                if (materialOwner != null && materialOwner.assetType == away.library.AssetType.LINE_SUB_MESH) {
                    if (!DefaultMaterialManager._defaultSegmentMaterial)
                        DefaultMaterialManager.createDefaultSegmentMaterial();

                    return DefaultMaterialManager._defaultSegmentMaterial;
                } else {
                    if (!DefaultMaterialManager._defaultTextureMaterial)
                        DefaultMaterialManager.createDefaultTextureMaterial();

                    return DefaultMaterialManager._defaultTextureMaterial;
                }
            };

            DefaultMaterialManager.getDefaultTexture = function (materialOwner) {
                if (typeof materialOwner === "undefined") { materialOwner = null; }
                if (!DefaultMaterialManager._defaultTexture)
                    DefaultMaterialManager.createDefaultTexture();

                return DefaultMaterialManager._defaultTexture;
            };

            DefaultMaterialManager.createDefaultTexture = function () {
                DefaultMaterialManager._defaultTextureBitmapData = DefaultMaterialManager.createCheckeredBitmapData();
                DefaultMaterialManager._defaultTexture = new away.textures.BitmapTexture(DefaultMaterialManager._defaultTextureBitmapData, true);
                DefaultMaterialManager._defaultTexture.name = "defaultTexture";
            };

            DefaultMaterialManager.createCheckeredBitmapData = function () {
                var b = new away.base.BitmapData(8, 8, false, 0x000000);

                //create chekerboard
                var i, j;
                for (i = 0; i < 8; i++) {
                    for (j = 0; j < 8; j++) {
                        if ((j & 1) ^ (i & 1)) {
                            b.setPixel(i, j, 0XFFFFFF);
                        }
                    }
                }

                return b;
            };

            DefaultMaterialManager.createDefaultTextureMaterial = function () {
                if (!DefaultMaterialManager._defaultTexture)
                    DefaultMaterialManager.createDefaultTexture();

                DefaultMaterialManager._defaultTextureMaterial = new materials.TextureMaterial(DefaultMaterialManager._defaultTexture);
                DefaultMaterialManager._defaultTextureMaterial.mipmap = false;
                DefaultMaterialManager._defaultTextureMaterial.smooth = false;
                DefaultMaterialManager._defaultTextureMaterial.name = "defaultTextureMaterial";
            };

            DefaultMaterialManager.createDefaultSegmentMaterial = function () {
                DefaultMaterialManager._defaultSegmentMaterial = new materials.SegmentMaterial();
                DefaultMaterialManager._defaultSegmentMaterial.name = "defaultSegmentMaterial";
            };
            return DefaultMaterialManager;
        })();
        materials.DefaultMaterialManager = DefaultMaterialManager;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (filters) {
        var Filter3DTaskBase = (function () {
            function Filter3DTaskBase(requireDepthRender) {
                if (typeof requireDepthRender === "undefined") { requireDepthRender = false; }
                this._scaledTextureWidth = -1;
                this._scaledTextureHeight = -1;
                this._textureWidth = -1;
                this._textureHeight = -1;
                this._textureDimensionsInvalid = true;
                this._program3DInvalid = true;
                this._textureScale = 0;
                this._requireDepthRender = requireDepthRender;
            }
            Object.defineProperty(Filter3DTaskBase.prototype, "textureScale", {
                /**
                * The texture scale for the input of this texture. This will define the output of the previous entry in the chain
                */
                get: function () {
                    return this._textureScale;
                },
                set: function (value) {
                    if (this._textureScale == value) {
                        return;
                    }

                    this._textureScale = value;
                    this._scaledTextureWidth = this._textureWidth >> this._textureScale;
                    this._scaledTextureHeight = this._textureHeight >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "target", {
                get: function () {
                    return this._target;
                },
                set: function (value) {
                    this._target = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "textureWidth", {
                get: function () {
                    return this._textureWidth;
                },
                set: function (value) {
                    if (this._textureWidth == value) {
                        return;
                    }

                    this._textureWidth = value;
                    this._scaledTextureWidth = this._textureWidth >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "textureHeight", {
                get: function () {
                    return this._textureHeight;
                },
                set: function (value) {
                    if (this._textureHeight == value) {
                        return;
                    }

                    this._textureHeight = value;
                    this._scaledTextureHeight = this._textureHeight >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Filter3DTaskBase.prototype.getMainInputTexture = function (stage) {
                if (this._textureDimensionsInvalid) {
                    this.pUpdateTextures(stage);
                }

                return this._mainInputTexture;
            };

            Filter3DTaskBase.prototype.dispose = function () {
                if (this._mainInputTexture) {
                    this._mainInputTexture.dispose();
                }

                if (this._program3D) {
                    this._program3D.dispose();
                }
            };

            Filter3DTaskBase.prototype.pInvalidateProgram = function () {
                this._program3DInvalid = true;
            };

            Filter3DTaskBase.prototype.pUpdateProgram = function (stage) {
                if (this._program3D) {
                    this._program3D.dispose();
                }

                this._program3D = stage.contextGL.createProgram();

                var vertexByteCode = (new aglsl.assembler.AGALMiniAssembler().assemble("part vertex 1\n" + this.pGetVertexCode() + "endpart"))['vertex'].data;
                var fragmentByteCode = (new aglsl.assembler.AGALMiniAssembler().assemble("part fragment 1\n" + this.pGetFragmentCode() + "endpart"))['fragment'].data;
                this._program3D.upload(vertexByteCode, fragmentByteCode);
                this._program3DInvalid = false;
            };

            Filter3DTaskBase.prototype.pGetVertexCode = function () {
                // TODO: imeplement AGAL <> GLSL
                return "mov op, va0\n" + "mov v0, va1\n";
            };

            Filter3DTaskBase.prototype.pGetFragmentCode = function () {
                throw new away.errors.AbstractMethodError();

                return null;
            };

            Filter3DTaskBase.prototype.pUpdateTextures = function (stage) {
                if (this._mainInputTexture) {
                    this._mainInputTexture.dispose();
                }

                this._mainInputTexture = stage.contextGL.createTexture(this._scaledTextureWidth, this._scaledTextureHeight, away.stagegl.ContextGLTextureFormat.BGRA, true);

                this._textureDimensionsInvalid = false;
            };

            Filter3DTaskBase.prototype.getProgram = function (stageGL) {
                if (this._program3DInvalid) {
                    this.pUpdateProgram(stageGL);
                }

                return this._program3D;
            };

            Filter3DTaskBase.prototype.activate = function (stageGL, camera, depthTexture) {
            };

            Filter3DTaskBase.prototype.deactivate = function (stageGL) {
            };

            Object.defineProperty(Filter3DTaskBase.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });
            return Filter3DTaskBase;
        })();
        filters.Filter3DTaskBase = Filter3DTaskBase;
    })(away.filters || (away.filters = {}));
    var filters = away.filters;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (filters) {
        var Filter3DBase = (function () {
            function Filter3DBase() {
                this._tasks = new Array();
            }
            Object.defineProperty(Filter3DBase.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DBase.prototype.pAddTask = function (filter) {
                this._tasks.push(filter);

                if (this._requireDepthRender == null) {
                    this._requireDepthRender = filter.requireDepthRender;
                }
            };

            Object.defineProperty(Filter3DBase.prototype, "tasks", {
                get: function () {
                    return this._tasks;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DBase.prototype.getMainInputTexture = function (stageGL) {
                return this._tasks[0].getMainInputTexture(stageGL);
            };

            Object.defineProperty(Filter3DBase.prototype, "textureWidth", {
                get: function () {
                    return this._textureWidth;
                },
                set: function (value) {
                    this._textureWidth = value;

                    for (var i = 0; i < this._tasks.length; ++i) {
                        this._tasks[i].textureWidth = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DBase.prototype, "textureHeight", {
                get: function () {
                    return this._textureHeight;
                },
                set: function (value) {
                    this._textureHeight = value;

                    for (var i = 0; i < this._tasks.length; ++i) {
                        this._tasks[i].textureHeight = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            // link up the filters correctly with the next filter
            Filter3DBase.prototype.setRenderTargets = function (mainTarget, stageGL) {
                this._tasks[this._tasks.length - 1].target = mainTarget;
            };

            Filter3DBase.prototype.dispose = function () {
                for (var i = 0; i < this._tasks.length; ++i) {
                    this._tasks[i].dispose();
                }
            };

            Filter3DBase.prototype.update = function (stage, camera) {
            };
            return Filter3DBase;
        })();
        filters.Filter3DBase = Filter3DBase;
    })(away.filters || (away.filters = {}));
    var filters = away.filters;
})(away || (away = {}));
///<reference path="../_definitions.ts" />
var away;
(function (away) {
    (function (lights) {
        var LightBase = (function (_super) {
            __extends(LightBase, _super);
            function LightBase() {
                _super.call(this);
                this._color = 0xffffff;
                this._colorR = 1;
                this._colorG = 1;
                this._colorB = 1;
                this._ambientColor = 0xffffff;
                this._ambient = 0;
                this._iAmbientR = 0;
                this._iAmbientG = 0;
                this._iAmbientB = 0;
                this._specular = 1;
                this._iSpecularR = 1;
                this._iSpecularG = 1;
                this._iSpecularB = 1;
                this._diffuse = 1;
                this._iDiffuseR = 1;
                this._iDiffuseG = 1;
                this._iDiffuseB = 1;
                this._castsShadows = false;
            }
            Object.defineProperty(LightBase.prototype, "castsShadows", {
                get: function () {
                    return this._castsShadows;
                },
                set: function (value) {
                    if (this._castsShadows == value)
                        return;

                    this._castsShadows = value;

                    if (value) {
                        if (this._shadowMapper == null)
                            this._shadowMapper = this.pCreateShadowMapper();

                        this._shadowMapper.light = this;
                    } else {
                        this._shadowMapper.dispose();
                        this._shadowMapper = null;
                    }

                    //*/
                    this.dispatchEvent(new away.events.LightEvent(away.events.LightEvent.CASTS_SHADOW_CHANGE));
                },
                enumerable: true,
                configurable: true
            });


            LightBase.prototype.pCreateShadowMapper = function () {
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(LightBase.prototype, "specular", {
                get: function () {
                    return this._specular;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;

                    this._specular = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "diffuse", {
                get: function () {
                    return this._diffuse;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;

                    this._diffuse = value;
                    this.updateDiffuse();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value;
                    this._colorR = ((this._color >> 16) & 0xff) / 0xff;
                    this._colorG = ((this._color >> 8) & 0xff) / 0xff;
                    this._colorB = (this._color & 0xff) / 0xff;
                    this.updateDiffuse();
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "ambient", {
                get: function () {
                    return this._ambient;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
                    else if (value > 1)
                        value = 1;

                    this._ambient = value;
                    this.updateAmbient();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "ambientColor", {
                get: function () {
                    return this._ambientColor;
                },
                set: function (value) {
                    this._ambientColor = value;
                    this.updateAmbient();
                },
                enumerable: true,
                configurable: true
            });


            LightBase.prototype.updateAmbient = function () {
                this._iAmbientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
                this._iAmbientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
                this._iAmbientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
            };

            LightBase.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
                if (typeof target === "undefined") { target = null; }
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(LightBase.prototype, "assetType", {
                //@override
                get: function () {
                    return away.library.AssetType.LIGHT;
                },
                enumerable: true,
                configurable: true
            });

            LightBase.prototype.updateSpecular = function () {
                this._iSpecularR = this._colorR * this._specular;
                this._iSpecularG = this._colorG * this._specular;
                this._iSpecularB = this._colorB * this._specular;
            };

            LightBase.prototype.updateDiffuse = function () {
                this._iDiffuseR = this._colorR * this._diffuse;
                this._iDiffuseG = this._colorG * this._diffuse;
                this._iDiffuseB = this._colorB * this._diffuse;
            };

            Object.defineProperty(LightBase.prototype, "shadowMapper", {
                get: function () {
                    return this._shadowMapper;
                },
                set: function (value) {
                    this._shadowMapper = value;
                    this._shadowMapper.light = this;
                },
                enumerable: true,
                configurable: true
            });

            return LightBase;
        })(away.containers.DisplayObjectContainer);
        lights.LightBase = LightBase;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
///<reference path="../_definitions.ts" />
var away;
(function (away) {
    (function (lights) {
        var LightProbe = (function (_super) {
            __extends(LightProbe, _super);
            function LightProbe(diffuseMap, specularMap) {
                if (typeof specularMap === "undefined") { specularMap = null; }
                _super.call(this);

                this._pIsEntity = true;

                this._diffuseMap = diffuseMap;
                this._specularMap = specularMap;
            }
            Object.defineProperty(LightProbe.prototype, "diffuseMap", {
                get: function () {
                    return this._diffuseMap;
                },
                set: function (value) {
                    this._diffuseMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightProbe.prototype, "specularMap", {
                get: function () {
                    return this._specularMap;
                },
                set: function (value) {
                    this._specularMap = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @protected
            */
            LightProbe.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.LightProbeNode(this);
            };

            //@override
            LightProbe.prototype.pUpdateBounds = function () {
                this._pBoundsInvalid = false;
            };

            //@override
            LightProbe.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            //@override
            LightProbe.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
                if (typeof target === "undefined") { target = null; }
                throw new away.errors.Error("Object projection matrices are not supported for LightProbe objects!");
            };

            LightProbe.prototype._iCollectRenderables = function (renderer) {
                //nothing to do here
            };
            return LightProbe;
        })(away.lights.LightBase);
        lights.LightProbe = LightProbe;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (lights) {
        var PointLight = (function (_super) {
            __extends(PointLight, _super);
            function PointLight() {
                _super.call(this);
                this._pRadius = 90000;
                this._pFallOff = 100000;

                this._pIsEntity = true;

                this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
            }
            PointLight.prototype.pCreateShadowMapper = function () {
                return new away.lights.CubeMapShadowMapper();
            };

            Object.defineProperty(PointLight.prototype, "radius", {
                get: function () {
                    return this._pRadius;
                },
                set: function (value) {
                    this._pRadius = value;

                    if (this._pRadius < 0) {
                        this._pRadius = 0;
                    } else if (this._pRadius > this._pFallOff) {
                        this._pFallOff = this._pRadius;
                        this.pInvalidateBounds();
                    }
                    this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
                },
                enumerable: true,
                configurable: true
            });


            PointLight.prototype.iFallOffFactor = function () {
                return this._pFallOffFactor;
            };

            Object.defineProperty(PointLight.prototype, "fallOff", {
                get: function () {
                    return this._pFallOff;
                },
                set: function (value) {
                    this._pFallOff = value;

                    if (this._pFallOff < 0)
                        this._pFallOff = 0;

                    if (this._pFallOff < this._pRadius)
                        this._pRadius = this._pFallOff;

                    this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
                    this.pInvalidateBounds();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @protected
            */
            PointLight.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.PointLightNode(this);
            };

            PointLight.prototype.pUpdateBounds = function () {
                this._pBounds.fromSphere(new away.geom.Vector3D(), this._pFallOff);
                this._pBoundsInvalid = false;
            };

            PointLight.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.BoundingSphere();
            };

            PointLight.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
                if (typeof target === "undefined") { target = null; }
                var raw = new Array(16);
                var bounds = entity.bounds;
                var m = new away.geom.Matrix3D();

                // todo: do not use lookAt on Light
                m.copyFrom(entity.getRenderSceneTransform(camera));
                m.append(this._pParent.inverseSceneTransform);
                this.lookAt(m.position);

                m.copyFrom(entity.getRenderSceneTransform(camera));
                m.append(this.inverseSceneTransform);

                var box = bounds.aabb;
                var v1 = m.deltaTransformVector(new away.geom.Vector3D(box.left, box.bottom, box.front));
                var v2 = m.deltaTransformVector(new away.geom.Vector3D(box.right, box.top, box.back));
                var d1 = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
                var d2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
                var d = Math.sqrt(d1 > d2 ? d1 : d2);
                var zMin;
                var zMax;

                var z = m.rawData[14];
                zMin = z - d;
                zMax = z + d;

                raw[5] = raw[0] = zMin / d;
                raw[10] = zMax / (zMax - zMin);
                raw[11] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[12] = raw[13] = raw[15] = 0;
                raw[14] = -zMin * raw[10];

                if (!target)
                    target = new away.geom.Matrix3D();

                target.copyRawDataFrom(raw);
                target.prepend(m);

                return target;
            };

            PointLight.prototype._iCollectRenderables = function (renderer) {
                //nothing to do here
            };
            return PointLight;
        })(away.lights.LightBase);
        lights.PointLight = PointLight;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
///<reference path="../_definitions.ts" />
var away;
(function (away) {
    (function (lights) {
        var DirectionalLight = (function (_super) {
            __extends(DirectionalLight, _super);
            function DirectionalLight(xDir, yDir, zDir) {
                if (typeof xDir === "undefined") { xDir = 0; }
                if (typeof yDir === "undefined") { yDir = -1; }
                if (typeof zDir === "undefined") { zDir = 1; }
                _super.call(this);

                this._pIsEntity = true;

                this.direction = new away.geom.Vector3D(xDir, yDir, zDir);

                this._sceneDirection = new away.geom.Vector3D();
            }
            Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
                get: function () {
                    if (this._pSceneTransformDirty)
                        this.pUpdateSceneTransform();

                    return this._sceneDirection;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DirectionalLight.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (value) {
                    this._direction = value;

                    if (!this._tmpLookAt)
                        this._tmpLookAt = new away.geom.Vector3D();

                    this._tmpLookAt.x = this.x + this._direction.x;
                    this._tmpLookAt.y = this.y + this._direction.y;
                    this._tmpLookAt.z = this.z + this._direction.z;

                    this.lookAt(this._tmpLookAt);
                },
                enumerable: true,
                configurable: true
            });


            //@override
            DirectionalLight.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            //@override
            DirectionalLight.prototype.pUpdateBounds = function () {
            };

            //@override
            DirectionalLight.prototype.pUpdateSceneTransform = function () {
                _super.prototype.pUpdateSceneTransform.call(this);
                this.sceneTransform.copyColumnTo(2, this._sceneDirection);
                this._sceneDirection.normalize();
            };

            //@override
            DirectionalLight.prototype.pCreateShadowMapper = function () {
                return new away.lights.DirectionalShadowMapper();
            };

            /**
            * @protected
            */
            DirectionalLight.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.DirectionalLightNode(this);
            };

            //override
            DirectionalLight.prototype.iGetObjectProjectionMatrix = function (entity, camera, target) {
                if (typeof target === "undefined") { target = null; }
                var raw = new Array();
                var bounds = entity.bounds;
                var m = new away.geom.Matrix3D();

                m.copyFrom(entity.getRenderSceneTransform(camera));
                m.append(this.inverseSceneTransform);

                if (!this._projAABBPoints)
                    this._projAABBPoints = [];

                m.transformVectors(bounds.aabbPoints, this._projAABBPoints);

                var xMin = Infinity, xMax = -Infinity;
                var yMin = Infinity, yMax = -Infinity;
                var zMin = Infinity, zMax = -Infinity;
                var d;
                for (var i = 0; i < 24;) {
                    d = this._projAABBPoints[i++];

                    if (d < xMin)
                        xMin = d;

                    if (d > xMax)
                        xMax = d;

                    d = this._projAABBPoints[i++];

                    if (d < yMin)
                        yMin = d;

                    if (d > yMax)
                        yMax = d;

                    d = this._projAABBPoints[i++];

                    if (d < zMin)
                        zMin = d;

                    if (d > zMax)
                        zMax = d;
                }

                var invXRange = 1 / (xMax - xMin);
                var invYRange = 1 / (yMax - yMin);
                var invZRange = 1 / (zMax - zMin);
                raw[0] = 2 * invXRange;
                raw[5] = 2 * invYRange;
                raw[10] = invZRange;
                raw[12] = -(xMax + xMin) * invXRange;
                raw[13] = -(yMax + yMin) * invYRange;
                raw[14] = -zMin * invZRange;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
                raw[15] = 1;

                if (!target)
                    target = new away.geom.Matrix3D();

                target.copyRawDataFrom(raw);
                target.prepend(m);

                return target;
            };

            DirectionalLight.prototype._iCollectRenderables = function (renderer) {
                //nothing to do here
            };
            return DirectionalLight;
        })(away.lights.LightBase);
        lights.DirectionalLight = DirectionalLight;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (lights) {
        var ShadowMapperBase = (function () {
            function ShadowMapperBase() {
                this._pDepthMapSize = 2048;
                this._autoUpdateShadows = true;
                this._pCasterCollector = this.pCreateCasterCollector();
            }
            ShadowMapperBase.prototype.pCreateCasterCollector = function () {
                return new away.traverse.ShadowCasterCollector();
            };

            Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
                get: function () {
                    return this._autoUpdateShadows;
                },
                set: function (value) {
                    this._autoUpdateShadows = value;
                },
                enumerable: true,
                configurable: true
            });


            ShadowMapperBase.prototype.updateShadows = function () {
                this._iShadowsInvalid = true;
            };

            ShadowMapperBase.prototype.iSetDepthMap = function (depthMap) {
                if (this._depthMap == depthMap)
                    return;

                if (this._depthMap && !this._explicitDepthMap)
                    this._depthMap.dispose();

                this._depthMap = depthMap;

                if (this._depthMap) {
                    this._explicitDepthMap = true;
                    this._pDepthMapSize = this._depthMap.size;
                } else {
                    this._explicitDepthMap = false;
                }
            };

            Object.defineProperty(ShadowMapperBase.prototype, "light", {
                get: function () {
                    return this._pLight;
                },
                set: function (value) {
                    this._pLight = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
                get: function () {
                    if (!this._depthMap)
                        this._depthMap = this.pCreateDepthTexture();

                    return this._depthMap;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
                get: function () {
                    return this._pDepthMapSize;
                },
                set: function (value) {
                    if (value == this._pDepthMapSize)
                        return;

                    this._pSetDepthMapSize(value);
                },
                enumerable: true,
                configurable: true
            });


            ShadowMapperBase.prototype.dispose = function () {
                this._pCasterCollector = null;

                if (this._depthMap && !this._explicitDepthMap)
                    this._depthMap.dispose();

                this._depthMap = null;
            };

            ShadowMapperBase.prototype.pCreateDepthTexture = function () {
                return new away.textures.RenderTexture(this._pDepthMapSize, this._pDepthMapSize);
            };

            ShadowMapperBase.prototype.iRenderDepthMap = function (stageGL, entityCollector, renderer) {
                this._iShadowsInvalid = false;

                this.pUpdateDepthProjection(entityCollector.camera);

                if (!this._depthMap)
                    this._depthMap = this.pCreateDepthTexture();

                this.pDrawDepthMap(this._depthMap, entityCollector.scene, renderer);
            };

            ShadowMapperBase.prototype.pUpdateDepthProjection = function (viewCamera) {
                throw new away.errors.AbstractMethodError();
            };

            ShadowMapperBase.prototype.pDrawDepthMap = function (target, scene, renderer) {
                throw new away.errors.AbstractMethodError();
            };

            ShadowMapperBase.prototype._pSetDepthMapSize = function (value) {
                this._pDepthMapSize = value;

                if (this._explicitDepthMap) {
                    throw Error("Cannot set depth map size for the current renderer.");
                } else if (this._depthMap) {
                    this._depthMap.dispose();
                    this._depthMap = null;
                }
            };
            return ShadowMapperBase;
        })();
        lights.ShadowMapperBase = ShadowMapperBase;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (lights) {
        var CubeMapShadowMapper = (function (_super) {
            __extends(CubeMapShadowMapper, _super);
            function CubeMapShadowMapper() {
                _super.call(this);

                this._pDepthMapSize = 512;
                this._needsRender = [];
                this.initCameras();
            }
            CubeMapShadowMapper.prototype.initCameras = function () {
                this._depthCameras = [];
                this._projections = [];

                // posX, negX, posY, negY, posZ, negZ
                this.addCamera(0, 90, 0);
                this.addCamera(0, -90, 0);
                this.addCamera(-90, 0, 0);
                this.addCamera(90, 0, 0);
                this.addCamera(0, 0, 0);
                this.addCamera(0, 180, 0);
            };

            CubeMapShadowMapper.prototype.addCamera = function (rotationX, rotationY, rotationZ) {
                var cam = new away.entities.Camera();
                cam.rotationX = rotationX;
                cam.rotationY = rotationY;
                cam.rotationZ = rotationZ;
                cam.projection.near = .01;

                var projection = cam.projection;
                projection.fieldOfView = 90;
                this._projections.push(projection);
                cam.projection._iAspectRatio = 1;
                this._depthCameras.push(cam);
            };

            //@override
            CubeMapShadowMapper.prototype.pCreateDepthTexture = function () {
                throw new away.errors.PartialImplementationError();
                /*
                return new away.textures.RenderCubeTexture( this._depthMapSize );
                */
            };

            //@override
            CubeMapShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                var light = (this._pLight);
                var maxDistance = light._pFallOff;
                var pos = this._pLight.scenePosition;

                for (var i = 0; i < 6; ++i) {
                    this._projections[i].far = maxDistance;
                    this._depthCameras[i].transform.position = pos;
                    this._needsRender[i] = true;
                }
            };

            //@override
            CubeMapShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
                for (var i = 0; i < 6; ++i) {
                    if (this._needsRender[i]) {
                        this._pCasterCollector.camera = this._depthCameras[i];
                        this._pCasterCollector.clear();
                        scene.traversePartitions(this._pCasterCollector);
                        renderer._iRender(this._pCasterCollector, target, null, i);
                    }
                }
            };
            return CubeMapShadowMapper;
        })(away.lights.ShadowMapperBase);
        lights.CubeMapShadowMapper = CubeMapShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
///<reference path="../../_definitions.ts" />
var away;
(function (away) {
    (function (lights) {
        var DirectionalShadowMapper = (function (_super) {
            __extends(DirectionalShadowMapper, _super);
            function DirectionalShadowMapper() {
                _super.call(this);
                this._pLightOffset = 10000;
                this._pSnap = 64;
                this._pCullPlanes = [];
                this._pOverallDepthProjection = new away.projections.FreeMatrixProjection();
                this._pOverallDepthCamera = new away.entities.Camera(this._pOverallDepthProjection);
                this._pLocalFrustum = [];
                this._pMatrix = new away.geom.Matrix3D();
            }
            Object.defineProperty(DirectionalShadowMapper.prototype, "snap", {
                get: function () {
                    return this._pSnap;
                },
                set: function (value) {
                    this._pSnap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DirectionalShadowMapper.prototype, "lightOffset", {
                get: function () {
                    return this._pLightOffset;
                },
                set: function (value) {
                    this._pLightOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DirectionalShadowMapper.prototype, "iDepthProjection", {
                //@arcane
                get: function () {
                    return this._pOverallDepthCamera.viewProjection;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
                //@arcane
                get: function () {
                    return this._pMaxZ - this._pMinZ;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            DirectionalShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
                this._pCasterCollector.camera = this._pOverallDepthCamera;
                this._pCasterCollector.cullPlanes = this._pCullPlanes;
                this._pCasterCollector.clear();
                scene.traversePartitions(this._pCasterCollector);
                renderer._iRender(this._pCasterCollector, target);
            };

            //@protected
            DirectionalShadowMapper.prototype.pUpdateCullPlanes = function (viewCamera) {
                var lightFrustumPlanes = this._pOverallDepthCamera.frustumPlanes;
                var viewFrustumPlanes = viewCamera.frustumPlanes;
                this._pCullPlanes.length = 4;

                this._pCullPlanes[0] = lightFrustumPlanes[0];
                this._pCullPlanes[1] = lightFrustumPlanes[1];
                this._pCullPlanes[2] = lightFrustumPlanes[2];
                this._pCullPlanes[3] = lightFrustumPlanes[3];

                var light = this._pLight;
                var dir = light.sceneDirection;
                var dirX = dir.x;
                var dirY = dir.y;
                var dirZ = dir.z;
                var j = 4;
                for (var i = 0; i < 6; ++i) {
                    var plane = viewFrustumPlanes[i];
                    if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0) {
                        this._pCullPlanes[j++] = plane;
                    }
                }
            };

            //@override
            DirectionalShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                this.pUpdateProjectionFromFrustumCorners(viewCamera, viewCamera.projection.frustumCorners, this._pMatrix);
                this._pOverallDepthProjection.matrix = this._pMatrix;
                this.pUpdateCullPlanes(viewCamera);
            };

            DirectionalShadowMapper.prototype.pUpdateProjectionFromFrustumCorners = function (viewCamera, corners, matrix) {
                var raw = new Array();
                var dir;
                var x, y, z;
                var minX, minY;
                var maxX, maxY;
                var i;

                var light = this._pLight;
                dir = light.sceneDirection;
                this._pOverallDepthCamera.transform.matrix3D = this._pLight.sceneTransform;
                x = Math.floor((viewCamera.x - dir.x * this._pLightOffset) / this._pSnap) * this._pSnap;
                y = Math.floor((viewCamera.y - dir.y * this._pLightOffset) / this._pSnap) * this._pSnap;
                z = Math.floor((viewCamera.z - dir.z * this._pLightOffset) / this._pSnap) * this._pSnap;
                this._pOverallDepthCamera.x = x;
                this._pOverallDepthCamera.y = y;
                this._pOverallDepthCamera.z = z;

                this._pMatrix.copyFrom(this._pOverallDepthCamera.inverseSceneTransform);
                this._pMatrix.prepend(viewCamera.sceneTransform);
                this._pMatrix.transformVectors(corners, this._pLocalFrustum);

                minX = maxX = this._pLocalFrustum[0];
                minY = maxY = this._pLocalFrustum[1];
                this._pMaxZ = this._pLocalFrustum[2];

                i = 3;
                while (i < 24) {
                    x = this._pLocalFrustum[i];
                    y = this._pLocalFrustum[i + 1];
                    z = this._pLocalFrustum[i + 2];
                    if (x < minX)
                        minX = x;
                    if (x > maxX)
                        maxX = x;
                    if (y < minY)
                        minY = y;
                    if (y > maxY)
                        maxY = y;
                    if (z > this._pMaxZ)
                        this._pMaxZ = z;
                    i += 3;
                }
                this._pMinZ = 1;

                var w = maxX - minX;
                var h = maxY - minY;
                var d = 1 / (this._pMaxZ - this._pMinZ);

                if (minX < 0) {
                    minX -= this._pSnap; // because int() rounds up for < 0
                }
                if (minY < 0) {
                    minY -= this._pSnap;
                }
                minX = Math.floor(minX / this._pSnap) * this._pSnap;
                minY = Math.floor(minY / this._pSnap) * this._pSnap;

                var snap2 = 2 * this._pSnap;
                w = Math.floor(w / snap2 + 2) * snap2;
                h = Math.floor(h / snap2 + 2) * snap2;

                maxX = minX + w;
                maxY = minY + h;

                w = 1 / w;
                h = 1 / h;

                raw[0] = 2 * w;
                raw[5] = 2 * h;
                raw[10] = d;
                raw[12] = -(maxX + minX) * w;
                raw[13] = -(maxY + minY) * h;
                raw[14] = -this._pMinZ * d;
                raw[15] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;

                matrix.copyRawDataFrom(raw);
            };
            return DirectionalShadowMapper;
        })(away.lights.ShadowMapperBase);
        lights.DirectionalShadowMapper = DirectionalShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    (function (lights) {
        var Camera = away.entities.Camera;
        var FreeMatrixProjection = away.projections.FreeMatrixProjection;

        var Matrix3DUtils = away.geom.Matrix3DUtils;

        //	import Event					= away.events.Event;
        var EventDispatcher = away.events.EventDispatcher;

        var Rectangle = away.geom.Rectangle;

        var CascadeShadowMapper = (function (_super) {
            __extends(CascadeShadowMapper, _super);
            function CascadeShadowMapper(numCascades) {
                if (typeof numCascades === "undefined") { numCascades = 3; }
                _super.call(this);
                this._pScissorRectsInvalid = true;

                if (numCascades < 1 || numCascades > 4)
                    throw new Error("numCascades must be an integer between 1 and 4");

                this._numCascades = numCascades;
                this._changeDispatcher = new EventDispatcher(this);
                this.init();
            }
            CascadeShadowMapper.prototype.getSplitRatio = function (index /*uint*/ ) {
                return this._splitRatios[index];
            };

            CascadeShadowMapper.prototype.setSplitRatio = function (index /*uint*/ , value) {
                if (value < 0)
                    value = 0;
                else if (value > 1)
                    value = 1;

                if (index >= this._numCascades)
                    throw new Error("index must be smaller than the number of cascades!");

                this._splitRatios[index] = value;
            };

            CascadeShadowMapper.prototype.getDepthProjections = function (partition /*uint*/ ) {
                return this._depthCameras[partition].viewProjection;
            };

            CascadeShadowMapper.prototype.init = function () {
                this._splitRatios = new Array(this._numCascades);
                this._nearPlaneDistances = new Array(this._numCascades);

                var s = 1;
                for (var i = this._numCascades - 1; i >= 0; --i) {
                    this._splitRatios[i] = s;
                    s *= .4;
                }

                this._texOffsetsX = Array(-1, 1, -1, 1);
                this._texOffsetsY = Array(1, 1, -1, -1);
                this._pScissorRects = new Array(4);
                this._depthLenses = new Array();
                this._depthCameras = new Array();

                for (i = 0; i < this._numCascades; ++i) {
                    this._depthLenses[i] = new FreeMatrixProjection();
                    this._depthCameras[i] = new Camera(this._depthLenses[i]);
                }
            };

            CascadeShadowMapper.prototype._pSetDepthMapSize = function (value /*uint*/ ) {
                _super.prototype._pSetDepthMapSize.call(this, value);

                this.invalidateScissorRects();
            };

            CascadeShadowMapper.prototype.invalidateScissorRects = function () {
                this._pScissorRectsInvalid = true;
            };

            Object.defineProperty(CascadeShadowMapper.prototype, "numCascades", {
                get: function () {
                    return this._numCascades;
                },
                set: function (value /*int*/ ) {
                    if (value == this._numCascades)
                        return;
                    if (value < 1 || value > 4)
                        throw new Error("numCascades must be an integer between 1 and 4");
                    this._numCascades = value;
                    this.invalidateScissorRects();
                    this.init();
                    this.dispatchEvent(new away.events.Event(away.events.Event.CHANGE));
                },
                enumerable: true,
                configurable: true
            });


            CascadeShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
                if (this._pScissorRectsInvalid)
                    this.updateScissorRects();

                this._pCasterCollector.cullPlanes = this._pCullPlanes;
                this._pCasterCollector.camera = this._pOverallDepthCamera;
                this._pCasterCollector.clear();
                scene.traversePartitions(this._pCasterCollector);

                renderer.iRenderCascades(this._pCasterCollector, target, this._numCascades, this._pScissorRects, this._depthCameras);
            };

            CascadeShadowMapper.prototype.updateScissorRects = function () {
                var half = this._pDepthMapSize * .5;

                this._pScissorRects[0] = new Rectangle(0, 0, half, half);
                this._pScissorRects[1] = new Rectangle(half, 0, half, half);
                this._pScissorRects[2] = new Rectangle(0, half, half, half);
                this._pScissorRects[3] = new Rectangle(half, half, half, half);

                this._pScissorRectsInvalid = false;
            };

            CascadeShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                var matrix;
                var projection = viewCamera.projection;
                var projectionNear = projection.near;
                var projectionRange = projection.far - projectionNear;

                this.pUpdateProjectionFromFrustumCorners(viewCamera, viewCamera.projection.frustumCorners, this._pMatrix);
                this._pMatrix.appendScale(.96, .96, 1);
                this._pOverallDepthProjection.matrix = this._pMatrix;
                this.pUpdateCullPlanes(viewCamera);

                for (var i = 0; i < this._numCascades; ++i) {
                    matrix = this._depthLenses[i].matrix;

                    this._nearPlaneDistances[i] = projectionNear + this._splitRatios[i] * projectionRange;
                    this._depthCameras[i].transform = this._pOverallDepthCamera.transform;

                    this.updateProjectionPartition(matrix, this._splitRatios[i], this._texOffsetsX[i], this._texOffsetsY[i]);

                    this._depthLenses[i].matrix = matrix;
                }
            };

            CascadeShadowMapper.prototype.updateProjectionPartition = function (matrix, splitRatio, texOffsetX, texOffsetY) {
                var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
                var xN, yN, zN;
                var xF, yF, zF;
                var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, minZ;
                var maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY, maxZ = Number.NEGATIVE_INFINITY;
                var i = 0;

                while (i < 12) {
                    xN = this._pLocalFrustum[i];
                    yN = this._pLocalFrustum[i + 1];
                    zN = this._pLocalFrustum[i + 2];
                    xF = xN + (this._pLocalFrustum[i + 12] - xN) * splitRatio;
                    yF = yN + (this._pLocalFrustum[i + 13] - yN) * splitRatio;
                    zF = zN + (this._pLocalFrustum[i + 14] - zN) * splitRatio;
                    if (xN < minX)
                        minX = xN;
                    if (xN > maxX)
                        maxX = xN;
                    if (yN < minY)
                        minY = yN;
                    if (yN > maxY)
                        maxY = yN;
                    if (zN > maxZ)
                        maxZ = zN;
                    if (xF < minX)
                        minX = xF;
                    if (xF > maxX)
                        maxX = xF;
                    if (yF < minY)
                        minY = yF;
                    if (yF > maxY)
                        maxY = yF;
                    if (zF > maxZ)
                        maxZ = zF;
                    i += 3;
                }

                minZ = 1;

                var w = (maxX - minX);
                var h = (maxY - minY);
                var d = 1 / (maxZ - minZ);

                if (minX < 0)
                    minX -= this._pSnap; // because int() rounds up for < 0
                if (minY < 0)
                    minY -= this._pSnap;
                minX = Math.floor(minX / this._pSnap) * this._pSnap;
                minY = Math.floor(minY / this._pSnap) * this._pSnap;

                var snap2 = 2 * this._pSnap;
                w = Math.floor(w / snap2 + 1) * snap2;
                h = Math.floor(h / snap2 + 1) * snap2;

                maxX = minX + w;
                maxY = minY + h;

                w = 1 / w;
                h = 1 / h;

                raw[0] = 2 * w;
                raw[5] = 2 * h;
                raw[10] = d;
                raw[12] = -(maxX + minX) * w;
                raw[13] = -(maxY + minY) * h;
                raw[14] = -minZ * d;
                raw[15] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;

                matrix.copyRawDataFrom(raw);
                matrix.appendScale(.96, .96, 1);
                matrix.appendTranslation(texOffsetX, texOffsetY, 0);
                matrix.appendScale(.5, .5, 1);
            };

            CascadeShadowMapper.prototype.addEventListener = function (type, listener) {
                this._changeDispatcher.addEventListener(type, listener);
            };

            CascadeShadowMapper.prototype.removeEventListener = function (type, listener) {
                this._changeDispatcher.removeEventListener(type, listener);
            };

            CascadeShadowMapper.prototype.dispatchEvent = function (event) {
                return this._changeDispatcher.dispatchEvent(event);
            };

            CascadeShadowMapper.prototype.hasEventListener = function (type) {
                return this._changeDispatcher.hasEventListener(type);
            };

            Object.defineProperty(CascadeShadowMapper.prototype, "_iNearPlaneDistances", {
                get: function () {
                    return this._nearPlaneDistances;
                },
                enumerable: true,
                configurable: true
            });
            return CascadeShadowMapper;
        })(lights.DirectionalShadowMapper);
        lights.CascadeShadowMapper = CascadeShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
///<reference path="../../_definitions.ts" />
var away;
(function (away) {
    (function (lights) {
        var NearDirectionalShadowMapper = (function (_super) {
            __extends(NearDirectionalShadowMapper, _super);
            function NearDirectionalShadowMapper(coverageRatio) {
                if (typeof coverageRatio === "undefined") { coverageRatio = .5; }
                _super.call(this);
                this.coverageRatio = coverageRatio;
            }
            Object.defineProperty(NearDirectionalShadowMapper.prototype, "coverageRatio", {
                /**
                * A value between 0 and 1 to indicate the ratio of the view frustum that needs to be covered by the shadow map.
                */
                get: function () {
                    return this._coverageRatio;
                },
                set: function (value) {
                    if (value > 1)
                        value = 1;
                    else if (value < 0)
                        value = 0;

                    this._coverageRatio = value;
                },
                enumerable: true,
                configurable: true
            });


            NearDirectionalShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                var corners = viewCamera.projection.frustumCorners;

                for (var i = 0; i < 12; ++i) {
                    var v = corners[i];
                    this._pLocalFrustum[i] = v;
                    this._pLocalFrustum[i + 12] = v + (corners[i + 12] - v) * this._coverageRatio;
                }

                this.pUpdateProjectionFromFrustumCorners(viewCamera, this._pLocalFrustum, this._pMatrix);
                this._pOverallDepthProjection.matrix = this._pMatrix;
            };
            return NearDirectionalShadowMapper;
        })(lights.DirectionalShadowMapper);
        lights.NearDirectionalShadowMapper = NearDirectionalShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var ContextGLBlendFactor = away.stagegl.ContextGLBlendFactor;
        var ContextGLCompareMode = away.stagegl.ContextGLCompareMode;
        var ContextGLTriangleFace = away.stagegl.ContextGLTriangleFace;

        var Event = away.events.Event;

        var Delegate = away.utils.Delegate;

        /**
        * MaterialPassBase provides an abstract base class for material shader passes. A material pass constitutes at least
        * a render call per required renderable.
        */
        var MaterialPassBase = (function (_super) {
            __extends(MaterialPassBase, _super);
            /**
            * Creates a new MaterialPassBase object.
            *
            * @param renderToTexture Indicates whether this pass is a render-to-texture pass.
            */
            function MaterialPassBase(renderToTexture) {
                if (typeof renderToTexture === "undefined") { renderToTexture = false; }
                _super.call(this);
                this._iPrograms = new Array(8);
                this._iProgramids = new Array(-1, -1, -1, -1, -1, -1, -1, -1);
                this._contextGLs = new Array(8);
                this._pSmooth = true;
                this._pRepeat = false;
                this._pMipmap = true;
                this._depthCompareMode = ContextGLCompareMode.LESS_EQUAL;
                this._blendFactorSource = ContextGLBlendFactor.ONE;
                this._blendFactorDest = ContextGLBlendFactor.ZERO;
                this._pEnableBlending = false;
                // TODO: AGAL conversion
                this._pAnimatableAttributes = new Array("va0");
                // TODO: AGAL conversion
                this._pAnimationTargetRegisters = new Array("vt0");
                // TODO: AGAL conversion
                this._pShadedTarget = "ft0";
                this._defaultCulling = ContextGLTriangleFace.BACK;
                this._pAlphaPremultiplied = false;
                this._writeDepth = true;

                this._onLightsChangeDelegate = Delegate.create(this, this.onLightsChange);

                this._renderToTexture = renderToTexture;
                this._pNumUsedStreams = 1;
                this._pNumUsedVertexConstants = 5;

                this._iUniqueId = MaterialPassBase.MATERIALPASS_ID_COUNT++;
            }
            Object.defineProperty(MaterialPassBase.prototype, "material", {
                /**
                * The material to which this pass belongs.
                */
                get: function () {
                    return this._pMaterial;
                },
                set: function (value) {
                    this._pMaterial = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "writeDepth", {
                /**
                * Indicate whether this pass should write to the depth buffer or not. Ignored when blending is enabled.
                */
                get: function () {
                    return this._writeDepth;
                },
                set: function (value) {
                    this._writeDepth = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "mipmap", {
                /**
                * Defines whether any used textures should use mipmapping.
                */
                get: function () {
                    return this._pMipmap;
                },
                set: function (value) {
                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialPassBase.prototype.setMipMap = function (value) {
                if (this._pMipmap == value) {
                    return;
                }

                this._pMipmap = value;
                this.iInvalidateShaderProgram();
            };

            Object.defineProperty(MaterialPassBase.prototype, "smooth", {
                /**
                * Defines whether smoothing should be applied to any used textures.
                */
                get: function () {
                    return this._pSmooth;
                },
                set: function (value) {
                    if (this._pSmooth == value) {
                        return;
                    }

                    this._pSmooth = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "repeat", {
                /**
                * Defines whether textures should be tiled.
                */
                get: function () {
                    return this._pRepeat;
                },
                set: function (value) {
                    if (this._pRepeat == value) {
                        return;
                    }

                    this._pRepeat = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "bothSides", {
                /**
                * Defines whether or not the material should perform backface culling.
                */
                get: function () {
                    return this._pBothSides;
                },
                set: function (value) {
                    this._pBothSides = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "depthCompareMode", {
                /**
                * The depth compare mode used to render the renderables using this material.
                *
                * @see flash.displayGL.ContextGLCompareMode
                */
                get: function () {
                    return this._depthCompareMode;
                },
                set: function (value) {
                    this._depthCompareMode = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "animationSet", {
                /**
                * Returns the animation data set adding animations to the material.
                */
                get: function () {
                    return this._animationSet;
                },
                set: function (value) {
                    if (this._animationSet == value)
                        return;

                    this._animationSet = value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "renderToTexture", {
                /**
                * Specifies whether this pass renders to texture
                */
                get: function () {
                    return this._renderToTexture;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Cleans up any resources used by the current object.
            * @param deep Indicates whether other resources should be cleaned up, that could potentially be shared across different instances.
            */
            MaterialPassBase.prototype.dispose = function () {
                if (this._pLightPicker)
                    this._pLightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);

                for (var i = 0; i < 8; ++i) {
                    if (this._iPrograms[i]) {
                        //away.Debug.throwPIR( 'MaterialPassBase' , 'dispose' , 'required dependency: AGALProgramCache');
                        away.managers.AGALProgramCache.getInstanceFromIndex(i).freeProgram(this._iProgramids[i]);
                        this._iPrograms[i] = null;
                    }
                }
            };

            Object.defineProperty(MaterialPassBase.prototype, "numUsedStreams", {
                /**
                * The amount of used vertex streams in the vertex code. Used by the animation code generation to know from which index on streams are available.
                */
                get: function () {
                    return this._pNumUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedVertexConstants", {
                /**
                * The amount of used vertex constants in the vertex code. Used by the animation code generation to know from which index on registers are available.
                */
                get: function () {
                    return this._pNumUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedVaryings", {
                get: function () {
                    return this._pNumUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedFragmentConstants", {
                /**
                * The amount of used fragment constants in the fragment code. Used by the animation code generation to know from which index on registers are available.
                */
                get: function () {
                    return this._pNumUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "needFragmentAnimation", {
                get: function () {
                    return this._pNeedFragmentAnimation;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "needUVAnimation", {
                /**
                * Indicates whether the pass requires any UV animatin code.
                */
                get: function () {
                    return this._pNeedUVAnimation;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Sets up the animation state. This needs to be called before render()
            *
            * @private
            */
            MaterialPassBase.prototype.iUpdateAnimationState = function (renderable, stageGL, camera) {
                renderable.materialOwner.animator.setRenderState(stageGL, renderable, this._pNumUsedVertexConstants, this._pNumUsedStreams, camera);
            };

            /**
            * Renders an object to the current render target.
            *
            * @private
            */
            MaterialPassBase.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Returns the vertex AGAL code for the material.
            */
            MaterialPassBase.prototype.iGetVertexCode = function () {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Returns the fragment AGAL code for the material.
            */
            MaterialPassBase.prototype.iGetFragmentCode = function (fragmentAnimatorCode) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * The blend mode to use when drawing this renderable. The following blend modes are supported:
            * <ul>
            * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
            * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
            * <li>BlendMode.MULTIPLY</li>
            * <li>BlendMode.ADD</li>
            * <li>BlendMode.ALPHA</li>
            * </ul>
            */
            MaterialPassBase.prototype.setBlendMode = function (value) {
                switch (value) {
                    case away.base.BlendMode.NORMAL:
                        this._blendFactorSource = ContextGLBlendFactor.ONE;
                        this._blendFactorDest = ContextGLBlendFactor.ZERO;
                        this._pEnableBlending = false;

                        break;

                    case away.base.BlendMode.LAYER:
                        this._blendFactorSource = ContextGLBlendFactor.SOURCE_ALPHA;
                        this._blendFactorDest = ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA;
                        this._pEnableBlending = true;

                        break;

                    case away.base.BlendMode.MULTIPLY:
                        this._blendFactorSource = ContextGLBlendFactor.ZERO;
                        this._blendFactorDest = ContextGLBlendFactor.SOURCE_COLOR;
                        this._pEnableBlending = true;

                        break;

                    case away.base.BlendMode.ADD:
                        this._blendFactorSource = ContextGLBlendFactor.SOURCE_ALPHA;
                        this._blendFactorDest = ContextGLBlendFactor.ONE;
                        this._pEnableBlending = true;

                        break;

                    case away.base.BlendMode.ALPHA:
                        this._blendFactorSource = ContextGLBlendFactor.ZERO;
                        this._blendFactorDest = ContextGLBlendFactor.SOURCE_ALPHA;
                        this._pEnableBlending = true;

                        break;

                    default:
                        throw new away.errors.ArgumentError("Unsupported blend mode!");
                }
            };

            /**
            * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
            * calling renderPass. Before activating a pass, the previously used pass needs to be deactivated.
            * @param stageGL The StageGL object which is currently used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @private
            */
            MaterialPassBase.prototype.iActivate = function (stageGL, camera) {
                var contextIndex = stageGL._iStageGLIndex;
                var context = stageGL.contextGL;

                context.setDepthTest((this._writeDepth && !this._pEnableBlending), this._depthCompareMode);

                if (this._pEnableBlending) {
                    context.setBlendFactors(this._blendFactorSource, this._blendFactorDest);
                }

                if (this._contextGLs[contextIndex] != context || !this._iPrograms[contextIndex]) {
                    this._contextGLs[contextIndex] = context;

                    this.iUpdateProgram(stageGL);
                    this.dispatchEvent(new Event(Event.CHANGE));
                }

                var prevUsed = MaterialPassBase._previousUsedStreams[contextIndex];
                var i;

                for (i = this._pNumUsedStreams; i < prevUsed; ++i) {
                    context.setVertexBufferAt(i, null);
                }

                prevUsed = MaterialPassBase._previousUsedTexs[contextIndex];

                for (i = this._pNumUsedTextures; i < prevUsed; ++i) {
                    context.setTextureAt(i, null);
                }

                if (this._animationSet && !this._animationSet.usesCPU) {
                    this._animationSet.activate(stageGL, this);
                }

                context.setProgram(this._iPrograms[contextIndex]);

                context.setCulling(this._pBothSides ? ContextGLTriangleFace.NONE : this._defaultCulling, camera.projection.coordinateSystem);

                if (this._renderToTexture) {
                    this._oldTarget = stageGL.renderTarget;
                    this._oldSurface = stageGL.renderSurfaceSelector;
                    this._oldDepthStencil = stageGL.enableDepthAndStencil;
                    this._oldRect = stageGL.scissorRect;
                }
            };

            /**
            * Clears the render state for the pass. This needs to be called before activating another pass.
            * @param stageGL The StageGL used for rendering
            *
            * @private
            */
            MaterialPassBase.prototype.iDeactivate = function (stageGL) {
                var index = stageGL._iStageGLIndex;
                MaterialPassBase._previousUsedStreams[index] = this._pNumUsedStreams;
                MaterialPassBase._previousUsedTexs[index] = this._pNumUsedTextures;

                if (this._animationSet && !this._animationSet.usesCPU) {
                    this._animationSet.deactivate(stageGL, this);
                }

                if (this._renderToTexture) {
                    // kindly restore state
                    stageGL.setRenderTarget(this._oldTarget, this._oldDepthStencil, this._oldSurface);
                    stageGL.scissorRect = this._oldRect;
                }

                stageGL.contextGL.setDepthTest(true, ContextGLCompareMode.LESS_EQUAL); // TODO : imeplement
            };

            /**
            * Marks the shader program as invalid, so it will be recompiled before the next render.
            *
            * @param updateMaterial Indicates whether the invalidation should be performed on the entire material. Should always pass "true" unless it's called from the material itself.
            */
            MaterialPassBase.prototype.iInvalidateShaderProgram = function (updateMaterial) {
                if (typeof updateMaterial === "undefined") { updateMaterial = true; }
                for (var i = 0; i < 8; ++i) {
                    this._iPrograms[i] = null;
                }

                if (this._pMaterial && updateMaterial) {
                    this._pMaterial.iInvalidatePasses(this);
                }
            };

            /**
            * Compiles the shader program.
            * @param polyOffsetReg An optional register that contains an amount by which to inflate the model (used in single object depth map rendering).
            */
            MaterialPassBase.prototype.iUpdateProgram = function (stageGL) {
                var animatorCode = "";
                var UVAnimatorCode = "";
                var fragmentAnimatorCode = "";
                var vertexCode = this.iGetVertexCode();

                if (this._animationSet && !this._animationSet.usesCPU) {
                    animatorCode = this._animationSet.getAGALVertexCode(this, this._pAnimatableAttributes, this._pAnimationTargetRegisters, stageGL.profile);

                    if (this._pNeedFragmentAnimation)
                        fragmentAnimatorCode = this._animationSet.getAGALFragmentCode(this, this._pShadedTarget, stageGL.profile);

                    if (this._pNeedUVAnimation)
                        UVAnimatorCode = this._animationSet.getAGALUVCode(this, this._pUVSource, this._pUVTarget);

                    this._animationSet.doneAGALCode(this);
                } else {
                    var len = this._pAnimatableAttributes.length;

                    for (var i = 0; i < len; ++i)
                        animatorCode += "mov " + this._pAnimationTargetRegisters[i] + ", " + this._pAnimatableAttributes[i] + "\n";

                    if (this._pNeedUVAnimation)
                        UVAnimatorCode = "mov " + this._pUVTarget + "," + this._pUVSource + "\n";
                }

                vertexCode = animatorCode + UVAnimatorCode + vertexCode;

                var fragmentCode = this.iGetFragmentCode(fragmentAnimatorCode);

                /*
                if (this.Debug.active) {
                trace("Compiling AGAL Code:");
                trace("--------------------");
                trace(vertexCode);
                trace("--------------------");
                trace(fragmentCode);
                }
                */
                away.managers.AGALProgramCache.getInstance(stageGL).setProgram(this._iProgramids, this._iPrograms, vertexCode, fragmentCode);
            };

            Object.defineProperty(MaterialPassBase.prototype, "lightPicker", {
                /**
                * The light picker used by the material to provide lights to the material if it supports lighting.
                *
                * @see away.materials.LightPickerBase
                * @see away.materials.StaticLightPicker
                */
                get: function () {
                    return this._pLightPicker;
                },
                set: function (value) {
                    if (this._pLightPicker) {
                        this._pLightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);
                    }

                    this._pLightPicker = value;

                    if (this._pLightPicker) {
                        this._pLightPicker.addEventListener(Event.CHANGE, this._onLightsChangeDelegate);
                    }

                    this.pUpdateLights();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Called when the light picker's configuration changes.
            */
            MaterialPassBase.prototype.onLightsChange = function (event) {
                this.pUpdateLights();
            };

            /**
            * Implemented by subclasses if the pass uses lights to update the shader.
            */
            MaterialPassBase.prototype.pUpdateLights = function () {
            };

            Object.defineProperty(MaterialPassBase.prototype, "alphaPremultiplied", {
                /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied. Toggle this if you are seeing black halos around your
                * blended alpha edges.
                */
                get: function () {
                    return this._pAlphaPremultiplied;
                },
                set: function (value) {
                    this._pAlphaPremultiplied = value;
                    this.iInvalidateShaderProgram(false);
                },
                enumerable: true,
                configurable: true
            });

            MaterialPassBase.MATERIALPASS_ID_COUNT = 0;

            MaterialPassBase._previousUsedStreams = new Array(0, 0, 0, 0, 0, 0, 0, 0);
            MaterialPassBase._previousUsedTexs = new Array(0, 0, 0, 0, 0, 0, 0, 0);
            return MaterialPassBase;
        })(away.events.EventDispatcher);
        materials.MaterialPassBase = MaterialPassBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var SubGeometry = away.base.TriangleSubGeometry;

        var Matrix3DUtils = away.geom.Matrix3DUtils;

        var Delegate = away.utils.Delegate;

        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        /**
        * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var CompiledPass = (function (_super) {
            __extends(CompiledPass, _super);
            /**
            * Creates a new CompiledPass object.
            * @param material The material to which this pass belongs.
            */
            function CompiledPass(material) {
                _super.call(this);
                this._pSpecularLightSources = 0x01;
                this._pDiffuseLightSources = 0x03;
                this._pVertexConstantData = new Array();
                this._pFragmentConstantData = new Array();
                this._preserveAlpha = true;
                this._animateUVs = false;
                this._pNumPointLights = 0;
                this._pNumDirectionalLights = 0;
                this._pNumLightProbes = 0;
                this._enableLightFallOff = true;
                this._forceSeparateMVP = false;

                this._pMaterial = material;

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                this.init();
            }
            Object.defineProperty(CompiledPass.prototype, "enableLightFallOff", {
                /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                get: function () {
                    return this._enableLightFallOff;
                },
                set: function (value) {
                    if (value != this._enableLightFallOff)
                        this.iInvalidateShaderProgram(true);

                    this._enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "forceSeparateMVP", {
                /**
                * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
                * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
                * projection code.
                */
                get: function () {
                    return this._forceSeparateMVP;
                },
                set: function (value) {
                    this._forceSeparateMVP = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "iNumPointLights", {
                /**
                * The amount of point lights that need to be supported.
                */
                get: function () {
                    return this._pNumPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "iNumDirectionalLights", {
                /**
                * The amount of directional lights that need to be supported.
                */
                get: function () {
                    return this._pNumDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "iNumLightProbes", {
                /**
                * The amount of light probes that need to be supported.
                */
                get: function () {
                    return this._pNumLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iUpdateProgram = function (stageGL) {
                this.reset(stageGL.profile);
                _super.prototype.iUpdateProgram.call(this, stageGL);
            };

            /**
            * Resets the compilation state.
            *
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.reset = function (profile) {
                this.iInitCompiler(profile);

                this.pUpdateShaderProperties(); //this.updateShaderProperties();
                this.initConstantData();

                this.pCleanUp(); //this.cleanUp();
            };

            /**
            * Updates the amount of used register indices.
            */
            CompiledPass.prototype.updateUsedOffsets = function () {
                this._pNumUsedVertexConstants = this._pCompiler.numUsedVertexConstants;
                this._pNumUsedFragmentConstants = this._pCompiler.numUsedFragmentConstants;
                this._pNumUsedStreams = this._pCompiler.numUsedStreams;
                this._pNumUsedTextures = this._pCompiler.numUsedTextures;
                this._pNumUsedVaryings = this._pCompiler.numUsedVaryings;
                this._pNumUsedFragmentConstants = this._pCompiler.numUsedFragmentConstants;
            };

            /**
            * Initializes the unchanging constant data for this material.
            */
            CompiledPass.prototype.initConstantData = function () {
                this._pVertexConstantData.length = this._pNumUsedVertexConstants * 4;
                this._pFragmentConstantData.length = this._pNumUsedFragmentConstants * 4;

                this.pInitCommonsData(); //this.initCommonsData();

                if (this._uvTransformIndex >= 0)
                    this.pInitUVTransformData();

                if (this._pCameraPositionIndex >= 0)
                    this._pVertexConstantData[this._pCameraPositionIndex + 3] = 1;

                this.pUpdateMethodConstants();
            };

            /**
            * Initializes the compiler for this pass.
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.iInitCompiler = function (profile) {
                this._pCompiler = this.pCreateCompiler(profile);
                this._pCompiler.forceSeperateMVP = this._forceSeparateMVP;
                this._pCompiler.numPointLights = this._pNumPointLights;
                this._pCompiler.numDirectionalLights = this._pNumDirectionalLights;
                this._pCompiler.numLightProbes = this._pNumLightProbes;
                this._pCompiler.methodSetup = this._pMethodSetup;
                this._pCompiler.diffuseLightSources = this._pDiffuseLightSources;
                this._pCompiler.specularLightSources = this._pSpecularLightSources;
                this._pCompiler.setTextureSampling(this._pSmooth, this._pRepeat, this._pMipmap);
                this._pCompiler.setConstantDataBuffers(this._pVertexConstantData, this._pFragmentConstantData);
                this._pCompiler.animateUVs = this._animateUVs;
                this._pCompiler.alphaPremultiplied = this._pAlphaPremultiplied && this._pEnableBlending;
                this._pCompiler.preserveAlpha = this._preserveAlpha && this._pEnableBlending;
                this._pCompiler.enableLightFallOff = this._enableLightFallOff;
                this._pCompiler.compile();
            };

            /**
            * Factory method to create a concrete compiler object for this pass.
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.pCreateCompiler = function (profile) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Copies the shader's properties from the compiler.
            */
            CompiledPass.prototype.pUpdateShaderProperties = function () {
                this._pAnimatableAttributes = this._pCompiler.animatableAttributes;
                this._pAnimationTargetRegisters = this._pCompiler.animationTargetRegisters;
                this._vertexCode = this._pCompiler.vertexCode;
                this._fragmentLightCode = this._pCompiler.fragmentLightCode;
                this._framentPostLightCode = this._pCompiler.fragmentPostLightCode;
                this._pShadedTarget = this._pCompiler.shadedTarget;
                this._usingSpecularMethod = this._pCompiler.usingSpecularMethod;
                this._usesNormals = this._pCompiler.usesNormals;
                this._pNeedUVAnimation = this._pCompiler.needUVAnimation;
                this._pUVSource = this._pCompiler.UVSource;
                this._pUVTarget = this._pCompiler.UVTarget;

                this.pUpdateRegisterIndices();
                this.updateUsedOffsets();
            };

            /**
            * Updates the indices for various registers.
            */
            CompiledPass.prototype.pUpdateRegisterIndices = function () {
                this._uvBufferIndex = this._pCompiler.uvBufferIndex;
                this._uvTransformIndex = this._pCompiler.uvTransformIndex;
                this._secondaryUVBufferIndex = this._pCompiler.secondaryUVBufferIndex;
                this._normalBufferIndex = this._pCompiler.normalBufferIndex;
                this._tangentBufferIndex = this._pCompiler.tangentBufferIndex;
                this._pLightFragmentConstantIndex = this._pCompiler.lightFragmentConstantIndex;
                this._pCameraPositionIndex = this._pCompiler.cameraPositionIndex;
                this._commonsDataIndex = this._pCompiler.commonsDataIndex;
                this._sceneMatrixIndex = this._pCompiler.sceneMatrixIndex;
                this._sceneNormalMatrixIndex = this._pCompiler.sceneNormalMatrixIndex;
                this._pProbeWeightsIndex = this._pCompiler.probeWeightsIndex;
                this._pLightProbeDiffuseIndices = this._pCompiler.lightProbeDiffuseIndices;
                this._pLightProbeSpecularIndices = this._pCompiler.lightProbeSpecularIndices;
            };

            Object.defineProperty(CompiledPass.prototype, "preserveAlpha", {
                /**
                * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
                */
                get: function () {
                    return this._preserveAlpha;
                },
                set: function (value) {
                    if (this._preserveAlpha == value)
                        return;

                    this._preserveAlpha = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "animateUVs", {
                /**
                * Indicate whether UV coordinates need to be animated using the renderable's transformUV matrix.
                */
                get: function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;

                    if ((value && !this._animateUVs) || (!value && this._animateUVs))
                        this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "mipmap", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    if (this._pMipmap == value)
                        return;

                    _super.prototype.setMipMap.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "normalMap", {
                /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                get: function () {
                    return this._pMethodSetup._iNormalMethod.normalMap;
                },
                set: function (value) {
                    this._pMethodSetup._iNormalMethod.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "normalMethod", {
                /**
                * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
                */
                get: function () {
                    return this._pMethodSetup.normalMethod;
                },
                set: function (value) {
                    this._pMethodSetup.normalMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "ambientMethod", {
                /**
                * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
                */
                get: function () {
                    return this._pMethodSetup.ambientMethod;
                },
                set: function (value) {
                    this._pMethodSetup.ambientMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "shadowMethod", {
                /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                get: function () {
                    return this._pMethodSetup.shadowMethod;
                },
                set: function (value) {
                    this._pMethodSetup.shadowMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "diffuseMethod", {
                /**
                * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
                */
                get: function () {
                    return this._pMethodSetup.diffuseMethod;
                },
                set: function (value) {
                    this._pMethodSetup.diffuseMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "specularMethod", {
                /**
                * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
                */
                get: function () {
                    return this._pMethodSetup.specularMethod;
                },
                set: function (value) {
                    this._pMethodSetup.specularMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Initializes the pass.
            */
            CompiledPass.prototype.init = function () {
                this._pMethodSetup = new materials.ShaderMethodSetup();

                this._pMethodSetup.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this._pMethodSetup.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._pMethodSetup.dispose();
                this._pMethodSetup = null;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iInvalidateShaderProgram = function (updateMaterial) {
                if (typeof updateMaterial === "undefined") { updateMaterial = true; }
                var oldPasses = this._iPasses;
                this._iPasses = new Array(); //= new Vector.<MaterialPassBase>();

                if (this._pMethodSetup) {
                    this.pAddPassesFromMethods(); //this.addPassesFromMethods();
                }

                if (!oldPasses || this._iPasses.length != oldPasses.length) {
                    this._iPassesDirty = true;
                    return;
                }

                for (var i = 0; i < this._iPasses.length; ++i) {
                    if (this._iPasses[i] != oldPasses[i]) {
                        this._iPassesDirty = true;
                        return;
                    }
                }

                _super.prototype.iInvalidateShaderProgram.call(this, updateMaterial);
            };

            /**
            * Adds any possible passes needed by the used methods.
            */
            CompiledPass.prototype.pAddPassesFromMethods = function () {
                if (this._pMethodSetup._iNormalMethod && this._pMethodSetup._iNormalMethod.iHasOutput)
                    this.pAddPasses(this._pMethodSetup._iNormalMethod.passes);

                if (this._pMethodSetup._iAmbientMethod)
                    this.pAddPasses(this._pMethodSetup._iAmbientMethod.passes);

                if (this._pMethodSetup._iShadowMethod)
                    this.pAddPasses(this._pMethodSetup._iShadowMethod.passes);

                if (this._pMethodSetup._iDiffuseMethod)
                    this.pAddPasses(this._pMethodSetup._iDiffuseMethod.passes);

                if (this._pMethodSetup._iSpecularMethod)
                    this.pAddPasses(this._pMethodSetup._iSpecularMethod.passes);
            };

            /**
            * Adds internal passes to the material.
            *
            * @param passes The passes to add.
            */
            CompiledPass.prototype.pAddPasses = function (passes) {
                if (!passes)
                    return;

                var len = passes.length;

                for (var i = 0; i < len; ++i) {
                    passes[i].material = this.material;
                    passes[i].lightPicker = this._pLightPicker;
                    this._iPasses.push(passes[i]);
                }
            };

            /**
            * Initializes the default UV transformation matrix.
            */
            CompiledPass.prototype.pInitUVTransformData = function () {
                this._pVertexConstantData[this._uvTransformIndex] = 1;
                this._pVertexConstantData[this._uvTransformIndex + 1] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 2] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 3] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 4] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 5] = 1;
                this._pVertexConstantData[this._uvTransformIndex + 6] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 7] = 0;
            };

            /**
            * Initializes commonly required constant values.
            */
            CompiledPass.prototype.pInitCommonsData = function () {
                this._pFragmentConstantData[this._commonsDataIndex] = .5;
                this._pFragmentConstantData[this._commonsDataIndex + 1] = 0;
                this._pFragmentConstantData[this._commonsDataIndex + 2] = 1 / 255;
                this._pFragmentConstantData[this._commonsDataIndex + 3] = 1;
            };

            /**
            * Cleans up the after compiling.
            */
            CompiledPass.prototype.pCleanUp = function () {
                this._pCompiler.dispose();
                this._pCompiler = null;
            };

            /**
            * Updates method constants if they have changed.
            */
            CompiledPass.prototype.pUpdateMethodConstants = function () {
                if (this._pMethodSetup._iNormalMethod)
                    this._pMethodSetup._iNormalMethod.iInitConstants(this._pMethodSetup._iNormalMethodVO);

                if (this._pMethodSetup._iDiffuseMethod)
                    this._pMethodSetup._iDiffuseMethod.iInitConstants(this._pMethodSetup._iDiffuseMethodVO);

                if (this._pMethodSetup._iAmbientMethod)
                    this._pMethodSetup._iAmbientMethod.iInitConstants(this._pMethodSetup._iAmbientMethodVO);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iInitConstants(this._pMethodSetup._iSpecularMethodVO);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iInitConstants(this._pMethodSetup._iShadowMethodVO);
            };

            /**
            * Updates constant data render state used by the lights. This method is optional for subclasses to implement.
            */
            CompiledPass.prototype.pUpdateLightConstants = function () {
                // up to subclasses to optionally implement
            };

            /**
            * Updates constant data render state used by the light probes. This method is optional for subclasses to implement.
            */
            CompiledPass.prototype.pUpdateProbes = function (stageGL) {
            };

            /**
            * Called when any method's shader code is invalidated.
            */
            CompiledPass.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram(); //invalidateShaderProgram();
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iGetVertexCode = function () {
                return this._vertexCode;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iGetFragmentCode = function (animatorCode) {
                //TODO: AGAL <> GLSL conversion
                return this._fragmentLightCode + animatorCode + this._framentPostLightCode;
            };

            // RENDER LOOP
            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (this._usesNormals)
                    this._pMethodSetup._iNormalMethod.iActivate(this._pMethodSetup._iNormalMethodVO, stageGL);

                this._pMethodSetup._iAmbientMethod.iActivate(this._pMethodSetup._iAmbientMethodVO, stageGL);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iActivate(this._pMethodSetup._iShadowMethodVO, stageGL);

                this._pMethodSetup._iDiffuseMethod.iActivate(this._pMethodSetup._iDiffuseMethodVO, stageGL);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iActivate(this._pMethodSetup._iSpecularMethodVO, stageGL);
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var i;
                var context = stageGL.contextGL;
                if (this._uvBufferIndex >= 0)
                    stageGL.activateBuffer(this._uvBufferIndex, renderable.getVertexData(SubGeometry.UV_DATA), renderable.getVertexOffset(SubGeometry.UV_DATA), SubGeometry.UV_FORMAT);

                if (this._secondaryUVBufferIndex >= 0)
                    stageGL.activateBuffer(this._secondaryUVBufferIndex, renderable.getVertexData(SubGeometry.SECONDARY_UV_DATA), renderable.getVertexOffset(SubGeometry.SECONDARY_UV_DATA), SubGeometry.SECONDARY_UV_FORMAT);

                if (this._normalBufferIndex >= 0)
                    stageGL.activateBuffer(this._normalBufferIndex, renderable.getVertexData(SubGeometry.NORMAL_DATA), renderable.getVertexOffset(SubGeometry.NORMAL_DATA), SubGeometry.NORMAL_FORMAT);

                if (this._tangentBufferIndex >= 0)
                    stageGL.activateBuffer(this._tangentBufferIndex, renderable.getVertexData(SubGeometry.TANGENT_DATA), renderable.getVertexOffset(SubGeometry.TANGENT_DATA), SubGeometry.TANGENT_FORMAT);

                if (this._animateUVs) {
                    var uvTransform = renderable.materialOwner.uvTransform.matrix;

                    if (uvTransform) {
                        this._pVertexConstantData[this._uvTransformIndex] = uvTransform.a;
                        this._pVertexConstantData[this._uvTransformIndex + 1] = uvTransform.b;
                        this._pVertexConstantData[this._uvTransformIndex + 3] = uvTransform.tx;
                        this._pVertexConstantData[this._uvTransformIndex + 4] = uvTransform.c;
                        this._pVertexConstantData[this._uvTransformIndex + 5] = uvTransform.d;
                        this._pVertexConstantData[this._uvTransformIndex + 7] = uvTransform.ty;
                    } else {
                        this._pVertexConstantData[this._uvTransformIndex] = 1;
                        this._pVertexConstantData[this._uvTransformIndex + 1] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 3] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 4] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 5] = 1;
                        this._pVertexConstantData[this._uvTransformIndex + 7] = 0;
                    }
                }

                this._pAmbientLightR = this._pAmbientLightG = this._pAmbientLightB = 0;

                if (this.pUsesLights())
                    this.pUpdateLightConstants();

                if (this.pUsesProbes())
                    this.pUpdateProbes(stageGL);

                if (this._sceneMatrixIndex >= 0) {
                    renderable.sourceEntity.getRenderSceneTransform(camera).copyRawDataTo(this._pVertexConstantData, this._sceneMatrixIndex, true);
                    viewProjection.copyRawDataTo(this._pVertexConstantData, 0, true);
                    //this._pVertexConstantData = renderable.getRenderSceneTransform(camera).copyRawDataTo( this._sceneMatrixIndex, true);
                    //this._pVertexConstantData = viewProjection.copyRawDataTo( 0, true);
                } else {
                    var matrix3D = Matrix3DUtils.CALCULATION_MATRIX;

                    matrix3D.copyFrom(renderable.sourceEntity.getRenderSceneTransform(camera));
                    matrix3D.append(viewProjection);

                    matrix3D.copyRawDataTo(this._pVertexConstantData, 0, true);
                    //this._pVertexConstantData = matrix3D.copyRawDataTo( 0, true);
                }

                if (this._sceneNormalMatrixIndex >= 0) {
                    renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._pVertexConstantData, this._sceneNormalMatrixIndex, false);
                    //this._pVertexConstantData = renderable.inverseSceneTransform.copyRawDataTo(this._sceneNormalMatrixIndex, false);
                }

                if (this._usesNormals)
                    this._pMethodSetup._iNormalMethod.iSetRenderState(this._pMethodSetup._iNormalMethodVO, renderable, stageGL, camera);

                var ambientMethod = this._pMethodSetup._iAmbientMethod;
                ambientMethod._iLightAmbientR = this._pAmbientLightR;
                ambientMethod._iLightAmbientG = this._pAmbientLightG;
                ambientMethod._iLightAmbientB = this._pAmbientLightB;
                ambientMethod.iSetRenderState(this._pMethodSetup._iAmbientMethodVO, renderable, stageGL, camera);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iSetRenderState(this._pMethodSetup._iShadowMethodVO, renderable, stageGL, camera);

                this._pMethodSetup._iDiffuseMethod.iSetRenderState(this._pMethodSetup._iDiffuseMethodVO, renderable, stageGL, camera);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iSetRenderState(this._pMethodSetup._iSpecularMethodVO, renderable, stageGL, camera);

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iSetRenderState(this._pMethodSetup._iColorTransformMethodVO, renderable, stageGL, camera);

                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (i = 0; i < len; ++i) {
                    var aset = methods[i];

                    aset.method.iSetRenderState(aset.data, renderable, stageGL, camera);
                }

                context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 0, this._pVertexConstantData, this._pNumUsedVertexConstants);
                context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.FRAGMENT, 0, this._pFragmentConstantData, this._pNumUsedFragmentConstants);

                stageGL.activateBuffer(0, renderable.getVertexData(SubGeometry.POSITION_DATA), renderable.getVertexOffset(SubGeometry.POSITION_DATA), SubGeometry.POSITION_FORMAT);
                context.drawTriangles(stageGL.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);
            };

            /**
            * Indicates whether the shader uses any light probes.
            */
            CompiledPass.prototype.pUsesProbes = function () {
                return this._pNumLightProbes > 0 && ((this._pDiffuseLightSources | this._pSpecularLightSources) & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether the shader uses any lights.
            */
            CompiledPass.prototype.pUsesLights = function () {
                return (this._pNumPointLights > 0 || this._pNumDirectionalLights > 0) && ((this._pDiffuseLightSources | this._pSpecularLightSources) & materials.LightSources.LIGHTS) != 0;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iDeactivate = function (stageGL) {
                _super.prototype.iDeactivate.call(this, stageGL);

                if (this._usesNormals)
                    this._pMethodSetup._iNormalMethod.iDeactivate(this._pMethodSetup._iNormalMethodVO, stageGL);

                this._pMethodSetup._iAmbientMethod.iDeactivate(this._pMethodSetup._iAmbientMethodVO, stageGL);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iDeactivate(this._pMethodSetup._iShadowMethodVO, stageGL);

                this._pMethodSetup._iDiffuseMethod.iDeactivate(this._pMethodSetup._iDiffuseMethodVO, stageGL);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iDeactivate(this._pMethodSetup._iSpecularMethodVO, stageGL);
            };

            Object.defineProperty(CompiledPass.prototype, "specularLightSources", {
                /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                get: function () {
                    return this._pSpecularLightSources;
                },
                set: function (value) {
                    this._pSpecularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "diffuseLightSources", {
                /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                get: function () {
                    return this._pDiffuseLightSources;
                },
                set: function (value) {
                    this._pDiffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });

            return CompiledPass;
        })(materials.MaterialPassBase);
        materials.CompiledPass = CompiledPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * SuperShaderPass is a shader pass that uses shader methods to compile a complete program. It includes all methods
        * associated with a material.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var SuperShaderPass = (function (_super) {
            __extends(SuperShaderPass, _super);
            /**
            * Creates a new SuperShaderPass objects.
            *
            * @param material The material to which this material belongs.
            */
            function SuperShaderPass(material) {
                _super.call(this, material);
                this._includeCasters = true;
                this._pNeedFragmentAnimation = true;
            }
            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pCreateCompiler = function (profile) {
                return new materials.SuperShaderCompiler(profile);
            };

            Object.defineProperty(SuperShaderPass.prototype, "includeCasters", {
                /**
                * Indicates whether lights that cast shadows should be included in the pass.
                */
                get: function () {
                    return this._includeCasters;
                },
                set: function (value) {
                    if (this._includeCasters == value)
                        return;
                    this._includeCasters = value;
                    this.iInvalidateShaderProgram(); //invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SuperShaderPass.prototype, "colorTransform", {
                /**
                * The ColorTransform object to transform the colour of the material with. Defaults to null.
                */
                get: function () {
                    return this._pMethodSetup._iColorTransformMethod ? this._pMethodSetup._iColorTransformMethod.colorTransform : null;
                },
                set: function (value) {
                    if (value) {
                        //colorTransformMethod ||= new away.geom.ColorTransform();
                        if (this.colorTransformMethod == null) {
                            this.colorTransformMethod = new materials.EffectColorTransformMethod();
                        }

                        this._pMethodSetup._iColorTransformMethod.colorTransform = value;
                    } else if (!value) {
                        if (this._pMethodSetup._iColorTransformMethod) {
                            this.colorTransformMethod = null;
                        }

                        this.colorTransformMethod = this._pMethodSetup._iColorTransformMethod = null;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SuperShaderPass.prototype, "colorTransformMethod", {
                /**
                * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.
                */
                get: function () {
                    return this._pMethodSetup._iColorTransformMethod;
                },
                set: function (value) {
                    this._pMethodSetup.iColorTransformMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            SuperShaderPass.prototype.addMethod = function (method) {
                this._pMethodSetup.addMethod(method);
            };

            Object.defineProperty(SuperShaderPass.prototype, "numMethods", {
                /**
                * The number of "effect" methods added to the material.
                */
                get: function () {
                    return this._pMethodSetup.numMethods;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            SuperShaderPass.prototype.hasMethod = function (method) {
                return this._pMethodSetup.hasMethod(method);
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            SuperShaderPass.prototype.getMethodAt = function (index) {
                return this._pMethodSetup.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            SuperShaderPass.prototype.addMethodAt = function (method, index) {
                this._pMethodSetup.addMethodAt(method, index);
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            SuperShaderPass.prototype.removeMethod = function (method) {
                this._pMethodSetup.removeMethod(method);
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateLights = function () {
                if (this._pLightPicker && !this._ignoreLights) {
                    this._pNumPointLights = this._pLightPicker.numPointLights;
                    this._pNumDirectionalLights = this._pLightPicker.numDirectionalLights;
                    this._pNumLightProbes = this._pLightPicker.numLightProbes;

                    if (this._includeCasters) {
                        this._pNumPointLights += this._pLightPicker.numCastingPointLights;
                        this._pNumDirectionalLights += this._pLightPicker.numCastingDirectionalLights;
                    }
                } else {
                    this._pNumPointLights = 0;
                    this._pNumDirectionalLights = 0;
                    this._pNumLightProbes = 0;
                }

                this.iInvalidateShaderProgram(); //invalidateShaderProgram();
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iActivate(this._pMethodSetup._iColorTransformMethodVO, stageGL);

                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    var aset = methods[i];
                    aset.method.iActivate(aset.data, stageGL);
                }

                if (this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;

                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.iDeactivate = function (stageGL) {
                _super.prototype.iDeactivate.call(this, stageGL);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pMethodSetup._iColorTransformMethod.iDeactivate(this._pMethodSetup._iColorTransformMethodVO, stageGL);
                }

                var aset;
                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    aset = methods[i];
                    aset.method.iDeactivate(aset.data, stageGL);
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pAddPassesFromMethods = function () {
                _super.prototype.pAddPassesFromMethods.call(this);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this.pAddPasses(this._pMethodSetup._iColorTransformMethod.passes);
                }
                var methods = this._pMethodSetup._iMethods;

                for (var i = 0; i < methods.length; ++i) {
                    this.pAddPasses(methods[i].method.passes);
                }
            };

            /**
            * Indicates whether any light probes are used to contribute to the specular shading.
            */
            SuperShaderPass.prototype.usesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._pSpecularLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used to contribute to the diffuse shading.
            */
            SuperShaderPass.prototype.usesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._pDiffuseLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateMethodConstants = function () {
                _super.prototype.pUpdateMethodConstants.call(this);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pMethodSetup._iColorTransformMethod.iInitConstants(this._pMethodSetup._iColorTransformMethodVO);
                }

                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iInitConstants(methods[i].data);
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateLightConstants = function () {
                // first dirs, then points
                var dirLight;

                var pointLight;

                var i, k;

                var len;

                var dirPos;

                var total = 0;

                var numLightTypes = this._includeCasters ? 2 : 1;

                k = this._pLightFragmentConstantIndex;

                for (var cast = 0; cast < numLightTypes; ++cast) {
                    var dirLights = cast ? this._pLightPicker.castingDirectionalLights : this._pLightPicker.directionalLights;
                    len = dirLights.length;
                    total += len;

                    for (i = 0; i < len; ++i) {
                        dirLight = dirLights[i];
                        dirPos = dirLight.sceneDirection;

                        this._pAmbientLightR += dirLight._iAmbientR;
                        this._pAmbientLightG += dirLight._iAmbientG;
                        this._pAmbientLightB += dirLight._iAmbientB;

                        this._pFragmentConstantData[k++] = -dirPos.x;
                        this._pFragmentConstantData[k++] = -dirPos.y;
                        this._pFragmentConstantData[k++] = -dirPos.z;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                        this._pFragmentConstantData[k++] = 1;
                    }
                }

                // more directional supported than currently picked, need to clamp all to 0
                if (this._pNumDirectionalLights > total) {
                    i = k + (this._pNumDirectionalLights - total) * 12;

                    while (k < i) {
                        this._pFragmentConstantData[k++] = 0;
                    }
                }

                total = 0;
                for (cast = 0; cast < numLightTypes; ++cast) {
                    var pointLights = cast ? this._pLightPicker.castingPointLights : this._pLightPicker.pointLights;

                    len = pointLights.length;

                    for (i = 0; i < len; ++i) {
                        pointLight = pointLights[i];
                        dirPos = pointLight.scenePosition;

                        this._pAmbientLightR += pointLight._iAmbientR;
                        this._pAmbientLightG += pointLight._iAmbientG;
                        this._pAmbientLightB += pointLight._iAmbientB;

                        this._pFragmentConstantData[k++] = dirPos.x;
                        this._pFragmentConstantData[k++] = dirPos.y;
                        this._pFragmentConstantData[k++] = dirPos.z;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = pointLight._pRadius * pointLight._pRadius;

                        this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                        this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;
                    }
                }

                // more directional supported than currently picked, need to clamp all to 0
                if (this._pNumPointLights > total) {
                    i = k + (total - this._pNumPointLights) * 12;

                    for (; k < i; ++k) {
                        this._pFragmentConstantData[k] = 0;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateProbes = function (stageGL) {
                var probe;
                var lightProbes = this._pLightPicker.lightProbes;
                var weights = this._pLightPicker.lightProbeWeights;
                var len = lightProbes.length;
                var addDiff = this.usesProbesForDiffuse();
                var addSpec = (this._pMethodSetup._iSpecularMethod && this.usesProbesForSpecular());
                var context = stageGL.contextGL;

                if (!(addDiff || addSpec)) {
                    return;
                }

                for (var i = 0; i < len; ++i) {
                    probe = lightProbes[i];

                    //away.Debug.throwPIR( 'SuperShaderPass' , 'pUpdateProbes' , 'context.setGLSLTextureAt - Parameters not matching');
                    if (addDiff) {
                        probe.diffuseMap.activateTextureForStage(this._pLightProbeSpecularIndices[i], stageGL); //<------ TODO: implement
                    }

                    if (addSpec) {
                        probe.specularMap.activateTextureForStage(this._pLightProbeSpecularIndices[i], stageGL); //<------ TODO: implement
                    }
                }

                this._pFragmentConstantData[this._pProbeWeightsIndex] = weights[0];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 1] = weights[1];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 2] = weights[2];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 3] = weights[3];
            };


            Object.defineProperty(SuperShaderPass.prototype, "iIgnoreLights", {
                get: function () {
                    return this._ignoreLights;
                },
                /**
                * Indicates whether lights should be ignored in this pass. This is used when only effect methods are rendered in
                * a multipass material.
                */
                set: function (ignoreLights) {
                    this._ignoreLights = ignoreLights;
                },
                enumerable: true,
                configurable: true
            });
            return SuperShaderPass;
        })(materials.CompiledPass);
        materials.SuperShaderPass = SuperShaderPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var SubGeometry = away.base.TriangleSubGeometry;

        /**
        * DepthMapPass is a pass that writes depth values to a depth map as a 32-bit value exploded over the 4 texture channels.
        * This is used to render shadow maps, depth maps, etc.
        */
        var DepthMapPass = (function (_super) {
            __extends(DepthMapPass, _super);
            /**
            * Creates a new DepthMapPass object.
            */
            function DepthMapPass() {
                _super.call(this);
                this._alphaThreshold = 0;

                this._data = new Array(1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0, 0.0, 0.0, 0.0, 0.0);
            }
            Object.defineProperty(DepthMapPass.prototype, "alphaThreshold", {
                /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                get: function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
                    else if (value > 1)
                        value = 1;

                    if (value == this._alphaThreshold)
                        return;

                    if (value == 0 || this._alphaThreshold == 0)
                        this.iInvalidateShaderProgram();

                    this._alphaThreshold = value;
                    this._data[8] = this._alphaThreshold;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DepthMapPass.prototype, "alphaMask", {
                /**
                * A texture providing alpha data to be able to prevent semi-transparent pixels to write to the alpha mask.
                * Usually the diffuse texture when alphaThreshold is used.
                */
                get: function () {
                    return this._alphaMask;
                },
                set: function (value) {
                    this._alphaMask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iGetVertexCode = function () {
                var code = "";

                // project
                //TODO: AGAL <> GLSL conversion
                code = "m44 vt1, vt0, vc0		\n" + "mov op, vt1	\n";

                if (this._alphaThreshold > 0) {
                    this._pNumUsedTextures = 1;
                    this._pNumUsedStreams = 2;
                    code += "mov v0, vt1\n" + "mov v1, va1\n";
                } else {
                    this._pNumUsedTextures = 0;
                    this._pNumUsedStreams = 1;
                    code += "mov v0, vt1\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iGetFragmentCode = function (code) {
                var wrap = this._pRepeat ? "wrap" : "clamp";
                var filter;

                if (this._pSmooth)
                    filter = this._pMipmap ? "linear,miplinear" : "linear";
                else
                    filter = this._pMipmap ? "nearest,mipnearest" : "nearest";

                // TODO: AGAL<>GLSL
                var codeF = "div ft2, v0, v0.w		\n" + "mul ft0, fc0, ft2.z	\n" + "frc ft0, ft0			\n" + "mul ft1, ft0.yzww, fc1	\n";

                //codeF += "mov ft1.w, fc1.w	\n" +
                //    "mov ft0.w, fc0.x	\n";
                if (this._alphaThreshold > 0) {
                    var format;

                    switch (this._alphaMask.format) {
                        case away.stagegl.ContextGLTextureFormat.COMPRESSED:
                            format = "dxt1,";
                            break;

                        case "compressedAlpha":
                            format = "dxt5,";
                            break;

                        default:
                            format = "";
                    }

                    codeF += "tex ft3, v1, fs0 <2d," + filter + "," + format + wrap + ">\n" + "sub ft3.w, ft3.w, fc2.x\n" + "kil ft3.w\n";
                }

                codeF += "sub oc, ft0, ft1		\n";

                return codeF;
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                if (this._alphaThreshold > 0)
                    stageGL.activateBuffer(1, renderable.getVertexData(SubGeometry.UV_DATA), renderable.getVertexOffset(SubGeometry.UV_DATA), SubGeometry.UV_FORMAT);

                var context = stageGL.contextGL;
                var matrix = away.geom.Matrix3DUtils.CALCULATION_MATRIX;

                matrix.copyFrom(renderable.sourceEntity.getRenderSceneTransform(camera));
                matrix.append(viewProjection);
                context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 0, matrix, true);

                stageGL.activateBuffer(0, renderable.getVertexData(SubGeometry.POSITION_DATA), renderable.getVertexOffset(SubGeometry.POSITION_DATA), SubGeometry.POSITION_FORMAT);
                context.drawTriangles(stageGL.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iActivate = function (stageGL, camera) {
                var context = stageGL.contextGL;

                _super.prototype.iActivate.call(this, stageGL, camera);

                if (this._alphaThreshold > 0) {
                    this._alphaMask.activateTextureForStage(0, stageGL);
                    context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.FRAGMENT, 0, this._data, 3);
                } else {
                    context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.FRAGMENT, 0, this._data, 2);
                }
            };
            return DepthMapPass;
        })(materials.MaterialPassBase);
        materials.DepthMapPass = DepthMapPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var SubGeometry = away.base.TriangleSubGeometry;

        /**
        * DistanceMapPass is a pass that writes distance values to a depth map as a 32-bit value exploded over the 4 texture channels.
        * This is used to render omnidirectional shadow maps.
        */
        var DistanceMapPass = (function (_super) {
            __extends(DistanceMapPass, _super);
            /**
            * Creates a new DistanceMapPass object.
            */
            function DistanceMapPass() {
                _super.call(this);

                this._fragmentData = new Array(1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0, 0.0, 0.0, 0.0, 0.0);
                this._vertexData = new Array(4);
                this._vertexData[3] = 1;
                this._pNumUsedVertexConstants = 9;
            }
            Object.defineProperty(DistanceMapPass.prototype, "alphaThreshold", {
                /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                get: function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
                    else if (value > 1)
                        value = 1;

                    if (value == this._alphaThreshold)
                        return;

                    if (value == 0 || this._alphaThreshold == 0)
                        this.iInvalidateShaderProgram();

                    this._alphaThreshold = value;
                    this._fragmentData[8] = this._alphaThreshold;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DistanceMapPass.prototype, "alphaMask", {
                /**
                * A texture providing alpha data to be able to prevent semi-transparent pixels to write to the alpha mask.
                * Usually the diffuse texture when alphaThreshold is used.
                */
                get: function () {
                    return this._alphaMask;
                },
                set: function (value) {
                    this._alphaMask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iGetVertexCode = function () {
                //TODO: AGAL<> GLSL
                var code;
                code = "m44 op, vt0, vc0		\n" + "m44 vt1, vt0, vc5		\n" + "sub v0, vt1, vc9		\n";

                if (this._alphaThreshold > 0) {
                    code += "mov v1, va1\n";

                    this._pNumUsedTextures = 1;
                    this._pNumUsedStreams = 2;
                } else {
                    this._pNumUsedTextures = 0;
                    this._pNumUsedStreams = 1;
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iGetFragmentCode = function (animationCode) {
                var code;
                var wrap = this._pRepeat ? "wrap" : "clamp";
                var filter;

                if (this._pSmooth)
                    filter = this._pMipmap ? "linear,miplinear" : "linear";
                else
                    filter = this._pMipmap ? "nearest,mipnearest" : "nearest";

                //TODO: AGAL<> GLSL
                // squared distance to view
                code = "dp3 ft2.z, v0.xyz, v0.xyz	\n" + "mul ft0, fc0, ft2.z	\n" + "frc ft0, ft0			\n" + "mul ft1, ft0.yzww, fc1	\n";

                if (this._alphaThreshold > 0) {
                    var format;

                    switch (this._alphaMask.format) {
                        case away.stagegl.ContextGLTextureFormat.COMPRESSED:
                            format = "dxt1,";
                            break;

                        case "compressedAlpha":
                            format = "dxt5,";
                            break;

                        default:
                            format = "";
                    }

                    code += "tex ft3, v1, fs0 <2d," + filter + "," + format + wrap + ">\n" + "sub ft3.w, ft3.w, fc2.x\n" + "kil ft3.w\n";
                }

                code += "sub oc, ft0, ft1		\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var context = stageGL.contextGL;
                var pos = camera.scenePosition;

                this._vertexData[0] = pos.x;
                this._vertexData[1] = pos.y;
                this._vertexData[2] = pos.z;
                this._vertexData[3] = 1;

                var sceneTransform = renderable.sourceEntity.getRenderSceneTransform(camera);

                context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 5, sceneTransform, true);

                context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 9, this._vertexData, 1);

                if (this._alphaThreshold > 0)
                    stageGL.activateBuffer(1, renderable.getVertexData(SubGeometry.SECONDARY_UV_DATA), renderable.getVertexOffset(SubGeometry.SECONDARY_UV_DATA), SubGeometry.SECONDARY_UV_FORMAT);

                var matrix = away.geom.Matrix3DUtils.CALCULATION_MATRIX;

                matrix.copyFrom(sceneTransform);
                matrix.append(viewProjection);

                context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 0, matrix, true);

                stageGL.activateBuffer(0, renderable.getVertexData(SubGeometry.POSITION_DATA), renderable.getVertexOffset(SubGeometry.POSITION_DATA), SubGeometry.POSITION_FORMAT);
                context.drawTriangles(stageGL.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iActivate = function (stageGL, camera) {
                var context = stageGL.contextGL;
                _super.prototype.iActivate.call(this, stageGL, camera);

                var f = camera.projection.far;

                f = 1 / (2 * f * f);

                // sqrt(f*f+f*f) is largest possible distance for any frustum, so we need to divide by it. Rarely a tight fit, but with 32 bits precision, it's enough.
                this._fragmentData[0] = 1 * f;
                this._fragmentData[1] = 255.0 * f;
                this._fragmentData[2] = 65025.0 * f;
                this._fragmentData[3] = 16581375.0 * f;

                if (this._alphaThreshold > 0) {
                    this._alphaMask.activateTextureForStage(0, stageGL);
                    context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.FRAGMENT, 0, this._fragmentData, 3);
                } else {
                    context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.FRAGMENT, 0, this._fragmentData, 2);
                }
            };
            return DistanceMapPass;
        })(materials.MaterialPassBase);
        materials.DistanceMapPass = DistanceMapPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away3d.arcane;
        //import away3d.cameras.Camera;
        //import away3d.core.base.IRenderable;
        //import away3d.base.StageGL;
        //import away3d.lights.DirectionalLight;
        //import away3d.lights.LightProbe;
        //import away3d.lights.PointLight;
        //import away3d.materials.LightSources;
        //import away3d.materials.MaterialBase;
        //import away3d.materials.compilation.LightingShaderCompiler;
        //import away3d.materials.compilation.ShaderCompiler;
        //import flash.displayGL.ContextGL;
        //import flash.geom.Matrix3D;
        //import flash.geom.Vector3D;
        //use namespace arcane;
        /**
        * LightingPass is a shader pass that uses shader methods to compile a complete program. It only includes the lighting
        * methods. It's used by multipass materials to accumulate lighting passes.
        *
        * @see away3d.materials.MultiPassMaterialBase
        */
        var LightingPass = (function (_super) {
            __extends(LightingPass, _super);
            /**
            * Creates a new LightingPass objects.
            *
            * @param material The material to which this pass belongs.
            */
            function LightingPass(material) {
                _super.call(this, material);
                this._includeCasters = true;
                this._inverseSceneMatrix = new Array();
                this._maxLights = 3;
            }
            Object.defineProperty(LightingPass.prototype, "directionalLightsOffset", {
                /**
                * Indicates the offset in the light picker's directional light vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                get: function () {
                    return this._directionalLightsOffset;
                },
                set: function (value) {
                    this._directionalLightsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightingPass.prototype, "pointLightsOffset", {
                /**
                * Indicates the offset in the light picker's point light vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                get: function () {
                    return this._pointLightsOffset;
                },
                set: function (value) {
                    this._pointLightsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightingPass.prototype, "lightProbesOffset", {
                /**
                * Indicates the offset in the light picker's light probes vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                get: function () {
                    return this._lightProbesOffset;
                },
                set: function (value) {
                    this._lightProbesOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            LightingPass.prototype.pCreateCompiler = function (profile) {
                this._maxLights = profile == "baselineConstrained" ? 1 : 3;
                return new materials.LightingShaderCompiler(profile);
            };

            Object.defineProperty(LightingPass.prototype, "includeCasters", {
                /**
                * Indicates whether or not shadow casting lights need to be included.
                */
                get: function () {
                    return this._includeCasters;
                },
                set: function (value) {
                    if (this._includeCasters == value)
                        return;
                    this._includeCasters = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateLights = function () {
                _super.prototype.pUpdateLights.call(this);
                var numDirectionalLightsOld = this._pNumDirectionalLights;
                var numPointLightsOld = this._pNumPointLights;
                var numLightProbesOld = this._pNumLightProbes;

                if (this._pLightPicker) {
                    this._pNumDirectionalLights = this.calculateNumDirectionalLights(this._pLightPicker.numDirectionalLights);
                    this._pNumPointLights = this.calculateNumPointLights(this._pLightPicker.numPointLights);
                    this._pNumLightProbes = this.calculateNumProbes(this._pLightPicker.numLightProbes);

                    if (this._includeCasters) {
                        this._pNumDirectionalLights += this._pLightPicker.numCastingDirectionalLights;
                        this._pNumPointLights += this._pLightPicker.numCastingPointLights;
                    }
                } else {
                    this._pNumDirectionalLights = 0;
                    this._pNumPointLights = 0;
                    this._pNumLightProbes = 0;
                }

                if (numDirectionalLightsOld != this._pNumDirectionalLights || numPointLightsOld != this._pNumPointLights || numLightProbesOld != this._pNumLightProbes)
                    this.iInvalidateShaderProgram();
            };

            /**
            * Calculates the amount of directional lights this material will support.
            * @param numDirectionalLights The maximum amount of directional lights to support.
            * @return The amount of directional lights this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {
                return Math.min(numDirectionalLights - this._directionalLightsOffset, this._maxLights);
            };

            /**
            * Calculates the amount of point lights this material will support.
            * @param numDirectionalLights The maximum amount of point lights to support.
            * @return The amount of point lights this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumPointLights = function (numPointLights) {
                var numFree = this._maxLights - this._pNumDirectionalLights;
                return Math.min(numPointLights - this._pointLightsOffset, numFree);
            };

            /**
            * Calculates the amount of light probes this material will support.
            * @param numDirectionalLights The maximum amount of light probes to support.
            * @return The amount of light probes this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumProbes = function (numLightProbes) {
                var numChannels = 0;
                if ((this._pSpecularLightSources & materials.LightSources.PROBES) != 0) {
                    ++numChannels;
                }
                if ((this._pDiffuseLightSources & materials.LightSources.PROBES) != 0)
                    ++numChannels;

                // 4 channels available
                return Math.min(numLightProbes - this._lightProbesOffset, (4 / numChannels) | 0);
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateShaderProperties = function () {
                _super.prototype.pUpdateShaderProperties.call(this);

                var compilerV = this._pCompiler;
                this._tangentSpace = compilerV.tangentSpace;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateRegisterIndices = function () {
                _super.prototype.pUpdateRegisterIndices.call(this);

                var compilerV = this._pCompiler;
                this._lightVertexConstantIndex = compilerV.lightVertexConstantIndex;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._inverseSceneMatrix);

                if (this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    var x = pos.x;
                    var y = pos.y;
                    var z = pos.z;

                    this._pVertexConstantData[this._pCameraPositionIndex] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                }

                _super.prototype.iRender.call(this, renderable, stageGL, camera, viewProjection);
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (!this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;

                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * Indicates whether any light probes are used to contribute to the specular shading.
            */
            LightingPass.prototype.usesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._pSpecularLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used to contribute to the diffuse shading.
            */
            LightingPass.prototype.usesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._pDiffuseLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateLightConstants = function () {
                var dirLight;
                var pointLight;
                var i = 0;
                var k = 0;
                var len;
                var dirPos;
                var total = 0;
                var numLightTypes = this._includeCasters ? 2 : 1;
                var l;
                var offset;

                l = this._lightVertexConstantIndex;
                k = this._pLightFragmentConstantIndex;

                var cast = 0;
                var dirLights = this._pLightPicker.directionalLights;
                offset = this._directionalLightsOffset;
                len = this._pLightPicker.directionalLights.length;

                if (offset > len) {
                    cast = 1;
                    offset -= len;
                }

                for (; cast < numLightTypes; ++cast) {
                    if (cast)
                        dirLights = this._pLightPicker.castingDirectionalLights;
                    len = dirLights.length;
                    if (len > this._pNumDirectionalLights)
                        len = this._pNumDirectionalLights;

                    for (i = 0; i < len; ++i) {
                        dirLight = dirLights[offset + i];
                        dirPos = dirLight.sceneDirection;

                        this._pAmbientLightR += dirLight._iAmbientR;
                        this._pAmbientLightG += dirLight._iAmbientG;
                        this._pAmbientLightB += dirLight._iAmbientB;

                        if (this._tangentSpace) {
                            var x = -dirPos.x;
                            var y = -dirPos.y;
                            var z = -dirPos.z;

                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z;
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z;
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z;
                            this._pVertexConstantData[l++] = 1;
                        } else {
                            this._pFragmentConstantData[k++] = -dirPos.x;
                            this._pFragmentConstantData[k++] = -dirPos.y;
                            this._pFragmentConstantData[k++] = -dirPos.z;
                            this._pFragmentConstantData[k++] = 1;
                        }

                        this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                        this._pFragmentConstantData[k++] = 1;

                        if (++total == this._pNumDirectionalLights) {
                            // break loop
                            i = len;
                            cast = numLightTypes;
                        }
                    }
                }

                // more directional supported than currently picked, need to clamp all to 0
                if (this._pNumDirectionalLights > total) {
                    i = k + (this._pNumDirectionalLights - total) * 12;

                    while (k < i) {
                        this._pFragmentConstantData[k++] = 0;
                    }
                }

                total = 0;

                var pointLights = this._pLightPicker.pointLights;
                offset = this._pointLightsOffset;
                len = this._pLightPicker.pointLights.length;

                if (offset > len) {
                    cast = 1;
                    offset -= len;
                } else {
                    cast = 0;
                }

                for (; cast < numLightTypes; ++cast) {
                    if (cast) {
                        pointLights = this._pLightPicker.castingPointLights;
                    }

                    len = pointLights.length;

                    for (i = 0; i < len; ++i) {
                        pointLight = pointLights[offset + i];
                        dirPos = pointLight.scenePosition;

                        this._pAmbientLightR += pointLight._iAmbientR;
                        this._pAmbientLightG += pointLight._iAmbientG;
                        this._pAmbientLightB += pointLight._iAmbientB;

                        if (this._tangentSpace) {
                            x = dirPos.x;
                            y = dirPos.y;
                            z = dirPos.z;

                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                        } else {
                            this._pVertexConstantData[l++] = dirPos.x;
                            this._pVertexConstantData[l++] = dirPos.y;
                            this._pVertexConstantData[l++] = dirPos.z;
                        }
                        this._pVertexConstantData[l++] = 1;

                        this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseB;

                        var radius = pointLight._pRadius;
                        this._pFragmentConstantData[k++] = radius * radius;

                        this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                        this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;

                        if (++total == this._pNumPointLights) {
                            // break loop
                            i = len;
                            cast = numLightTypes;
                        }
                    }
                }

                // more directional supported than currently picked, need to clamp all to 0
                if (this._pNumPointLights > total) {
                    i = k + (total - this._pNumPointLights) * 12;
                    for (; k < i; ++k) {
                        this._pFragmentConstantData[k] = 0;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateProbes = function (stageGL) {
                var probe;
                var lightProbes = this._pLightPicker.lightProbes;
                var weights = this._pLightPicker.lightProbeWeights;
                var len = lightProbes.length - this._lightProbesOffset;
                var addDiff = this.usesProbesForDiffuse();
                var addSpec = (this._pMethodSetup._iSpecularMethod && this.usesProbesForSpecular());

                if (!(addDiff || addSpec))
                    return;

                if (len > this._pNumLightProbes) {
                    len = this._pNumLightProbes;
                }

                for (var i = 0; i < len; ++i) {
                    probe = lightProbes[this._lightProbesOffset + i];

                    if (addDiff)
                        probe.diffuseMap.activateTextureForStage(this._pLightProbeDiffuseIndices[i], stageGL);

                    if (addSpec)
                        probe.specularMap.activateTextureForStage(this._pLightProbeSpecularIndices[i], stageGL);
                }

                for (i = 0; i < len; ++i)
                    this._pFragmentConstantData[this._pProbeWeightsIndex + i] = weights[this._lightProbesOffset + i];
            };
            return LightingPass;
        })(materials.CompiledPass);
        materials.LightingPass = LightingPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShadowCasterPass is a shader pass that uses shader methods to compile a complete program. It only draws the lighting
        * contribution for a single shadow-casting light.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var ShadowCasterPass = (function (_super) {
            __extends(ShadowCasterPass, _super);
            /**
            * Creates a new ShadowCasterPass objects.
            *
            * @param material The material to which this pass belongs.
            */
            function ShadowCasterPass(material) {
                _super.call(this, material);
                this._inverseSceneMatrix = new Array();
            }
            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pCreateCompiler = function (profile) {
                return new materials.LightingShaderCompiler(profile);
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateLights = function () {
                _super.prototype.pUpdateLights.call(this);

                var numPointLights = 0;
                var numDirectionalLights = 0;

                if (this._pLightPicker) {
                    numPointLights = this._pLightPicker.numCastingPointLights > 0 ? 1 : 0;
                    numDirectionalLights = this._pLightPicker.numCastingDirectionalLights > 0 ? 1 : 0;
                } else {
                    numPointLights = 0;
                    numDirectionalLights = 0;
                }

                this._pNumLightProbes = 0;

                if (numPointLights + numDirectionalLights > 1) {
                    throw new Error("Must have exactly one light!");
                }

                if (numPointLights != this._pNumPointLights || numDirectionalLights != this._pNumDirectionalLights) {
                    this._pNumPointLights = numPointLights;
                    this._pNumDirectionalLights = numDirectionalLights;
                    this.iInvalidateShaderProgram();
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateShaderProperties = function () {
                _super.prototype.pUpdateShaderProperties.call(this);

                var c = this._pCompiler;
                this._tangentSpace = c.tangentSpace;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateRegisterIndices = function () {
                _super.prototype.pUpdateRegisterIndices.call(this);

                var c = this._pCompiler;

                this._lightVertexConstantIndex = c.lightVertexConstantIndex;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._inverseSceneMatrix);

                if (this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    var x = pos.x;
                    var y = pos.y;
                    var z = pos.z;
                    this._pVertexConstantData[this._pCameraPositionIndex] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                }

                _super.prototype.iRender.call(this, renderable, stageGL, camera, viewProjection);
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (!this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateLightConstants = function () {
                // first dirs, then points
                var dirLight;
                var pointLight;
                var k = 0;
                var l = 0;
                var dirPos;

                l = this._lightVertexConstantIndex;
                k = this._pLightFragmentConstantIndex;

                if (this._pNumDirectionalLights > 0) {
                    dirLight = this._pLightPicker.castingDirectionalLights[0];
                    dirPos = dirLight.sceneDirection;

                    this._pAmbientLightR += dirLight._iAmbientR;
                    this._pAmbientLightG += dirLight._iAmbientG;
                    this._pAmbientLightB += dirLight._iAmbientB;

                    if (this._tangentSpace) {
                        var x = -dirPos.x;
                        var y = -dirPos.y;
                        var z = -dirPos.z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z;
                        this._pVertexConstantData[l++] = 1;
                    } else {
                        this._pFragmentConstantData[k++] = -dirPos.x;
                        this._pFragmentConstantData[k++] = -dirPos.y;
                        this._pFragmentConstantData[k++] = -dirPos.z;
                        this._pFragmentConstantData[k++] = 1;
                    }

                    this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                    this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                    this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                    this._pFragmentConstantData[k++] = 1;

                    this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                    this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                    this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                    this._pFragmentConstantData[k++] = 1;

                    return;
                }

                if (this._pNumPointLights > 0) {
                    pointLight = this._pLightPicker.castingPointLights[0];

                    dirPos = pointLight.scenePosition;

                    this._pAmbientLightR += pointLight._iAmbientR;
                    this._pAmbientLightG += pointLight._iAmbientG;
                    this._pAmbientLightB += pointLight._iAmbientB;

                    if (this._tangentSpace) {
                        x = dirPos.x;
                        y = dirPos.y;
                        z = dirPos.z;

                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                    } else {
                        this._pVertexConstantData[l++] = dirPos.x;
                        this._pVertexConstantData[l++] = dirPos.y;
                        this._pVertexConstantData[l++] = dirPos.z;
                    }
                    this._pVertexConstantData[l++] = 1;

                    this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                    this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                    this._pFragmentConstantData[k++] = pointLight._iDiffuseB;
                    this._pFragmentConstantData[k++] = pointLight._pRadius * pointLight._pRadius;

                    this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                    this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                    this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                    this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUsesProbes = function () {
                return false;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUsesLights = function () {
                return true;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateProbes = function (stageGL) {
            };
            return ShadowCasterPass;
        })(materials.CompiledPass);
        materials.ShadowCasterPass = ShadowCasterPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var SubGeometry = away.base.TriangleSubGeometry;

        /**
        * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point
        * of view from a light.
        */
        var SingleObjectDepthPass = (function (_super) {
            __extends(SingleObjectDepthPass, _super);
            /**
            * Creates a new SingleObjectDepthPass object.
            * @param textureSize The size of the depth map texture to render to.
            * @param polyOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.
            *
            * todo: provide custom vertex code to assembler
            */
            function SingleObjectDepthPass(textureSize, polyOffset) {
                if (typeof textureSize === "undefined") { textureSize = 512; }
                if (typeof polyOffset === "undefined") { polyOffset = 15; }
                _super.call(this, true);
                this._projectionTexturesInvalid = true;

                this._textureSize = textureSize;
                this._pNumUsedStreams = 2;
                this._pNumUsedVertexConstants = 7;
                this._polyOffset = Array(polyOffset, 0, 0, 0);
                this._enc = Array(1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);

                this._pAnimatableAttributes = Array("va0", "va1");
                this._pAnimationTargetRegisters = Array("vt0", "vt1");
            }
            /**
            * @inheritDoc
            */
            SingleObjectDepthPass.prototype.dispose = function () {
                if (this._textures) {
                    for (var key in this._textures) {
                        var texture = this._textures[key];
                        texture.dispose();
                    }
                    this._textures = null;
                }
            };

            /**
            * Updates the projection textures used to contain the depth renders.
            */
            SingleObjectDepthPass.prototype.updateProjectionTextures = function () {
                if (this._textures) {
                    for (var key in this._textures) {
                        var texture = this._textures[key];
                        texture.dispose();
                    }
                }

                this._textures = new Object();
                this._projections = new Object();
                this._projectionTexturesInvalid = false;
            };

            /**
            * @inheritDoc
            */
            SingleObjectDepthPass.prototype.iGetVertexCode = function () {
                var code;

                // offset
                code = "mul vt7, vt1, vc4.x	\n" + "add vt7, vt7, vt0		\n" + "mov vt7.w, vt0.w		\n";

                // project
                code += "m44 vt2, vt7, vc0		\n" + "mov op, vt2			\n";

                // perspective divide
                code += "div v0, vt2, vt2.w \n";

                return code;
            };

            /**
            * @inheritDoc
            */
            SingleObjectDepthPass.prototype.iGetFragmentCode = function (animationCode) {
                var code = "";

                // encode float -> rgba
                code += "mul ft0, fc0, v0.z     \n" + "frc ft0, ft0           \n" + "mul ft1, ft0.yzww, fc1 \n" + "sub ft0, ft0, ft1      \n" + "mov oc, ft0            \n";

                return code;
            };

            /**
            * Gets the depth maps rendered for this object from all lights.
            * @param renderable The renderable for which to retrieve the depth maps.
            * @param stage3DProxy The Stage3DProxy object currently used for rendering.
            * @return A list of depth map textures for all supported lights.
            */
            SingleObjectDepthPass.prototype._iGetDepthMap = function (renderable) {
                return this._textures[renderable.materialOwner.id];
            };

            /**
            * Retrieves the depth map projection maps for all lights.
            * @param renderable The renderable for which to retrieve the projection maps.
            * @return A list of projection maps for all supported lights.
            */
            SingleObjectDepthPass.prototype._iGetProjection = function (renderable) {
                return this._projections[renderable.materialOwner.id];
            };

            /**
            * @inheritDoc
            */
            SingleObjectDepthPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var matrix;
                var context = stageGL.contextGL;
                var len;
                var light;
                var lights = this._pLightPicker.allPickedLights;
                var rId = renderable.materialOwner.id;

                if (!this._textures[rId])
                    this._textures[rId] = new away.textures.RenderTexture(this._textureSize, this._textureSize);

                if (!this._projections[rId])
                    this._projections[rId] = new away.geom.Matrix3D();

                len = lights.length;

                // local position = enough
                light = lights[0];

                matrix = light.iGetObjectProjectionMatrix(renderable.sourceEntity, camera, this._projections[rId]);

                stageGL.setRenderTarget(this._textures[rId], true);
                context.clear(1.0, 1.0, 1.0);
                context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 0, matrix, true);
                context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.FRAGMENT, 0, this._enc, 2);

                stageGL.activateBuffer(0, renderable.getVertexData(SubGeometry.POSITION_DATA), renderable.getVertexOffset(SubGeometry.POSITION_DATA), SubGeometry.POSITION_FORMAT);
                stageGL.activateBuffer(1, renderable.getVertexData(SubGeometry.NORMAL_DATA), renderable.getVertexOffset(SubGeometry.NORMAL_DATA), SubGeometry.NORMAL_FORMAT);
                context.drawTriangles(stageGL.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);
            };

            /**
            * @inheritDoc
            */
            SingleObjectDepthPass.prototype.iActivate = function (stageGL, camera) {
                if (this._projectionTexturesInvalid)
                    this.updateProjectionTextures();

                // never scale
                _super.prototype.iActivate.call(this, stageGL, camera);

                stageGL.contextGL.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);
            };
            return SingleObjectDepthPass;
        })(materials.MaterialPassBase);
        materials.SingleObjectDepthPass = SingleObjectDepthPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * SegmentPass is a material pass that draws wireframe segments.
        */
        var SegmentPass = (function (_super) {
            __extends(SegmentPass, _super);
            /**
            * Creates a new SegmentPass object.
            *
            * @param thickness the thickness of the segments to be drawn.
            */
            function SegmentPass(thickness) {
                _super.call(this);
                this._constants = new Array(0, 0, 0, 0);

                this._calcMatrix = new away.geom.Matrix3D();

                this._thickness = thickness;
                this._constants[1] = 1 / 255;
            }
            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iGetVertexCode = function () {
                return "m44 vt0, va0, vc8			\n" + "m44 vt1, va1, vc8			\n" + "sub vt2, vt1, vt0 			\n" + "slt vt5.x, vt0.z, vc7.z			\n" + "sub vt5.y, vc5.x, vt5.x			\n" + "add vt4.x, vt0.z, vc7.z			\n" + "sub vt4.y, vt0.z, vt1.z			\n" + "seq vt4.z, vt4.y vc6.x			\n" + "add vt4.y, vt4.y, vt4.z			\n" + "div vt4.z, vt4.x, vt4.y			\n" + "mul vt4.xyz, vt4.zzz, vt2.xyz	\n" + "add vt3.xyz, vt0.xyz, vt4.xyz	\n" + "mov vt3.w, vc5.x			\n" + "mul vt0, vt0, vt5.yyyy			\n" + "mul vt3, vt3, vt5.xxxx			\n" + "add vt0, vt0, vt3				\n" + "sub vt2, vt1, vt0 			\n" + "nrm vt2.xyz, vt2.xyz			\n" + "nrm vt5.xyz, vt0.xyz			\n" + "mov vt5.w, vc5.x				\n" + "crs vt3.xyz, vt2, vt5			\n" + "nrm vt3.xyz, vt3.xyz			\n" + "mul vt3.xyz, vt3.xyz, va2.xxx	\n" + "mov vt3.w, vc5.x			\n" + "dp3 vt4.x, vt0, vc6			\n" + "mul vt4.x, vt4.x, vc7.x			\n" + "mul vt3.xyz, vt3.xyz, vt4.xxx	\n" + "add vt0.xyz, vt0.xyz, vt3.xyz	\n" + "m44 op, vt0, vc0			\n" + "mov v0, va3				\n";
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iGetFragmentCode = function (animationCode) {
                return "mov oc, v0\n";
            };

            /**
            * @inheritDoc
            * todo: keep maps in dictionary per renderable
            */
            SegmentPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var context = stageGL.contextGL;
                this._calcMatrix.copyFrom(renderable.sourceEntity.sceneTransform);
                this._calcMatrix.append(camera.inverseSceneTransform);
                context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 8, this._calcMatrix, true);

                stageGL.activateBuffer(0, renderable.getVertexData(away.base.LineSubGeometry.START_POSITION_DATA), renderable.getVertexOffset(away.base.LineSubGeometry.START_POSITION_DATA), away.base.LineSubGeometry.POSITION_FORMAT);
                stageGL.activateBuffer(1, renderable.getVertexData(away.base.LineSubGeometry.END_POSITION_DATA), renderable.getVertexOffset(away.base.LineSubGeometry.END_POSITION_DATA), away.base.LineSubGeometry.POSITION_FORMAT);
                stageGL.activateBuffer(2, renderable.getVertexData(away.base.LineSubGeometry.THICKNESS_DATA), renderable.getVertexOffset(away.base.LineSubGeometry.THICKNESS_DATA), away.base.LineSubGeometry.THICKNESS_FORMAT);
                stageGL.activateBuffer(3, renderable.getVertexData(away.base.LineSubGeometry.COLOR_DATA), renderable.getVertexOffset(away.base.LineSubGeometry.COLOR_DATA), away.base.LineSubGeometry.COLOR_FORMAT);

                context.drawTriangles(stageGL.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iActivate = function (stageGL, camera) {
                var context = stageGL.contextGL;
                _super.prototype.iActivate.call(this, stageGL, camera);

                if (stageGL.scissorRect)
                    this._constants[0] = this._thickness / Math.min(stageGL.scissorRect.width, stageGL.scissorRect.height);
                else
                    this._constants[0] = this._thickness / Math.min(stageGL.width, stageGL.height);

                // value to convert distance from camera to model length per pixel width
                this._constants[2] = camera.projection.near;

                context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 5, SegmentPass.pONE_VECTOR, 1);
                context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 6, SegmentPass.pFRONT_VECTOR, 1);
                context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 7, this._constants, 1);

                // projection matrix
                context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 0, camera.projection.matrix, true);
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.pDeactivate = function (stageGL) {
                var context = stageGL.contextGL;
                context.setVertexBufferAt(0, null);
                context.setVertexBufferAt(1, null);
                context.setVertexBufferAt(2, null);
                context.setVertexBufferAt(3, null);
            };
            SegmentPass.pONE_VECTOR = Array(1, 1, 1, 1);
            SegmentPass.pFRONT_VECTOR = Array(0, 0, -1, 0);
            return SegmentPass;
        })(materials.MaterialPassBase);
        materials.SegmentPass = SegmentPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var SubGeometry = away.base.TriangleSubGeometry;

        /**
        * SkyboxPass provides a material pass exclusively used to render sky boxes from a cube texture.
        */
        var SkyboxPass = (function (_super) {
            __extends(SkyboxPass, _super);
            /**
            * Creates a new SkyboxPass object.
            */
            function SkyboxPass() {
                _super.call(this);
                this.mipmap = false;
                this._pNumUsedTextures = 1;
                this._vertexData = new Array(0, 0, 0, 0, 1, 1, 1, 1);
            }
            Object.defineProperty(SkyboxPass.prototype, "cubeTexture", {
                /**
                * The cube texture to use as the skybox.
                */
                get: function () {
                    return this._cubeTexture;
                },
                set: function (value) {
                    this._cubeTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkyboxPass.prototype.iGetVertexCode = function () {
                return "mul vt0, va0, vc5\n" + "add vt0, vt0, vc4\n" + "m44 op, vt0, vc0\n" + "mov v0, va0\n";
            };

            /**
            * @inheritDoc
            */
            SkyboxPass.prototype.iGetFragmentCode = function (animationCode) {
                var format;
                switch (this._cubeTexture.format) {
                    case away.stagegl.ContextGLTextureFormat.COMPRESSED:
                        format = "dxt1,";
                        break;
                    case "compressedAlpha":
                        format = "dxt5,";
                        break;
                    default:
                        format = "";
                }

                var mip = ",mipnone";

                if (this._cubeTexture.hasMipmaps) {
                    mip = ",miplinear";
                }
                return "tex ft0, v0, fs0 <cube," + format + "linear,clamp" + mip + ">\n" + "mov oc, ft0\n";
            };

            /**
            * @inheritDoc
            */
            SkyboxPass.prototype.iRender = function (renderable, stageGL, camera, viewProjection) {
                var context = stageGL.contextGL;
                var pos = camera.scenePosition;
                this._vertexData[0] = pos.x;
                this._vertexData[1] = pos.y;
                this._vertexData[2] = pos.z;
                this._vertexData[4] = this._vertexData[5] = this._vertexData[6] = camera.projection.far / Math.sqrt(3);
                context.setProgramConstantsFromMatrix(away.stagegl.ContextGLProgramType.VERTEX, 0, viewProjection, true);
                context.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, 4, this._vertexData, 2);

                stageGL.activateBuffer(0, renderable.getVertexData(SubGeometry.POSITION_DATA), renderable.getVertexOffset(SubGeometry.POSITION_DATA), SubGeometry.POSITION_FORMAT);
                context.drawTriangles(stageGL.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);
            };

            /**
            * @inheritDoc
            */
            SkyboxPass.prototype.iActivate = function (stageGL, camera) {
                _super.prototype.iActivate.call(this, stageGL, camera);
                var context = stageGL.contextGL;
                context.setSamplerStateAt(0, away.stagegl.ContextGLWrapMode.CLAMP, away.stagegl.ContextGLTextureFilter.LINEAR, this._cubeTexture.hasMipmaps ? away.stagegl.ContextGLMipFilter.MIPLINEAR : away.stagegl.ContextGLMipFilter.MIPNONE);
                context.setDepthTest(false, away.stagegl.ContextGLCompareMode.LESS);
                this._cubeTexture.activateTextureForStage(0, stageGL);
            };
            return SkyboxPass;
        })(materials.MaterialPassBase);
        materials.SkyboxPass = SkyboxPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * MethodVO contains data for a given method for the use within a single material.
        * This allows methods to be shared across materials while their non-public state differs.
        */
        var MethodVO = (function () {
            /**
            * Creates a new MethodVO object.
            */
            function MethodVO() {
                this.useLightFallOff = true;
            }
            /**
            * Resets the values of the value object to their "unused" state.
            */
            MethodVO.prototype.reset = function () {
                this.texturesIndex = -1;
                this.vertexConstantsIndex = -1;
                this.fragmentConstantsIndex = -1;

                this.useMipmapping = true;
                this.useSmoothTextures = true;
                this.repeatTextures = false;

                this.needsProjection = false;
                this.needsView = false;
                this.needsNormals = false;
                this.needsTangents = false;
                this.needsUV = false;
                this.needsSecondaryUV = false;
                this.needsGlobalVertexPos = false;
                this.needsGlobalFragmentPos = false;

                this.numLights = 0;
                this.useLightFallOff = true;
            };
            return MethodVO;
        })();
        materials.MethodVO = MethodVO;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away.arcane;
        /**
        * MethodVOSet provides a EffectMethodBase and MethodVO combination to be used by a material, allowing methods
        * to be shared across different materials while their internal state changes.
        */
        var MethodVOSet = (function () {
            /**
            * Creates a new MethodVOSet object.
            * @param method The method for which we need to store a MethodVO object.
            */
            function MethodVOSet(method) {
                this.method = method;
                this.data = method.iCreateMethodVO();
            }
            return MethodVOSet;
        })();
        materials.MethodVOSet = MethodVOSet;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile
        * the final shading program.
        */
        var ShadingMethodBase = (function (_super) {
            __extends(ShadingMethodBase, _super);
            /**
            * Create a new ShadingMethodBase object.
            */
            function ShadingMethodBase() {
                _super.call(this);
            }
            /**
            * Initializes the properties for a MethodVO, including register and texture indices.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iInitVO = function (vo) {
            };

            /**
            * Initializes unchanging shader constants using the data from a MethodVO.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iInitConstants = function (vo) {
            };

            Object.defineProperty(ShadingMethodBase.prototype, "iSharedRegisters", {
                /**
                * The shared registers created by the compiler and possibly used by methods.
                *
                * @internal
                */
                get: function () {
                    return this._sharedRegisters;
                },
                /**
                * @internal
                */
                set: function (value) {
                    this._sharedRegisters = value;
                },
                enumerable: true,
                configurable: true
            });


            ShadingMethodBase.prototype.setISharedRegisters = function (value) {
                this._sharedRegisters = value;
            };

            Object.defineProperty(ShadingMethodBase.prototype, "passes", {
                /**
                * Any passes required that render to a texture used by this method.
                */
                get: function () {
                    return this._passes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Cleans up any resources used by the current object.
            */
            ShadingMethodBase.prototype.dispose = function () {
            };

            /**
            * Creates a data container that contains material-dependent data. Provided as a factory method so a custom subtype can be overridden when needed.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iCreateMethodVO = function () {
                return new materials.MethodVO();
            };

            /**
            * Resets the compilation state of the method.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iReset = function () {
                this.iCleanCompilationData();
            };

            /**
            * Resets the method's state for compilation.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iCleanCompilationData = function () {
            };

            /**
            * Get the vertex shader code for this method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iGetVertexCode = function (vo, regCache) {
                return "";
            };

            /**
            * Sets the render state for this method.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param stageGL The StageGL object currently used for rendering.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iActivate = function (vo, stageGL) {
            };

            /**
            * Sets the render state for a single renderable.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param renderable The renderable currently being rendered.
            * @param stageGL The StageGL object currently used for rendering.
            * @param camera The camera from which the scene is currently rendered.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
            };

            /**
            * Clears the render state for this method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param stageGL The StageGL object currently used for rendering.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iDeactivate = function (vo, stageGL) {
            };

            /**
            * A helper method that generates standard code for sampling from a texture using the normal uv coordinates.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param targetReg The register in which to store the sampled colour.
            * @param inputReg The texture stream register.
            * @param texture The texture which will be assigned to the given slot.
            * @param uvReg An optional uv register if coordinates different from the primary uv coordinates are to be used.
            * @param forceWrap If true, texture wrapping is enabled regardless of the material setting.
            * @return The fragment code that performs the sampling.
            *
            * @protected
            */
            ShadingMethodBase.prototype.pGetTex2DSampleCode = function (vo, targetReg, inputReg, texture, uvReg, forceWrap) {
                if (typeof uvReg === "undefined") { uvReg = null; }
                if (typeof forceWrap === "undefined") { forceWrap = null; }
                var wrap = forceWrap || (vo.repeatTextures ? "wrap" : "clamp");
                var filter;

                var format = this.getFormatStringForTexture(texture);
                var enableMipMaps = vo.useMipmapping && texture.hasMipmaps;

                if (vo.useSmoothTextures)
                    filter = enableMipMaps ? "linear,miplinear" : "linear";
                else
                    filter = enableMipMaps ? "nearest,mipnearest" : "nearest";

                if (uvReg == null)
                    uvReg = this._sharedRegisters.uvVarying;

                return "tex " + targetReg + ", " + uvReg + ", " + inputReg + " <2d," + filter + "," + format + wrap + ">\n";
            };

            /**
            * A helper method that generates standard code for sampling from a cube texture.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param targetReg The register in which to store the sampled colour.
            * @param inputReg The texture stream register.
            * @param texture The cube map which will be assigned to the given slot.
            * @param uvReg The direction vector with which to sample the cube map.
            *
            * @protected
            */
            ShadingMethodBase.prototype.pGetTexCubeSampleCode = function (vo, targetReg, inputReg, texture, uvReg) {
                var filter;
                var format = this.getFormatStringForTexture(texture);
                var enableMipMaps = vo.useMipmapping && texture.hasMipmaps;

                if (vo.useSmoothTextures)
                    filter = enableMipMaps ? "linear,miplinear" : "linear";
                else
                    filter = enableMipMaps ? "nearest,mipnearest" : "nearest";

                return "tex " + targetReg + ", " + uvReg + ", " + inputReg + " <cube," + format + filter + ">\n";
            };

            /**
            * Generates a texture format string for the sample instruction.
            * @param texture The texture for which to get the format string.
            * @return
            *
            * @protected
            */
            ShadingMethodBase.prototype.getFormatStringForTexture = function (texture) {
                switch (texture.format) {
                    case away.stagegl.ContextGLTextureFormat.COMPRESSED:
                        return "dxt1,";
                        break;
                    case "compressedAlpha":
                        return "dxt5,";
                        break;
                    default:
                        return "";
                }
            };

            /**
            * Marks the shader program as invalid, so it will be recompiled before the next render.
            *
            * @internal
            */
            ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {
                this.dispatchEvent(new away.events.ShadingMethodEvent(away.events.ShadingMethodEvent.SHADER_INVALIDATED));
            };

            /**
            * Copies the state from a ShadingMethodBase object into the current object.
            */
            ShadingMethodBase.prototype.copyFrom = function (method) {
            };
            return ShadingMethodBase;
        })(away.library.NamedAssetBase);
        materials.ShadingMethodBase = ShadingMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away.arcane;
        //import away.materials.compilation.ShaderRegisterCache;
        //import away.materials.compilation.ShaderRegisterElement;
        //use namespace arcane;
        /**
        * LightingMethodBase provides an abstract base method for shading methods that uses lights.
        * Used for diffuse and specular shaders only.
        */
        var LightingMethodBase = (function (_super) {
            __extends(LightingMethodBase, _super);
            /**
            * Creates a new LightingMethodBase.
            */
            function LightingMethodBase() {
                _super.call(this);
            }
            /**
            * Get the fragment shader code that will be needed before any per-light code is added.
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @private
            */
            LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that will generate the code relevant to a single light.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param lightDirReg The register containing the light direction vector.
            * @param lightColReg The register containing the light colour.
            * @param regCache The register cache used during the compilation.
            */
            LightingMethodBase.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that will generate the code relevant to a single light probe object.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param cubeMapReg The register containing the cube map for the current probe
            * @param weightRegister A string representation of the register + component containing the current weight
            * @param regCache The register cache providing any necessary registers to the shader
            */
            LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register containing the final shading output.
            * @private
            */
            LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return "";
            };
            return LightingMethodBase;
        })(materials.ShadingMethodBase);
        materials.LightingMethodBase = LightingMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away.*;
        //import away.errors.*;
        //import away.library.assets.*;
        //import away.lights.*;
        //import away.lights.shadowmaps.*;
        //import away.materials.compilation.*;
        //use namespace arcane;
        /**
        * ShadowMapMethodBase provides an abstract base method for shadow map methods.
        */
        var ShadowMapMethodBase = (function (_super) {
            __extends(ShadowMapMethodBase, _super);
            /**
            * Creates a new ShadowMapMethodBase object.
            * @param castingLight The light used to cast shadows.
            */
            function ShadowMapMethodBase(castingLight) {
                _super.call(this);
                this._pEpsilon = .02;
                this._pAlpha = 1;
                this._pCastingLight = castingLight;
                castingLight.castsShadows = true;
                this._pShadowMapper = castingLight.shadowMapper;
            }
            Object.defineProperty(ShadowMapMethodBase.prototype, "assetType", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return away.library.AssetType.SHADOW_MAP_METHOD;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapMethodBase.prototype, "alpha", {
                /**
                * The "transparency" of the shadows. This allows making shadows less strong.
                */
                get: function () {
                    return this._pAlpha;
                },
                set: function (value) {
                    this._pAlpha = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowMapMethodBase.prototype, "castingLight", {
                /**
                * The light casting the shadows.
                */
                get: function () {
                    return this._pCastingLight;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapMethodBase.prototype, "epsilon", {
                /**
                * A small value to counter floating point precision errors when comparing values in the shadow map with the
                * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.
                */
                get: function () {
                    return this._pEpsilon;
                },
                set: function (value) {
                    this._pEpsilon = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowMapMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return null;
            };
            return ShadowMapMethodBase;
        })(materials.ShadingMethodBase);
        materials.ShadowMapMethodBase = ShadowMapMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var Delegate = away.utils.Delegate;

        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        /**
        * ShaderMethodSetup contains the method configuration for an entire material.
        */
        var ShaderMethodSetup = (function (_super) {
            __extends(ShaderMethodSetup, _super);
            /**
            * Creates a new <code>ShaderMethodSetup</code> object.
            */
            function ShaderMethodSetup() {
                _super.call(this);

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                this._iMethods = new Array();
                this._iNormalMethod = new materials.NormalBasicMethod();
                this._iAmbientMethod = new materials.AmbientBasicMethod();
                this._iDiffuseMethod = new materials.DiffuseBasicMethod();
                this._iSpecularMethod = new materials.SpecularBasicMethod();

                this._iNormalMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._iDiffuseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._iSpecularMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._iAmbientMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                this._iNormalMethodVO = this._iNormalMethod.iCreateMethodVO();
                this._iAmbientMethodVO = this._iAmbientMethod.iCreateMethodVO();
                this._iDiffuseMethodVO = this._iDiffuseMethod.iCreateMethodVO();
                this._iSpecularMethodVO = this._iSpecularMethod.iCreateMethodVO();
            }
            /**
            * Called when any method's code is invalidated.
            */
            ShaderMethodSetup.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };

            /**
            * Invalidates the material's shader code.
            */
            ShaderMethodSetup.prototype.iInvalidateShaderProgram = function () {
                this.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));
            };

            Object.defineProperty(ShaderMethodSetup.prototype, "normalMethod", {
                /**
                *  The method used to generate the per-pixel normals.
                */
                get: function () {
                    return this._iNormalMethod;
                },
                set: function (value) {
                    if (this._iNormalMethod)
                        this._iNormalMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    if (value) {
                        if (this._iNormalMethod)
                            value.copyFrom(this._iNormalMethod);

                        this._iNormalMethodVO = value.iCreateMethodVO();
                        value.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    }

                    this._iNormalMethod = value;

                    if (value)
                        this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "ambientMethod", {
                /**
                * The method that provides the ambient lighting contribution.
                */
                get: function () {
                    return this._iAmbientMethod;
                },
                set: function (value) {
                    if (this._iAmbientMethod)
                        this._iAmbientMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    if (value) {
                        if (this._iAmbientMethod)
                            value.copyFrom(this._iAmbientMethod);

                        value.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                        this._iAmbientMethodVO = value.iCreateMethodVO();
                    }

                    this._iAmbientMethod = value;

                    if (value)
                        this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "shadowMethod", {
                /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered.
                */
                get: function () {
                    return this._iShadowMethod;
                },
                set: function (value) {
                    if (this._iShadowMethod)
                        this._iShadowMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    this._iShadowMethod = value;

                    if (this._iShadowMethod) {
                        this._iShadowMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                        this._iShadowMethodVO = this._iShadowMethod.iCreateMethodVO();
                    } else {
                        this._iShadowMethodVO = null;
                    }

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "diffuseMethod", {
                /**
                * The method that provides the diffuse lighting contribution.
                */
                get: function () {
                    return this._iDiffuseMethod;
                },
                set: function (value) {
                    if (this._iDiffuseMethod)
                        this._iDiffuseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    if (value) {
                        if (this._iDiffuseMethod)
                            value.copyFrom(this._iDiffuseMethod);

                        value.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                        this._iDiffuseMethodVO = value.iCreateMethodVO();
                    }

                    this._iDiffuseMethod = value;

                    if (value)
                        this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "specularMethod", {
                /**
                * The method to perform specular shading.
                */
                get: function () {
                    return this._iSpecularMethod;
                },
                set: function (value) {
                    if (this._iSpecularMethod) {
                        this._iSpecularMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                        if (value)
                            value.copyFrom(this._iSpecularMethod);
                    }

                    this._iSpecularMethod = value;

                    if (this._iSpecularMethod) {
                        this._iSpecularMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                        this._iSpecularMethodVO = this._iSpecularMethod.iCreateMethodVO();
                    } else {
                        this._iSpecularMethodVO = null;
                    }

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "iColorTransformMethod", {
                /**
                * @private
                */
                get: function () {
                    return this._iColorTransformMethod;
                },
                set: function (value) {
                    if (this._iColorTransformMethod == value)
                        return;

                    if (this._iColorTransformMethod)
                        this._iColorTransformMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    if (!this._iColorTransformMethod || !value)
                        this.iInvalidateShaderProgram();

                    this._iColorTransformMethod = value;

                    if (this._iColorTransformMethod) {
                        this._iColorTransformMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                        this._iColorTransformMethodVO = this._iColorTransformMethod.iCreateMethodVO();
                    } else {
                        this._iColorTransformMethodVO = null;
                    }
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Disposes the object.
            */
            ShaderMethodSetup.prototype.dispose = function () {
                this.clearListeners(this._iNormalMethod);
                this.clearListeners(this._iDiffuseMethod);
                this.clearListeners(this._iShadowMethod);
                this.clearListeners(this._iAmbientMethod);
                this.clearListeners(this._iSpecularMethod);

                for (var i = 0; i < this._iMethods.length; ++i)
                    this.clearListeners(this._iMethods[i].method);

                this._iMethods = null;
            };

            /**
            * Removes all listeners from a method.
            */
            ShaderMethodSetup.prototype.clearListeners = function (method) {
                if (method)
                    method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            };

            /**
            * Adds a method to change the material after all lighting is performed.
            * @param method The method to be added.
            */
            ShaderMethodSetup.prototype.addMethod = function (method) {
                this._iMethods.push(new materials.MethodVOSet(method));

                method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                this.iInvalidateShaderProgram();
            };

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            ShaderMethodSetup.prototype.hasMethod = function (method) {
                return this.getMethodSetForMethod(method) != null;
            };

            /**
            * Inserts a method to change the material after all lighting is performed at the given index.
            * @param method The method to be added.
            * @param index The index of the method's occurrence
            */
            ShaderMethodSetup.prototype.addMethodAt = function (method, index) {
                this._iMethods.splice(index, 0, new materials.MethodVOSet(method));

                method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                this.iInvalidateShaderProgram();
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            ShaderMethodSetup.prototype.getMethodAt = function (index) {
                if (index > this._iMethods.length - 1)
                    return null;

                return this._iMethods[index].method;
            };

            Object.defineProperty(ShaderMethodSetup.prototype, "numMethods", {
                /**
                * The number of "effect" methods added to the material.
                */
                get: function () {
                    return this._iMethods.length;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Removes a method from the pass.
            * @param method The method to be removed.
            */
            ShaderMethodSetup.prototype.removeMethod = function (method) {
                var methodSet = this.getMethodSetForMethod(method);

                if (methodSet != null) {
                    var index = this._iMethods.indexOf(methodSet);

                    this._iMethods.splice(index, 1);

                    method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);

                    this.iInvalidateShaderProgram();
                }
            };

            ShaderMethodSetup.prototype.getMethodSetForMethod = function (method) {
                var len = this._iMethods.length;

                for (var i = 0; i < len; ++i)
                    if (this._iMethods[i].method == method)
                        return this._iMethods[i];

                return null;
            };
            return ShaderMethodSetup;
        })(away.events.EventDispatcher);
        materials.ShaderMethodSetup = ShaderMethodSetup;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * AmbientBasicMethod provides the default shading method for uniform ambient lighting.
        */
        var AmbientBasicMethod = (function (_super) {
            __extends(AmbientBasicMethod, _super);
            /**
            * Creates a new AmbientBasicMethod object.
            */
            function AmbientBasicMethod() {
                _super.call(this);
                this._useTexture = false;
                this._ambientColor = 0xffffff;
                this._ambientR = 0;
                this._ambientG = 0;
                this._ambientB = 0;
                this._ambient = 1;
                this._iLightAmbientR = 0;
                this._iLightAmbientG = 0;
                this._iLightAmbientB = 0;
            }
            /**
            * @inheritDoc
            */
            AmbientBasicMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._useTexture;
            };

            /**
            * @inheritDoc
            */
            AmbientBasicMethod.prototype.iInitConstants = function (vo) {
                vo.fragmentData[vo.fragmentConstantsIndex + 3] = 1;
            };

            Object.defineProperty(AmbientBasicMethod.prototype, "ambient", {
                /**
                * The strength of the ambient reflection of the surface.
                */
                get: function () {
                    return this._ambient;
                },
                set: function (value) {
                    this._ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AmbientBasicMethod.prototype, "ambientColor", {
                /**
                * The colour of the ambient reflection of the surface.
                */
                get: function () {
                    return this._ambientColor;
                },
                set: function (value) {
                    this._ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AmbientBasicMethod.prototype, "texture", {
                /**
                * The bitmapData to use to define the diffuse reflection color per texel.
                */
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    /* // ORIGINAL conditional
                    if (Boolean(value) != _useTexture ||
                    (value && _texture && (value.hasMipmaps != _texture.hasMipmaps || value.format != _texture.format))) {
                    iInvalidateShaderProgram();
                    }
                    */
                    if (b != this._useTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }
                    this._useTexture = b; //Boolean(value);
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            AmbientBasicMethod.prototype.copyFrom = function (method) {
                var m = method;
                var b = m;

                var diff = b;

                this.ambient = diff.ambient;
                this.ambientColor = diff.ambientColor;
            };

            /**
            * @inheritDoc
            */
            AmbientBasicMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._pAmbientInputRegister = null;
            };

            /**
            * @inheritDoc
            */
            AmbientBasicMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = "";

                if (this._useTexture) {
                    this._pAmbientInputRegister = regCache.getFreeTextureReg();

                    vo.texturesIndex = this._pAmbientInputRegister.index;

                    // TODO: AGAL <> GLSL
                    code += this.pGetTex2DSampleCode(vo, targetReg, this._pAmbientInputRegister, this._texture) + "div " + targetReg + ".xyz, " + targetReg + ".xyz, " + targetReg + ".w\n"; // apparently, still needs to un-premultiply :s
                } else {
                    this._pAmbientInputRegister = regCache.getFreeFragmentConstant();
                    vo.fragmentConstantsIndex = this._pAmbientInputRegister.index * 4;

                    code += "mov " + targetReg + ", " + this._pAmbientInputRegister + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            AmbientBasicMethod.prototype.iActivate = function (vo, stageGL) {
                if (this._useTexture) {
                    stageGL.contextGL.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.stagegl.ContextGLWrapMode.REPEAT : away.stagegl.ContextGLWrapMode.CLAMP, vo.useSmoothTextures ? away.stagegl.ContextGLTextureFilter.LINEAR : away.stagegl.ContextGLTextureFilter.NEAREST, vo.useMipmapping ? away.stagegl.ContextGLMipFilter.MIPLINEAR : away.stagegl.ContextGLMipFilter.MIPNONE);

                    this._texture.activateTextureForStage(vo.texturesIndex, stageGL);
                }
            };

            /**
            * Updates the ambient color data used by the render state.
            */
            AmbientBasicMethod.prototype.updateAmbient = function () {
                this._ambientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient * this._iLightAmbientR;
                this._ambientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient * this._iLightAmbientG;
                this._ambientB = (this.ambientColor & 0xff) / 0xff * this._ambient * this._iLightAmbientB;
            };

            /**
            * @inheritDoc
            */
            AmbientBasicMethod.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
                this.updateAmbient();

                if (!this._useTexture) {
                    var index = vo.fragmentConstantsIndex;
                    var data = vo.fragmentData;
                    data[index] = this._ambientR;
                    data[index + 1] = this._ambientG;
                    data[index + 2] = this._ambientB;
                }
            };
            return AmbientBasicMethod;
        })(materials.ShadingMethodBase);
        materials.AmbientBasicMethod = AmbientBasicMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to
        * approximate global lighting rather than lights.
        */
        var AmbientEnvMapMethod = (function (_super) {
            __extends(AmbientEnvMapMethod, _super);
            /**
            * Creates a new <code>AmbientEnvMapMethod</code> object.
            *
            * @param envMap The cube environment map to use for the ambient lighting.
            */
            function AmbientEnvMapMethod(envMap) {
                _super.call(this);
                this._cubeTexture = envMap;
            }
            /**
            * @inheritDoc
            */
            AmbientEnvMapMethod.prototype.iInitVO = function (vo) {
                _super.prototype.iInitVO.call(this, vo);
                vo.needsNormals = true;
            };

            Object.defineProperty(AmbientEnvMapMethod.prototype, "envMap", {
                /**
                * The cube environment map to use for the diffuse lighting.
                */
                get: function () {
                    return this._cubeTexture;
                },
                set: function (value) {
                    this._cubeTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            AmbientEnvMapMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);

                this._cubeTexture.activateTextureForStage(vo.texturesIndex, stageGL);
            };

            /**
            * @inheritDoc
            */
            AmbientEnvMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = "";
                var cubeMapReg = regCache.getFreeTextureReg();
                vo.texturesIndex = cubeMapReg.index;

                code += this.pGetTexCubeSampleCode(vo, targetReg, cubeMapReg, this._cubeTexture, this._sharedRegisters.normalFragment);

                this._pAmbientInputRegister = regCache.getFreeFragmentConstant();
                vo.fragmentConstantsIndex = this._pAmbientInputRegister.index;

                code += "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + this._pAmbientInputRegister + ".xyz\n";

                return code;
            };
            return AmbientEnvMapMethod;
        })(materials.AmbientBasicMethod);
        materials.AmbientEnvMapMethod = AmbientEnvMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away.arcane;
        //import away.base.StageGL;
        //import away.materials.compilation.ShaderRegisterCache;
        //import away.materials.compilation.ShaderRegisterElement;
        //import away.textures.Texture2DBase;
        //use namespace arcane;
        /**
        * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.
        */
        var DiffuseBasicMethod = (function (_super) {
            __extends(DiffuseBasicMethod, _super);
            /**
            * Creates a new DiffuseBasicMethod object.
            */
            function DiffuseBasicMethod() {
                _super.call(this);
                this._diffuseColor = 0xffffff;
                this._diffuseR = 1;
                this._diffuseG = 1;
                this._diffuseB = 1;
                this._diffuseA = 1;
                this._alphaThreshold = 0;
            }
            Object.defineProperty(DiffuseBasicMethod.prototype, "iUseAmbientTexture", {
                /**
                * Set internally if the ambient method uses a texture.
                */
                get: function () {
                    return this._useAmbientTexture;
                },
                set: function (value) {
                    if (this._useAmbientTexture == value)
                        return;

                    this._useAmbientTexture = value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            DiffuseBasicMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._pUseTexture;
                vo.needsNormals = vo.numLights > 0;
            };

            /**
            * Forces the creation of the texture.
            * @param stageGL The StageGL used by the renderer
            */
            DiffuseBasicMethod.prototype.generateMip = function (stageGL) {
                if (this._pUseTexture)
                    this._texture.activateTextureForStage(0, stageGL);
            };

            Object.defineProperty(DiffuseBasicMethod.prototype, "diffuseAlpha", {
                /**
                * The alpha component of the diffuse reflection.
                */
                get: function () {
                    return this._diffuseA;
                },
                set: function (value) {
                    this._diffuseA = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseBasicMethod.prototype, "diffuseColor", {
                /**
                * The color of the diffuse reflection when not using a texture.
                */
                get: function () {
                    return this._diffuseColor;
                },
                set: function (diffuseColor) {
                    this._diffuseColor = diffuseColor;
                    this.updateDiffuse();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseBasicMethod.prototype, "texture", {
                /**
                * The bitmapData to use to define the diffuse reflection color per texel.
                */
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._pUseTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }

                    this._pUseTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseBasicMethod.prototype, "alphaThreshold", {
                /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                get: function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
                    else if (value > 1)
                        value = 1;
                    if (value == this._alphaThreshold)
                        return;

                    if (value == 0 || this._alphaThreshold == 0)
                        this.iInvalidateShaderProgram();

                    this._alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DiffuseBasicMethod.prototype.dispose = function () {
                this._texture = null;
            };

            /**
            * @inheritDoc
            */
            DiffuseBasicMethod.prototype.copyFrom = function (method) {
                var m = method;

                var diff = m;

                this.alphaThreshold = diff.alphaThreshold;
                this.texture = diff.texture;
                this.iUseAmbientTexture = diff.iUseAmbientTexture;
                this.diffuseAlpha = diff.diffuseAlpha;
                this.diffuseColor = diff.diffuseColor;
            };

            /**
            * @inheritDoc
            */
            DiffuseBasicMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);

                this._pShadowRegister = null;
                this._pTotalLightColorReg = null;
                this._pDiffuseInputRegister = null;
            };

            /**
            * @inheritDoc
            */
            DiffuseBasicMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                var code = "";

                this._pIsFirstLight = true;

                if (vo.numLights > 0) {
                    this._pTotalLightColorReg = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseBasicMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                // write in temporary if not first light, so we can add to total diffuse colour
                if (this._pIsFirstLight) {
                    t = this._pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                //TODO: AGAL <> GLSL
                //*
                code += "dp3 " + t + ".x, " + lightDirReg + ", " + this._sharedRegisters.normalFragment + "\n" + "max " + t + ".w, " + t + ".x, " + this._sharedRegisters.commons + ".y\n";

                if (vo.useLightFallOff) {
                    code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
                }

                if (this._iModulateMethod != null)
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);

                code += "mul " + t + ", " + t + ".w, " + lightColReg + "\n";

                if (!this._pIsFirstLight) {
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
                    regCache.removeFragmentTempUsage(t);
                }

                //*/
                this._pIsFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseBasicMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = "";
                var t;

                // write in temporary if not first light, so we can add to total diffuse colour
                if (this._pIsFirstLight) {
                    t = this._pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                // TODO: AGAL <> GLSL
                code += "tex " + t + ", " + this._sharedRegisters.normalFragment + ", " + cubeMapReg + " <cube,linear,miplinear>\n" + "mul " + t + ".xyz, " + t + ".xyz, " + weightRegister + "\n";

                if (this._iModulateMethod != null)
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);

                if (!this._pIsFirstLight) {
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseBasicMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code = "";
                var albedo;
                var cutOffReg;

                // incorporate input from ambient
                if (vo.numLights > 0) {
                    if (this._pShadowRegister)
                        code += this.pApplyShadow(vo, regCache);

                    albedo = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(albedo, 1);
                } else {
                    albedo = targetReg;
                }

                if (this._pUseTexture) {
                    this._pDiffuseInputRegister = regCache.getFreeTextureReg();

                    vo.texturesIndex = this._pDiffuseInputRegister.index;

                    code += this.pGetTex2DSampleCode(vo, albedo, this._pDiffuseInputRegister, this._texture);

                    if (this._alphaThreshold > 0) {
                        //TODO: AGAL <> GLSL
                        cutOffReg = regCache.getFreeFragmentConstant();
                        vo.fragmentConstantsIndex = cutOffReg.index * 4;

                        code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" + "kil " + albedo + ".w\n" + "add " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n";
                    }
                } else {
                    //TODO: AGAL <> GLSL
                    this._pDiffuseInputRegister = regCache.getFreeFragmentConstant();

                    vo.fragmentConstantsIndex = this._pDiffuseInputRegister.index * 4;

                    code += "mov " + albedo + ", " + this._pDiffuseInputRegister + "\n";
                }

                if (vo.numLights == 0)
                    return code;

                //TODO: AGAL <> GLSL
                code += "sat " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + "\n";

                if (this._useAmbientTexture) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + albedo + ".xyz, " + albedo + ", " + this._pTotalLightColorReg + "\n" + "mul " + this._pTotalLightColorReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n" + "sub " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n" + "add " + targetReg + ".xyz, " + albedo + ", " + targetReg + "\n";
                } else {
                    //TODO: AGAL <> GLSL
                    code += "add " + targetReg + ".xyz, " + this._pTotalLightColorReg + ", " + targetReg + "\n";

                    if (this._pUseTexture) {
                        code += "mul " + targetReg + ".xyz, " + albedo + ", " + targetReg + "\n" + "mov " + targetReg + ".w, " + albedo + ".w\n";
                    } else {
                        code += "mul " + targetReg + ".xyz, " + this._pDiffuseInputRegister + ", " + targetReg + "\n" + "mov " + targetReg + ".w, " + this._pDiffuseInputRegister + ".w\n";
                    }
                }

                regCache.removeFragmentTempUsage(this._pTotalLightColorReg);
                regCache.removeFragmentTempUsage(albedo);

                return code;
            };

            /**
            * Generate the code that applies the calculated shadow to the diffuse light
            * @param vo The MethodVO object for which the compilation is currently happening.
            * @param regCache The register cache the compiler is currently using for the register management.
            */
            DiffuseBasicMethod.prototype.pApplyShadow = function (vo, regCache) {
                //TODO: AGAL <> GLSL
                return "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pShadowRegister + ".w\n";
            };

            /**
            * @inheritDoc
            */
            DiffuseBasicMethod.prototype.iActivate = function (vo, stageGL) {
                if (this._pUseTexture) {
                    stageGL.contextGL.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.stagegl.ContextGLWrapMode.REPEAT : away.stagegl.ContextGLWrapMode.CLAMP, vo.useSmoothTextures ? away.stagegl.ContextGLTextureFilter.LINEAR : away.stagegl.ContextGLTextureFilter.NEAREST, vo.useMipmapping ? away.stagegl.ContextGLMipFilter.MIPLINEAR : away.stagegl.ContextGLMipFilter.MIPNONE);

                    this._texture.activateTextureForStage(vo.texturesIndex, stageGL);

                    if (this._alphaThreshold > 0)
                        vo.fragmentData[vo.fragmentConstantsIndex] = this._alphaThreshold;
                } else {
                    var index = vo.fragmentConstantsIndex;
                    var data = vo.fragmentData;
                    data[index] = this._diffuseR;
                    data[index + 1] = this._diffuseG;
                    data[index + 2] = this._diffuseB;
                    data[index + 3] = this._diffuseA;
                }
            };

            /**
            * Updates the diffuse color data used by the render state.
            */
            DiffuseBasicMethod.prototype.updateDiffuse = function () {
                this._diffuseR = ((this._diffuseColor >> 16) & 0xff) / 0xff;
                this._diffuseG = ((this._diffuseColor >> 8) & 0xff) / 0xff;
                this._diffuseB = (this._diffuseColor & 0xff) / 0xff;
            };

            Object.defineProperty(DiffuseBasicMethod.prototype, "iShadowRegister", {
                /**
                * Set internally by the compiler, so the method knows the register containing the shadow calculation.
                */
                set: function (value) {
                    this._pShadowRegister = value;
                },
                enumerable: true,
                configurable: true
            });

            DiffuseBasicMethod.prototype.setIShadowRegister = function (value) {
                this._pShadowRegister = value;
            };
            return DiffuseBasicMethod;
        })(materials.LightingMethodBase);
        materials.DiffuseBasicMethod = DiffuseBasicMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var Delegate = away.utils.Delegate;

        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        /**
        * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the
        * calculated diffuse reflection strength.
        */
        var DiffuseCompositeMethod = (function (_super) {
            __extends(DiffuseCompositeMethod, _super);
            /**
            * Creates a new <code>DiffuseCompositeMethod</code> object.
            *
            * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.
            * @param baseMethod The base diffuse method on which this method's shading is based.
            */
            function DiffuseCompositeMethod(modulateMethod, baseMethod) {
                if (typeof baseMethod === "undefined") { baseMethod = null; }
                _super.call(this);

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                this.pBaseMethod = baseMethod || new materials.DiffuseBasicMethod();
                this.pBaseMethod._iModulateMethod = modulateMethod;
                this.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            }
            Object.defineProperty(DiffuseCompositeMethod.prototype, "baseMethod", {
                /**
                * The base diffuse method on which this method's shading is based.
                */
                get: function () {
                    return this.pBaseMethod;
                },
                set: function (value) {
                    if (this.pBaseMethod == value)
                        return;

                    this.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this.pBaseMethod = value;
                    this.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iInitVO = function (vo) {
                this.pBaseMethod.iInitVO(vo);
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iInitConstants = function (vo) {
                this.pBaseMethod.iInitConstants(vo);
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.dispose = function () {
                this.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this.pBaseMethod.dispose();
            };

            Object.defineProperty(DiffuseCompositeMethod.prototype, "alphaThreshold", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this.pBaseMethod.alphaThreshold;
                },
                set: function (value) {
                    this.pBaseMethod.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseCompositeMethod.prototype, "texture", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this.pBaseMethod.texture;
                },
                /**
                * @inheritDoc
                */
                set: function (value) {
                    this.pBaseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseCompositeMethod.prototype, "diffuseAlpha", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this.pBaseMethod.diffuseAlpha;
                },
                /**
                * @inheritDoc
                */
                set: function (value) {
                    this.pBaseMethod.diffuseAlpha = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DiffuseCompositeMethod.prototype, "diffuseColor", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this.pBaseMethod.diffuseColor;
                },
                /**
                * @inheritDoc
                */
                set: function (diffuseColor) {
                    this.pBaseMethod.diffuseColor = diffuseColor;
                },
                enumerable: true,
                configurable: true
            });



            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return this.pBaseMethod.iGetFragmentPreLightingCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = this.pBaseMethod.iGetFragmentCodePerLight(vo, lightDirReg, lightColReg, regCache);
                this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;
                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = this.pBaseMethod.iGetFragmentCodePerProbe(vo, cubeMapReg, weightRegister, regCache);
                this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;
                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iActivate = function (vo, stageGL) {
                this.pBaseMethod.iActivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iDeactivate = function (vo, stageGL) {
                this.pBaseMethod.iDeactivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iGetVertexCode = function (vo, regCache) {
                return this.pBaseMethod.iGetVertexCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return this.pBaseMethod.iGetFragmentPostLightingCode(vo, regCache, targetReg);
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iReset = function () {
                this.pBaseMethod.iReset();
            };

            /**
            * @inheritDoc
            */
            DiffuseCompositeMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this.pBaseMethod.iCleanCompilationData();
            };

            Object.defineProperty(DiffuseCompositeMethod.prototype, "iSharedRegisters", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    this.pBaseMethod.setISharedRegisters(value);
                    _super.prototype.setISharedRegisters.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            DiffuseCompositeMethod.prototype.setISharedRegisters = function (value) {
                this.pBaseMethod.setISharedRegisters(value);
                _super.prototype.setISharedRegisters.call(this, value);
            };

            Object.defineProperty(DiffuseCompositeMethod.prototype, "iShadowRegister", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    _super.prototype.setIShadowRegister.call(this, value);
                    this.pBaseMethod.setIShadowRegister(value);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called when the base method's shader code is invalidated.
            */
            DiffuseCompositeMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return DiffuseCompositeMethod;
        })(materials.DiffuseBasicMethod);
        materials.DiffuseCompositeMethod = DiffuseCompositeMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.
        */
        var DiffuseCelMethod = (function (_super) {
            __extends(DiffuseCelMethod, _super);
            /**
            * Creates a new DiffuseCelMethod object.
            * @param levels The amount of shadow gradations.
            * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.
            */
            function DiffuseCelMethod(levels, baseMethod) {
                if (typeof levels === "undefined") { levels = 3; }
                if (typeof baseMethod === "undefined") { baseMethod = null; }
                var _this = this;
                _super.call(this, null, baseMethod);
                this._smoothness = .1;

                this.baseMethod._iModulateMethod = function (vo, target, regCache, sharedRegisters) {
                    return _this.clampDiffuse(vo, target, regCache, sharedRegisters);
                };

                this._levels = levels;
            }
            /**
            * @inheritDoc
            */
            DiffuseCelMethod.prototype.iInitConstants = function (vo) {
                var data = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                _super.prototype.iInitConstants.call(this, vo);
                data[index + 1] = 1;
                data[index + 2] = 0;
            };

            Object.defineProperty(DiffuseCelMethod.prototype, "levels", {
                /**
                * The amount of shadow gradations.
                */
                get: function () {
                    return this._levels;
                },
                set: function (value /*uint*/ ) {
                    this._levels = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseCelMethod.prototype, "smoothness", {
                /**
                * The smoothness of the edge between 2 shading levels.
                */
                get: function () {
                    return this._smoothness;
                },
                set: function (value) {
                    this._smoothness = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DiffuseCelMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._dataReg = null;
            };

            /**
            * @inheritDoc
            */
            DiffuseCelMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                this._dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
                return _super.prototype.iGetFragmentPreLightingCode.call(this, vo, regCache);
            };

            /**
            * @inheritDoc
            */
            DiffuseCelMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var data = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                data[index] = this._levels;
                data[index + 3] = this._smoothness;
            };

            /**
            * Snaps the diffuse shading of the wrapped method to one of the levels.
            * @param vo The MethodVO used to compile the current shader.
            * @param t The register containing the diffuse strength in the "w" component.
            * @param regCache The register cache used for the shader compilation.
            * @param sharedRegisters The shared register data for this shader.
            * @return The AGAL fragment code for the method.
            */
            DiffuseCelMethod.prototype.clampDiffuse = function (vo, t, regCache, sharedRegisters) {
                return "mul " + t + ".w, " + t + ".w, " + this._dataReg + ".x\n" + "frc " + t + ".z, " + t + ".w\n" + "sub " + t + ".y, " + t + ".w, " + t + ".z\n" + "mov " + t + ".x, " + this._dataReg + ".x\n" + "sub " + t + ".x, " + t + ".x, " + this._dataReg + ".y\n" + "rcp " + t + ".x," + t + ".x\n" + "mul " + t + ".w, " + t + ".y, " + t + ".x\n" + "sub " + t + ".y, " + t + ".w, " + t + ".x\n" + "div " + t + ".z, " + t + ".z, " + this._dataReg + ".w\n" + "sat " + t + ".z, " + t + ".z\n" + "mul " + t + ".w, " + t + ".w, " + t + ".z\n" + "sub " + t + ".z, " + this._dataReg + ".y, " + t + ".z\n" + "mul " + t + ".y, " + t + ".y, " + t + ".z\n" + "add " + t + ".w, " + t + ".w, " + t + ".y\n" + "sat " + t + ".w, " + t + ".w\n";
            };
            return DiffuseCelMethod;
        })(materials.DiffuseCompositeMethod);
        materials.DiffuseCelMethod = DiffuseCelMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * DiffuseDepthMethod provides a debug method to visualise depth maps
        */
        var DiffuseDepthMethod = (function (_super) {
            __extends(DiffuseDepthMethod, _super);
            /**
            * Creates a new DiffuseBasicMethod object.
            */
            function DiffuseDepthMethod() {
                _super.call(this);
            }
            /**
            * @inheritDoc
            */
            DiffuseDepthMethod.prototype.iInitConstants = function (vo) {
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index] = 1.0;
                data[index + 1] = 1 / 255.0;
                data[index + 2] = 1 / 65025.0;
                data[index + 3] = 1 / 16581375.0;
            };

            /**
            * @inheritDoc
            */
            DiffuseDepthMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code = "";
                var temp;
                var decReg;

                if (!this._pUseTexture)
                    throw new Error("DiffuseDepthMethod requires texture!");

                // incorporate input from ambient
                if (vo.numLights > 0) {
                    if (this._pShadowRegister)
                        code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + this._pShadowRegister + ".w\n";
                    code += "add " + targetReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + targetReg + ".xyz\n" + "sat " + targetReg + ".xyz, " + targetReg + ".xyz\n";
                    regCache.removeFragmentTempUsage(this._pTotalLightColorReg);
                }

                temp = vo.numLights > 0 ? regCache.getFreeFragmentVectorTemp() : targetReg;

                this._pDiffuseInputRegister = regCache.getFreeTextureReg();
                vo.texturesIndex = this._pDiffuseInputRegister.index;
                decReg = regCache.getFreeFragmentConstant();
                vo.fragmentConstantsIndex = decReg.index * 4;
                code += this.pGetTex2DSampleCode(vo, temp, this._pDiffuseInputRegister, this.texture) + "dp4 " + temp + ".x, " + temp + ", " + decReg + "\n" + "mov " + temp + ".yz, " + temp + ".xx			\n" + "mov " + temp + ".w, " + decReg + ".x\n" + "sub " + temp + ".xyz, " + decReg + ".xxx, " + temp + ".xyz\n";

                if (vo.numLights == 0)
                    return code;

                code += "mul " + targetReg + ".xyz, " + temp + ".xyz, " + targetReg + ".xyz\n" + "mov " + targetReg + ".w, " + temp + ".w\n";

                return code;
            };
            return DiffuseDepthMethod;
        })(materials.DiffuseBasicMethod);
        materials.DiffuseDepthMethod = DiffuseDepthMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient
        * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude
        * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate
        * scattered light within the skin attributing to the final colour)
        */
        var DiffuseGradientMethod = (function (_super) {
            __extends(DiffuseGradientMethod, _super);
            /**
            * Creates a new DiffuseGradientMethod object.
            * @param gradient A texture that contains the light colour based on the angle. This can be used to change
            * the light colour due to subsurface scattering when the surface faces away from the light.
            */
            function DiffuseGradientMethod(gradient) {
                _super.call(this);

                this._gradient = gradient;
            }
            Object.defineProperty(DiffuseGradientMethod.prototype, "gradient", {
                /**
                * A texture that contains the light colour based on the angle. This can be used to change the light colour
                * due to subsurface scattering when the surface faces away from the light.
                */
                get: function () {
                    return this._gradient;
                },
                set: function (value) {
                    if (value.hasMipmaps != this._gradient.hasMipmaps || value.format != this._gradient.format)
                        this.iInvalidateShaderProgram();
                    this._gradient = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DiffuseGradientMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._gradientTextureRegister = null;
            };

            /**
            * @inheritDoc
            */
            DiffuseGradientMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                var code = _super.prototype.iGetFragmentPreLightingCode.call(this, vo, regCache);
                this._pIsFirstLight = true;

                if (vo.numLights > 0) {
                    this._gradientTextureRegister = regCache.getFreeTextureReg();
                    vo.secondaryTexturesIndex = this._gradientTextureRegister.index;
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseGradientMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                // write in temporary if not first light, so we can add to total diffuse colour
                if (this._pIsFirstLight)
                    t = this._pTotalLightColorReg;
                else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                code += "dp3 " + t + ".w, " + lightDirReg + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz\n" + "mul " + t + ".w, " + t + ".w, " + this._sharedRegisters.commons + ".x\n" + "add " + t + ".w, " + t + ".w, " + this._sharedRegisters.commons + ".x\n" + "mul " + t + ".xyz, " + t + ".w, " + lightDirReg + ".w\n";

                if (this._iModulateMethod != null)
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);

                code += this.pGetTex2DSampleCode(vo, t, this._gradientTextureRegister, this._gradient, t, "clamp") + "mul " + t + ".xyz, " + t + ".xyz, " + lightColReg + ".xyz\n";

                if (!this._pIsFirstLight) {
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseGradientMethod.prototype.pApplyShadow = function (vo, regCache) {
                var t = regCache.getFreeFragmentVectorTemp();

                return "mov " + t + ", " + this._pShadowRegister + ".wwww\n" + this.pGetTex2DSampleCode(vo, t, this._gradientTextureRegister, this._gradient, t, "clamp") + "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
            };

            /**
            * @inheritDoc
            */
            DiffuseGradientMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                this._gradient.activateTextureForStage(vo.secondaryTexturesIndex, stageGL);
            };
            return DiffuseGradientMethod;
        })(materials.DiffuseBasicMethod);
        materials.DiffuseGradientMethod = DiffuseGradientMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse
        * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather
        * than only the diffuse lighting value.
        */
        var DiffuseLightMapMethod = (function (_super) {
            __extends(DiffuseLightMapMethod, _super);
            /**
            * Creates a new DiffuseLightMapMethod method.
            *
            * @param lightMap The texture containing the light map.
            * @param blendMode The blend mode with which the light map should be applied to the lighting result.
            * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.
            * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.
            */
            function DiffuseLightMapMethod(lightMap, blendMode, useSecondaryUV, baseMethod) {
                if (typeof blendMode === "undefined") { blendMode = "multiply"; }
                if (typeof useSecondaryUV === "undefined") { useSecondaryUV = false; }
                if (typeof baseMethod === "undefined") { baseMethod = null; }
                _super.call(this, null, baseMethod);

                this._useSecondaryUV = useSecondaryUV;
                this._lightMapTexture = lightMap;
                this.blendMode = blendMode;
            }
            /**
            * @inheritDoc
            */
            DiffuseLightMapMethod.prototype.iInitVO = function (vo) {
                vo.needsSecondaryUV = this._useSecondaryUV;
                vo.needsUV = !this._useSecondaryUV;
            };

            Object.defineProperty(DiffuseLightMapMethod.prototype, "blendMode", {
                /**
                * The blend mode with which the light map should be applied to the lighting result.
                *
                * @see DiffuseLightMapMethod.ADD
                * @see DiffuseLightMapMethod.MULTIPLY
                */
                get: function () {
                    return this._blendMode;
                },
                set: function (value) {
                    if (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)
                        throw new Error("Unknown blendmode!");
                    if (this._blendMode == value)
                        return;
                    this._blendMode = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseLightMapMethod.prototype, "lightMapTexture", {
                /**
                * The texture containing the light map data.
                */
                get: function () {
                    return this._lightMapTexture;
                },
                set: function (value) {
                    this._lightMapTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DiffuseLightMapMethod.prototype.iActivate = function (vo, stageGL) {
                this._lightMapTexture.activateTextureForStage(vo.secondaryTexturesIndex, stageGL);
                _super.prototype.iActivate.call(this, vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            DiffuseLightMapMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code;
                var lightMapReg = regCache.getFreeTextureReg();
                var temp = regCache.getFreeFragmentVectorTemp();
                vo.secondaryTexturesIndex = lightMapReg.index;

                code = this.pGetTex2DSampleCode(vo, temp, lightMapReg, this._lightMapTexture, this._sharedRegisters.secondaryUVVarying);

                switch (this._blendMode) {
                    case DiffuseLightMapMethod.MULTIPLY:
                        code += "mul " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + ", " + temp + "\n";
                        break;
                    case DiffuseLightMapMethod.ADD:
                        code += "add " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + ", " + temp + "\n";
                        break;
                }

                code += _super.prototype.iGetFragmentPostLightingCode.call(this, vo, regCache, targetReg);

                return code;
            };
            DiffuseLightMapMethod.MULTIPLY = "multiply";

            DiffuseLightMapMethod.ADD = "add";
            return DiffuseLightMapMethod;
        })(materials.DiffuseCompositeMethod);
        materials.DiffuseLightMapMethod = DiffuseLightMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of
        * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.
        * It can be used for candle wax, ice, skin, ...
        */
        var DiffuseSubSurfaceMethod = (function (_super) {
            __extends(DiffuseSubSurfaceMethod, _super);
            /**
            * Creates a new <code>DiffuseSubSurfaceMethod</code> object.
            *
            * @param depthMapSize The size of the depth map used.
            * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.
            * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.
            */
            function DiffuseSubSurfaceMethod(depthMapSize, depthMapOffset, baseMethod) {
                if (typeof depthMapSize === "undefined") { depthMapSize = 512; }
                if (typeof depthMapOffset === "undefined") { depthMapOffset = 15; }
                if (typeof baseMethod === "undefined") { baseMethod = null; }
                var _this = this;
                _super.call(this, null, baseMethod);
                this._translucency = 1;
                this._scatterColor = 0xffffff;
                this._scatterR = 1.0;
                this._scatterG = 1.0;
                this._scatterB = 1.0;

                this.pBaseMethod._iModulateMethod = function (vo, target, regCache, sharedRegisters) {
                    return _this.scatterLight(vo, target, regCache, sharedRegisters);
                };

                this._passes = new Array();
                this._depthPass = new materials.SingleObjectDepthPass(depthMapSize, depthMapOffset);
                this._passes.push(this._depthPass);
                this._scattering = 0.2;
                this._translucency = 1;
            }
            /**
            * @inheritDoc
            */
            DiffuseSubSurfaceMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);
                var data = vo.vertexData;
                var index = vo.secondaryVertexConstantsIndex;
                data[index] = .5;
                data[index + 1] = -.5;
                data[index + 2] = 0;
                data[index + 3] = 1;

                data = vo.fragmentData;
                index = vo.secondaryFragmentConstantsIndex;
                data[index + 3] = 1.0;
                data[index + 4] = 1.0;
                data[index + 5] = 1 / 255;
                data[index + 6] = 1 / 65025;
                data[index + 7] = 1 / 16581375;
                data[index + 10] = .5;
                data[index + 11] = -.1;
            };

            DiffuseSubSurfaceMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);

                this._lightProjVarying = null;
                this._propReg = null;
                this._lightColorReg = null;
                this._colorReg = null;
                this._decReg = null;
                this._targetReg = null;
            };

            Object.defineProperty(DiffuseSubSurfaceMethod.prototype, "scattering", {
                /**
                * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low
                * values for skin.
                */
                get: function () {
                    return this._scattering;
                },
                set: function (value) {
                    this._scattering = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseSubSurfaceMethod.prototype, "translucency", {
                /**
                * The translucency of the object.
                */
                get: function () {
                    return this._translucency;
                },
                set: function (value) {
                    this._translucency = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DiffuseSubSurfaceMethod.prototype, "scatterColor", {
                /**
                * The colour of the "insides" of the object, ie: the colour the light becomes after leaving the object.
                */
                get: function () {
                    return this._scatterColor;
                },
                set: function (scatterColor /*uint*/ ) {
                    this._scatterColor = scatterColor;
                    this._scatterR = ((scatterColor >> 16) & 0xff) / 0xff;
                    this._scatterG = ((scatterColor >> 8) & 0xff) / 0xff;
                    this._scatterB = (scatterColor & 0xff) / 0xff;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DiffuseSubSurfaceMethod.prototype.iGetVertexCode = function (vo, regCache) {
                var code = _super.prototype.iGetVertexCode.call(this, vo, regCache);
                var lightProjection;
                var toTexRegister;
                var temp = regCache.getFreeVertexVectorTemp();

                toTexRegister = regCache.getFreeVertexConstant();
                vo.secondaryVertexConstantsIndex = toTexRegister.index * 4;

                this._lightProjVarying = regCache.getFreeVarying();
                lightProjection = regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();

                code += "m44 " + temp + ", vt0, " + lightProjection + "\n" + "div " + temp + ".xyz, " + temp + ".xyz, " + temp + ".w\n" + "mul " + temp + ".xy, " + temp + ".xy, " + toTexRegister + ".xy\n" + "add " + temp + ".xy, " + temp + ".xy, " + toTexRegister + ".xx\n" + "mov " + this._lightProjVarying + ".xyz, " + temp + ".xyz\n" + "mov " + this._lightProjVarying + ".w, va0.w\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseSubSurfaceMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                this._colorReg = regCache.getFreeFragmentConstant();
                this._decReg = regCache.getFreeFragmentConstant();
                this._propReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = this._colorReg.index * 4;

                return _super.prototype.iGetFragmentPreLightingCode.call(this, vo, regCache);
            };

            /**
            * @inheritDoc
            */
            DiffuseSubSurfaceMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                this._pIsFirstLight = true;
                this._lightColorReg = lightColReg;
                return _super.prototype.iGetFragmentCodePerLight.call(this, vo, lightDirReg, lightColReg, regCache);
            };

            /**
            * @inheritDoc
            */
            DiffuseSubSurfaceMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code = _super.prototype.iGetFragmentPostLightingCode.call(this, vo, regCache, targetReg);
                var temp = regCache.getFreeFragmentVectorTemp();

                code += "mul " + temp + ".xyz, " + this._lightColorReg + ".xyz, " + this._targetReg + ".w\n" + "mul " + temp + ".xyz, " + temp + ".xyz, " + this._colorReg + ".xyz\n" + "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";

                if (this._targetReg != this._sharedRegisters.viewDirFragment)
                    regCache.removeFragmentTempUsage(targetReg);

                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseSubSurfaceMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);

                var index = vo.secondaryFragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = this._scatterR;
                data[index + 1] = this._scatterG;
                data[index + 2] = this._scatterB;
                data[index + 8] = this._scattering;
                data[index + 9] = this._translucency;
            };

            /**
            * @inheritDoc
            */
            DiffuseSubSurfaceMethod.prototype.setRenderState = function (vo, renderable, stageGL, camera) {
                var depthMap = this._depthPass._iGetDepthMap(renderable);
                var projection = this._depthPass._iGetProjection(renderable);

                depthMap.activateTextureForStage(vo.secondaryTexturesIndex, stageGL);
                projection.copyRawDataTo(vo.vertexData, vo.secondaryVertexConstantsIndex + 4, true);
            };

            /**
            * Generates the code for this method
            */
            DiffuseSubSurfaceMethod.prototype.scatterLight = function (vo, targetReg, regCache, sharedRegisters) {
                // only scatter first light
                if (!this._pIsFirstLight)
                    return "";

                this._pIsFirstLight = false;

                var code = "";
                var depthReg = regCache.getFreeTextureReg();

                if (sharedRegisters.viewDirFragment) {
                    this._targetReg = sharedRegisters.viewDirFragment;
                } else {
                    this._targetReg = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(this._targetReg, 1);
                }

                vo.secondaryTexturesIndex = depthReg.index;

                var temp = regCache.getFreeFragmentVectorTemp();
                code += "tex " + temp + ", " + this._lightProjVarying + ", " + depthReg + " <2d,nearest,clamp>\n" + "dp4 " + targetReg + ".z, " + temp + ", " + this._decReg + "\n";

                // currentDistanceToLight - closestDistanceToLight
                code += "sub " + targetReg + ".z, " + this._lightProjVarying + ".z, " + targetReg + ".z\n" + "sub " + targetReg + ".z, " + this._propReg + ".x, " + targetReg + ".z\n" + "mul " + targetReg + ".z, " + this._propReg + ".y, " + targetReg + ".z\n" + "sat " + targetReg + ".z, " + targetReg + ".z\n" + "neg " + targetReg + ".y, " + targetReg + ".x\n" + "mul " + targetReg + ".y, " + targetReg + ".y, " + this._propReg + ".z\n" + "add " + targetReg + ".y, " + targetReg + ".y, " + this._propReg + ".z\n" + "mul " + this._targetReg + ".w, " + targetReg + ".z, " + targetReg + ".y\n" + "sub " + targetReg + ".y, " + this._colorReg + ".w, " + this._targetReg + ".w\n" + "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n";

                return code;
            };
            return DiffuseSubSurfaceMethod;
        })(materials.DiffuseCompositeMethod);
        materials.DiffuseSubSurfaceMethod = DiffuseSubSurfaceMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be "wrapped around" the normally dark area, to some extent.
        * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.
        */
        var DiffuseWrapMethod = (function (_super) {
            __extends(DiffuseWrapMethod, _super);
            /**
            * Creates a new DiffuseWrapMethod object.
            * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap
            */
            function DiffuseWrapMethod(wrapFactor) {
                if (typeof wrapFactor === "undefined") { wrapFactor = .5; }
                _super.call(this);

                this.wrapFactor = wrapFactor;
            }
            /**
            * @inheritDoc
            */
            DiffuseWrapMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);

                this._wrapDataRegister = null;
            };

            Object.defineProperty(DiffuseWrapMethod.prototype, "wrapFactor", {
                /**
                * A factor to indicate the amount by which the light is allowed to wrap.
                */
                get: function () {
                    return this._wrapFactor;
                },
                set: function (value) {
                    this._wrapFactor = value;
                    this._wrapFactor = 1 / (value + 1);
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DiffuseWrapMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                var code = _super.prototype.iGetFragmentPreLightingCode.call(this, vo, regCache);
                this._pIsFirstLight = true;
                this._wrapDataRegister = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = this._wrapDataRegister.index * 4;

                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseWrapMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                // write in temporary if not first light, so we can add to total diffuse colour
                if (this._pIsFirstLight) {
                    t = this._pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                code += "dp3 " + t + ".x, " + lightDirReg + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz\n" + "add " + t + ".y, " + t + ".x, " + this._wrapDataRegister + ".x\n" + "mul " + t + ".y, " + t + ".y, " + this._wrapDataRegister + ".y\n" + "sat " + t + ".w, " + t + ".y\n" + "mul " + t + ".xz, " + t + ".w, " + lightDirReg + ".wz\n";

                if (this._iModulateMethod != null)
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);

                code += "mul " + t + ", " + t + ".x, " + lightColReg + "\n";

                if (!this._pIsFirstLight) {
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            DiffuseWrapMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var index = vo.secondaryFragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = this._wrapFactor;
                data[index + 1] = 1 / (this._wrapFactor + 1);
            };
            return DiffuseWrapMethod;
        })(materials.DiffuseBasicMethod);
        materials.DiffuseWrapMethod = DiffuseWrapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,
        * and are in essence post-process effects on the materials.
        */
        var EffectMethodBase = (function (_super) {
            __extends(EffectMethodBase, _super);
            function EffectMethodBase() {
                _super.call(this);
            }
            Object.defineProperty(EffectMethodBase.prototype, "assetType", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return away.library.AssetType.EFFECTS_METHOD;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register that will be containing the method's output.
            * @private
            */
            EffectMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };
            return EffectMethodBase;
        })(materials.ShadingMethodBase);
        materials.EffectMethodBase = EffectMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used
        * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water
        * etc).
        */
        var EffectAlphaMaskMethod = (function (_super) {
            __extends(EffectAlphaMaskMethod, _super);
            /**
            * Creates a new EffectAlphaMaskMethod object.
            *
            * @param texture The texture to use as the alpha mask.
            * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.
            */
            function EffectAlphaMaskMethod(texture, useSecondaryUV) {
                if (typeof useSecondaryUV === "undefined") { useSecondaryUV = false; }
                _super.call(this);

                this._texture = texture;
                this._useSecondaryUV = useSecondaryUV;
            }
            /**
            * @inheritDoc
            */
            EffectAlphaMaskMethod.prototype.iInitVO = function (vo) {
                vo.needsSecondaryUV = this._useSecondaryUV;
                vo.needsUV = !this._useSecondaryUV;
            };

            Object.defineProperty(EffectAlphaMaskMethod.prototype, "useSecondaryUV", {
                /**
                * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for
                * instance to tile the main texture and normal map while providing untiled alpha, for example to define the
                * transparency over a tiled water surface.
                */
                get: function () {
                    return this._useSecondaryUV;
                },
                set: function (value) {
                    if (this._useSecondaryUV == value)
                        return;
                    this._useSecondaryUV = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectAlphaMaskMethod.prototype, "texture", {
                /**
                * The texture to use as the alpha mask.
                */
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectAlphaMaskMethod.prototype.iActivate = function (vo, stageGL) {
                this._texture.activateTextureForStage(vo.texturesIndex, stageGL);
            };

            /**
            * @inheritDoc
            */
            EffectAlphaMaskMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var textureReg = regCache.getFreeTextureReg();
                var temp = regCache.getFreeFragmentVectorTemp();
                var uvReg = this._useSecondaryUV ? this._sharedRegisters.secondaryUVVarying : this._sharedRegisters.uvVarying;
                vo.texturesIndex = textureReg.index;

                return this.pGetTex2DSampleCode(vo, temp, textureReg, this._texture, uvReg) + "mul " + targetReg + ", " + targetReg + ", " + temp + ".x\n";
            };
            return EffectAlphaMaskMethod;
        })(materials.EffectMethodBase);
        materials.EffectAlphaMaskMethod = EffectAlphaMaskMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.
        */
        var EffectColorMatrixMethod = (function (_super) {
            __extends(EffectColorMatrixMethod, _super);
            /**
            * Creates a new EffectColorTransformMethod.
            *
            * @param matrix An array of 20 items for 4 x 5 color transform.
            */
            function EffectColorMatrixMethod(matrix) {
                _super.call(this);

                if (matrix.length != 20)
                    throw new Error("Matrix length must be 20!");

                this._matrix = matrix;
            }
            Object.defineProperty(EffectColorMatrixMethod.prototype, "colorMatrix", {
                /**
                * The 4 x 5 matrix to transform the color of the material.
                */
                get: function () {
                    return this._matrix;
                },
                set: function (value) {
                    this._matrix = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectColorMatrixMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = "";
                var colorMultReg = regCache.getFreeFragmentConstant();
                regCache.getFreeFragmentConstant();
                regCache.getFreeFragmentConstant();
                regCache.getFreeFragmentConstant();

                var colorOffsetReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = colorMultReg.index * 4;

                var temp = regCache.getFreeFragmentVectorTemp();

                code += "m44 " + temp + ", " + targetReg + ", " + colorMultReg + "\n" + "add " + targetReg + ", " + temp + ", " + colorOffsetReg + "\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            EffectColorMatrixMethod.prototype.iActivate = function (vo, stageGL) {
                var matrix = this._matrix;
                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;

                // r
                data[index] = matrix[0];
                data[index + 1] = matrix[1];
                data[index + 2] = matrix[2];
                data[index + 3] = matrix[3];

                // g
                data[index + 4] = matrix[5];
                data[index + 5] = matrix[6];
                data[index + 6] = matrix[7];
                data[index + 7] = matrix[8];

                // b
                data[index + 8] = matrix[10];
                data[index + 9] = matrix[11];
                data[index + 10] = matrix[12];
                data[index + 11] = matrix[13];

                // a
                data[index + 12] = matrix[15];
                data[index + 13] = matrix[16];
                data[index + 14] = matrix[17];
                data[index + 15] = matrix[18];

                // rgba offset
                data[index + 16] = matrix[4];
                data[index + 17] = matrix[9];
                data[index + 18] = matrix[14];
                data[index + 19] = matrix[19];
            };
            return EffectColorMatrixMethod;
        })(materials.EffectMethodBase);
        materials.EffectColorMatrixMethod = EffectColorMatrixMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away.arcane;
        //import away.base.StageGL;
        //import away.materials.compilation.ShaderRegisterCache;
        //import away.materials.compilation.ShaderRegisterElement;
        //import flash.geom.ColorTransform;
        //use namespace arcane;
        /**
        * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a
        * ColorTransform object.
        */
        var EffectColorTransformMethod = (function (_super) {
            __extends(EffectColorTransformMethod, _super);
            /**
            * Creates a new EffectColorTransformMethod.
            */
            function EffectColorTransformMethod() {
                _super.call(this);
            }
            Object.defineProperty(EffectColorTransformMethod.prototype, "colorTransform", {
                /**
                * The ColorTransform object to transform the colour of the material with.
                */
                get: function () {
                    return this._colorTransform;
                },
                set: function (value) {
                    this._colorTransform = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectColorTransformMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = "";
                var colorMultReg = regCache.getFreeFragmentConstant();
                var colorOffsReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = colorMultReg.index * 4;

                //TODO: AGAL <> GLSL
                code += "mul " + targetReg + ", " + targetReg + ", " + colorMultReg + "\n" + "add " + targetReg + ", " + targetReg + ", " + colorOffsReg + "\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            EffectColorTransformMethod.prototype.iActivate = function (vo, stageGL) {
                var inv = 1 / 0xff;
                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;

                data[index] = this._colorTransform.redMultiplier;
                data[index + 1] = this._colorTransform.greenMultiplier;
                data[index + 2] = this._colorTransform.blueMultiplier;
                data[index + 3] = this._colorTransform.alphaMultiplier;
                data[index + 4] = this._colorTransform.redOffset * inv;
                data[index + 5] = this._colorTransform.greenOffset * inv;
                data[index + 6] = this._colorTransform.blueOffset * inv;
                data[index + 7] = this._colorTransform.alphaOffset * inv;
            };
            return EffectColorTransformMethod;
        })(materials.EffectMethodBase);
        materials.EffectColorTransformMethod = EffectColorTransformMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.
        */
        var EffectEnvMapMethod = (function (_super) {
            __extends(EffectEnvMapMethod, _super);
            /**
            * Creates an EffectEnvMapMethod object.
            * @param envMap The environment map containing the reflected scene.
            * @param alpha The reflectivity of the surface.
            */
            function EffectEnvMapMethod(envMap, alpha) {
                if (typeof alpha === "undefined") { alpha = 1; }
                _super.call(this);
                this._cubeTexture = envMap;
                this._alpha = alpha;
            }
            Object.defineProperty(EffectEnvMapMethod.prototype, "mask", {
                /**
                * An optional texture to modulate the reflectivity of the surface.
                */
                get: function () {
                    return this._mask;
                },
                set: function (value) {
                    if (value != this._mask || (value && this._mask && (value.hasMipmaps != this._mask.hasMipmaps || value.format != this._mask.format)))
                        this.iInvalidateShaderProgram();

                    /*
                    if (Boolean(value) != Boolean(_mask) ||
                    (value && _mask && (value.hasMipmaps != _mask.hasMipmaps || value.format != _mask.format))) {
                    iInvalidateShaderProgram();
                    }
                    */
                    this._mask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectEnvMapMethod.prototype.iInitVO = function (vo) {
                vo.needsNormals = true;
                vo.needsView = true;
                vo.needsUV = this._mask != null;
            };

            Object.defineProperty(EffectEnvMapMethod.prototype, "envMap", {
                /**
                * The cubic environment map containing the reflected scene.
                */
                get: function () {
                    return this._cubeTexture;
                },
                set: function (value) {
                    this._cubeTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectEnvMapMethod.prototype.dispose = function () {
            };

            Object.defineProperty(EffectEnvMapMethod.prototype, "alpha", {
                /**
                * The reflectivity of the surface.
                */
                get: function () {
                    return this._alpha;
                },
                set: function (value) {
                    this._alpha = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectEnvMapMethod.prototype.iActivate = function (vo, stageGL) {
                vo.fragmentData[vo.fragmentConstantsIndex] = this._alpha;

                this._cubeTexture.activateTextureForStage(vo.texturesIndex, stageGL);
                if (this._mask)
                    this._mask.activateTextureForStage(vo.texturesIndex + 1, stageGL);
            };

            /**
            * @inheritDoc
            */
            EffectEnvMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var dataRegister = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentVectorTemp();
                var code = "";
                var cubeMapReg = regCache.getFreeTextureReg();

                vo.texturesIndex = cubeMapReg.index;
                vo.fragmentConstantsIndex = dataRegister.index * 4;

                regCache.addFragmentTempUsages(temp, 1);
                var temp2 = regCache.getFreeFragmentVectorTemp();

                // r = I - 2(I.N)*N
                code += "dp3 " + temp + ".w, " + this._sharedRegisters.viewDirFragment + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz		\n" + "add " + temp + ".w, " + temp + ".w, " + temp + ".w											\n" + "mul " + temp + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz, " + temp + ".w						\n" + "sub " + temp + ".xyz, " + temp + ".xyz, " + this._sharedRegisters.viewDirFragment + ".xyz					\n" + this.pGetTexCubeSampleCode(vo, temp, cubeMapReg, this._cubeTexture, temp) + "sub " + temp2 + ".w, " + temp + ".w, fc0.x									\n" + "kil " + temp2 + ".w\n" + "sub " + temp + ", " + temp + ", " + targetReg + "											\n";

                if (this._mask) {
                    var maskReg = regCache.getFreeTextureReg();
                    code += this.pGetTex2DSampleCode(vo, temp2, maskReg, this._mask, this._sharedRegisters.uvVarying) + "mul " + temp + ", " + temp2 + ", " + temp + "\n";
                }
                code += "mul " + temp + ", " + temp + ", " + dataRegister + ".x										\n" + "add " + targetReg + ", " + targetReg + ", " + temp + "										\n";

                regCache.removeFragmentTempUsage(temp);

                return code;
            };
            return EffectEnvMapMethod;
        })(materials.EffectMethodBase);
        materials.EffectEnvMapMethod = EffectEnvMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectFogMethod provides a method to add distance-based fog to a material.
        */
        var EffectFogMethod = (function (_super) {
            __extends(EffectFogMethod, _super);
            /**
            * Creates a new EffectFogMethod object.
            * @param minDistance The distance from which the fog starts appearing.
            * @param maxDistance The distance at which the fog is densest.
            * @param fogColor The colour of the fog.
            */
            function EffectFogMethod(minDistance, maxDistance, fogColor) {
                if (typeof fogColor === "undefined") { fogColor = 0x808080; }
                _super.call(this);
                this._minDistance = 0;
                this._maxDistance = 1000;
                this.minDistance = minDistance;
                this.maxDistance = maxDistance;
                this.fogColor = fogColor;
            }
            /**
            * @inheritDoc
            */
            EffectFogMethod.prototype.iInitVO = function (vo) {
                vo.needsProjection = true;
            };

            /**
            * @inheritDoc
            */
            EffectFogMethod.prototype.iInitConstants = function (vo) {
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index + 3] = 1;
                data[index + 6] = 0;
                data[index + 7] = 0;
            };

            Object.defineProperty(EffectFogMethod.prototype, "minDistance", {
                /**
                * The distance from which the fog starts appearing.
                */
                get: function () {
                    return this._minDistance;
                },
                set: function (value) {
                    this._minDistance = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectFogMethod.prototype, "maxDistance", {
                /**
                * The distance at which the fog is densest.
                */
                get: function () {
                    return this._maxDistance;
                },
                set: function (value) {
                    this._maxDistance = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectFogMethod.prototype, "fogColor", {
                /**
                * The colour of the fog.
                */
                get: function () {
                    return this._fogColor;
                },
                set: function (value /*uint*/ ) {
                    this._fogColor = value;
                    this._fogR = ((value >> 16) & 0xff) / 0xff;
                    this._fogG = ((value >> 8) & 0xff) / 0xff;
                    this._fogB = (value & 0xff) / 0xff;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectFogMethod.prototype.iActivate = function (vo, stageGL) {
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index] = this._fogR;
                data[index + 1] = this._fogG;
                data[index + 2] = this._fogB;
                data[index + 4] = this._minDistance;
                data[index + 5] = 1 / (this._maxDistance - this._minDistance);
            };

            /**
            * @inheritDoc
            */
            EffectFogMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var fogColor = regCache.getFreeFragmentConstant();
                var fogData = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(temp, 1);
                var temp2 = regCache.getFreeFragmentVectorTemp();
                var code = "";
                vo.fragmentConstantsIndex = fogColor.index * 4;

                code += "sub " + temp2 + ".w, " + this._sharedRegisters.projectionFragment + ".z, " + fogData + ".x          \n" + "mul " + temp2 + ".w, " + temp2 + ".w, " + fogData + ".y					\n" + "sat " + temp2 + ".w, " + temp2 + ".w										\n" + "sub " + temp + ", " + fogColor + ", " + targetReg + "\n" + "mul " + temp + ", " + temp + ", " + temp2 + ".w					\n" + "add " + targetReg + ", " + targetReg + ", " + temp + "\n"; // fogRatio*(fogColor- col) + col

                regCache.removeFragmentTempUsage(temp);

                return code;
            };
            return EffectFogMethod;
        })(materials.EffectMethodBase);
        materials.EffectFogMethod = EffectFogMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets
        * stronger as the viewing angle becomes more grazing.
        */
        var EffectFresnelEnvMapMethod = (function (_super) {
            __extends(EffectFresnelEnvMapMethod, _super);
            /**
            * Creates a new <code>EffectFresnelEnvMapMethod</code> object.
            *
            * @param envMap The environment map containing the reflected scene.
            * @param alpha The reflectivity of the material.
            */
            function EffectFresnelEnvMapMethod(envMap, alpha) {
                if (typeof alpha === "undefined") { alpha = 1; }
                _super.call(this);
                this._fresnelPower = 5;
                this._normalReflectance = 0;

                this._cubeTexture = envMap;
                this._alpha = alpha;
            }
            /**
            * @inheritDoc
            */
            EffectFresnelEnvMapMethod.prototype.iInitVO = function (vo) {
                vo.needsNormals = true;
                vo.needsView = true;
                vo.needsUV = this._mask != null;
            };

            /**
            * @inheritDoc
            */
            EffectFresnelEnvMapMethod.prototype.iInitConstants = function (vo) {
                vo.fragmentData[vo.fragmentConstantsIndex + 3] = 1;
            };

            Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "mask", {
                /**
                * An optional texture to modulate the reflectivity of the surface.
                */
                get: function () {
                    return this._mask;
                },
                set: function (value) {
                    if (Boolean(value) != Boolean(this._mask) || (value && this._mask && (value.hasMipmaps != this._mask.hasMipmaps || value.format != this._mask.format))) {
                        this.iInvalidateShaderProgram();
                    }
                    this._mask = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "fresnelPower", {
                /**
                * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
                */
                get: function () {
                    return this._fresnelPower;
                },
                set: function (value) {
                    this._fresnelPower = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "envMap", {
                /**
                * The cubic environment map containing the reflected scene.
                */
                get: function () {
                    return this._cubeTexture;
                },
                set: function (value) {
                    this._cubeTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "alpha", {
                /**
                * The reflectivity of the surface.
                */
                get: function () {
                    return this._alpha;
                },
                set: function (value) {
                    this._alpha = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "normalReflectance", {
                /**
                * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
                */
                get: function () {
                    return this._normalReflectance;
                },
                set: function (value) {
                    this._normalReflectance = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectFresnelEnvMapMethod.prototype.iActivate = function (vo, stageGL) {
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index] = this._alpha;
                data[index + 1] = this._normalReflectance;
                data[index + 2] = this._fresnelPower;
                this._cubeTexture.activateTextureForStage(vo.texturesIndex, stageGL);
                if (this._mask)
                    this._mask.activateTextureForStage(vo.texturesIndex + 1, stageGL);
            };

            /**
            * @inheritDoc
            */
            EffectFresnelEnvMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var dataRegister = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentVectorTemp();
                var code = "";
                var cubeMapReg = regCache.getFreeTextureReg();
                var viewDirReg = this._sharedRegisters.viewDirFragment;
                var normalReg = this._sharedRegisters.normalFragment;

                vo.texturesIndex = cubeMapReg.index;
                vo.fragmentConstantsIndex = dataRegister.index * 4;

                regCache.addFragmentTempUsages(temp, 1);
                var temp2 = regCache.getFreeFragmentVectorTemp();

                // r = V - 2(V.N)*N
                code += "dp3 " + temp + ".w, " + viewDirReg + ".xyz, " + normalReg + ".xyz		\n" + "add " + temp + ".w, " + temp + ".w, " + temp + ".w											\n" + "mul " + temp + ".xyz, " + normalReg + ".xyz, " + temp + ".w						\n" + "sub " + temp + ".xyz, " + temp + ".xyz, " + viewDirReg + ".xyz					\n" + this.pGetTexCubeSampleCode(vo, temp, cubeMapReg, this._cubeTexture, temp) + "sub " + temp2 + ".w, " + temp + ".w, fc0.x									\n" + "kil " + temp2 + ".w\n" + "sub " + temp + ", " + temp + ", " + targetReg + "											\n";

                // calculate fresnel term
                code += "dp3 " + viewDirReg + ".w, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" + "sub " + viewDirReg + ".w, " + dataRegister + ".w, " + viewDirReg + ".w\n" + "pow " + viewDirReg + ".w, " + viewDirReg + ".w, " + dataRegister + ".z\n" + "sub " + normalReg + ".w, " + dataRegister + ".w, " + viewDirReg + ".w\n" + "mul " + normalReg + ".w, " + dataRegister + ".y, " + normalReg + ".w\n" + "add " + viewDirReg + ".w, " + viewDirReg + ".w, " + normalReg + ".w\n" + "mul " + viewDirReg + ".w, " + dataRegister + ".x, " + viewDirReg + ".w\n";

                if (this._mask) {
                    var maskReg = regCache.getFreeTextureReg();
                    code += this.pGetTex2DSampleCode(vo, temp2, maskReg, this._mask, this._sharedRegisters.uvVarying) + "mul " + viewDirReg + ".w, " + temp2 + ".x, " + viewDirReg + ".w\n";
                }

                // blend
                code += "mul " + temp + ", " + temp + ", " + viewDirReg + ".w						\n" + "add " + targetReg + ", " + targetReg + ", " + temp + "						\n";

                regCache.removeFragmentTempUsage(temp);

                return code;
            };
            return EffectFresnelEnvMapMethod;
        })(materials.EffectMethodBase);
        materials.EffectFresnelEnvMapMethod = EffectFresnelEnvMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.
        * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather
        * than the whole pixel colour.
        */
        var EffectLightMapMethod = (function (_super) {
            __extends(EffectLightMapMethod, _super);
            /**
            * Creates a new EffectLightMapMethod object.
            *
            * @param texture The texture containing the light map.
            * @param blendMode The blend mode with which the light map should be applied to the lighting result.
            * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.
            */
            function EffectLightMapMethod(texture, blendMode, useSecondaryUV) {
                if (typeof blendMode === "undefined") { blendMode = "multiply"; }
                if (typeof useSecondaryUV === "undefined") { useSecondaryUV = false; }
                _super.call(this);
                this._useSecondaryUV = useSecondaryUV;
                this._texture = texture;
                this.blendMode = blendMode;
            }
            /**
            * @inheritDoc
            */
            EffectLightMapMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = !this._useSecondaryUV;
                vo.needsSecondaryUV = this._useSecondaryUV;
            };

            Object.defineProperty(EffectLightMapMethod.prototype, "blendMode", {
                /**
                * The blend mode with which the light map should be applied to the lighting result.
                *
                * @see EffectLightMapMethod.ADD
                * @see EffectLightMapMethod.MULTIPLY
                */
                get: function () {
                    return this._blendMode;
                },
                set: function (value) {
                    if (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)
                        throw new Error("Unknown blendmode!");
                    if (this._blendMode == value)
                        return;
                    this._blendMode = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectLightMapMethod.prototype, "texture", {
                /**
                * The texture containing the light map.
                */
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)
                        this.iInvalidateShaderProgram();
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectLightMapMethod.prototype.iActivate = function (vo, stageGL) {
                this._texture.activateTextureForStage(vo.texturesIndex, stageGL);
                _super.prototype.iActivate.call(this, vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            EffectLightMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code;
                var lightMapReg = regCache.getFreeTextureReg();
                var temp = regCache.getFreeFragmentVectorTemp();
                vo.texturesIndex = lightMapReg.index;

                code = this.pGetTex2DSampleCode(vo, temp, lightMapReg, this._texture, this._useSecondaryUV ? this._sharedRegisters.secondaryUVVarying : this._sharedRegisters.uvVarying);

                switch (this._blendMode) {
                    case EffectLightMapMethod.MULTIPLY:
                        code += "mul " + targetReg + ", " + targetReg + ", " + temp + "\n";
                        break;
                    case EffectLightMapMethod.ADD:
                        code += "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
                        break;
                }

                return code;
            };
            EffectLightMapMethod.MULTIPLY = "multiply";

            EffectLightMapMethod.ADD = "add";
            return EffectLightMapMethod;
        })(materials.EffectMethodBase);
        materials.EffectLightMapMethod = EffectLightMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.
        */
        var EffectRefractionEnvMapMethod = (function (_super) {
            __extends(EffectRefractionEnvMapMethod, _super);
            /**
            * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015
            *
            * @param envMap The environment map containing the refracted scene.
            * @param refractionIndex The refractive index of the material.
            * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).
            * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).
            * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).
            */
            function EffectRefractionEnvMapMethod(envMap, refractionIndex, dispersionR, dispersionG, dispersionB) {
                if (typeof refractionIndex === "undefined") { refractionIndex = .1; }
                if (typeof dispersionR === "undefined") { dispersionR = 0; }
                if (typeof dispersionG === "undefined") { dispersionG = 0; }
                if (typeof dispersionB === "undefined") { dispersionB = 0; }
                _super.call(this);
                this._dispersionR = 0;
                this._dispersionG = 0;
                this._dispersionB = 0;
                this._alpha = 1;
                this._envMap = envMap;
                this._dispersionR = dispersionR;
                this._dispersionG = dispersionG;
                this._dispersionB = dispersionB;
                this._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);
                this._refractionIndex = refractionIndex;
            }
            /**
            * @inheritDoc
            */
            EffectRefractionEnvMapMethod.prototype.iInitConstants = function (vo) {
                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index + 4] = 1;
                data[index + 5] = 0;
                data[index + 7] = 1;
            };

            /**
            * @inheritDoc
            */
            EffectRefractionEnvMapMethod.prototype.iInitVO = function (vo) {
                vo.needsNormals = true;
                vo.needsView = true;
            };

            Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "envMap", {
                /**
                * The cube environment map to use for the refraction.
                */
                get: function () {
                    return this._envMap;
                },
                set: function (value) {
                    this._envMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "refractionIndex", {
                /**
                * The refractive index of the material.
                */
                get: function () {
                    return this._refractionIndex;
                },
                set: function (value) {
                    this._refractionIndex = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionR", {
                /**
                * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).
                */
                get: function () {
                    return this._dispersionR;
                },
                set: function (value) {
                    this._dispersionR = value;

                    var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);
                    if (this._useDispersion != useDispersion) {
                        this.iInvalidateShaderProgram();
                        this._useDispersion = useDispersion;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionG", {
                /**
                * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).
                */
                get: function () {
                    return this._dispersionG;
                },
                set: function (value) {
                    this._dispersionG = value;

                    var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);
                    if (this._useDispersion != useDispersion) {
                        this.iInvalidateShaderProgram();
                        this._useDispersion = useDispersion;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionB", {
                /**
                * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).
                */
                get: function () {
                    return this._dispersionB;
                },
                set: function (value) {
                    this._dispersionB = value;

                    var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);
                    if (this._useDispersion != useDispersion) {
                        this.iInvalidateShaderProgram();
                        this._useDispersion = useDispersion;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "alpha", {
                /**
                * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual
                * material. A value of 1 will make it appear fully transparent.
                */
                get: function () {
                    return this._alpha;
                },
                set: function (value) {
                    this._alpha = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectRefractionEnvMapMethod.prototype.iActivate = function (vo, stageGL) {
                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;

                data[index] = this._dispersionR + this._refractionIndex;

                if (this._useDispersion) {
                    data[index + 1] = this._dispersionG + this._refractionIndex;
                    data[index + 2] = this._dispersionB + this._refractionIndex;
                }
                data[index + 3] = this._alpha;

                this._envMap.activateTextureForStage(vo.texturesIndex, stageGL);
            };

            /**
            * @inheritDoc
            */
            EffectRefractionEnvMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                // todo: data2.x could use common reg, so only 1 reg is used
                var data = regCache.getFreeFragmentConstant();
                var data2 = regCache.getFreeFragmentConstant();
                var code = "";
                var cubeMapReg = regCache.getFreeTextureReg();
                var refractionDir;
                var refractionColor;
                var temp;

                vo.texturesIndex = cubeMapReg.index;
                vo.fragmentConstantsIndex = data.index * 4;

                refractionDir = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(refractionDir, 1);
                refractionColor = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(refractionColor, 1);

                temp = regCache.getFreeFragmentVectorTemp();

                var viewDirReg = this._sharedRegisters.viewDirFragment;
                var normalReg = this._sharedRegisters.normalFragment;

                code += "neg " + viewDirReg + ".xyz, " + viewDirReg + ".xyz\n";

                code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" + "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" + "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" + "mul " + temp + ".w, " + data + ".x, " + temp + ".w\n" + "mul " + temp + ".w, " + data + ".x, " + temp + ".w\n" + "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" + "sqt " + temp + ".y, " + temp + ".w\n" + "mul " + temp + ".x, " + data + ".x, " + temp + ".x\n" + "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" + "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" + "mul " + refractionDir + ", " + data + ".x, " + viewDirReg + "\n" + "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" + "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n";

                code += this.pGetTexCubeSampleCode(vo, refractionColor, cubeMapReg, this._envMap, refractionDir) + "sub " + refractionColor + ".w, " + refractionColor + ".w, fc0.x	\n" + "kil " + refractionColor + ".w\n";

                if (this._useDispersion) {
                    // GREEN
                    code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" + "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" + "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" + "mul " + temp + ".w, " + data + ".y, " + temp + ".w\n" + "mul " + temp + ".w, " + data + ".y, " + temp + ".w\n" + "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" + "sqt " + temp + ".y, " + temp + ".w\n" + "mul " + temp + ".x, " + data + ".y, " + temp + ".x\n" + "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" + "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" + "mul " + refractionDir + ", " + data + ".y, " + viewDirReg + "\n" + "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" + "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n";

                    //
                    code += this.pGetTexCubeSampleCode(vo, temp, cubeMapReg, this._envMap, refractionDir) + "mov " + refractionColor + ".y, " + temp + ".y\n";

                    // BLUE
                    code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" + "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" + "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" + "mul " + temp + ".w, " + data + ".z, " + temp + ".w\n" + "mul " + temp + ".w, " + data + ".z, " + temp + ".w\n" + "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" + "sqt " + temp + ".y, " + temp + ".w\n" + "mul " + temp + ".x, " + data + ".z, " + temp + ".x\n" + "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" + "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" + "mul " + refractionDir + ", " + data + ".z, " + viewDirReg + "\n" + "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" + "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n";

                    code += this.pGetTexCubeSampleCode(vo, temp, cubeMapReg, this._envMap, refractionDir) + "mov " + refractionColor + ".z, " + temp + ".z\n";
                }

                regCache.removeFragmentTempUsage(refractionDir);

                code += "sub " + refractionColor + ".xyz, " + refractionColor + ".xyz, " + targetReg + ".xyz\n" + "mul " + refractionColor + ".xyz, " + refractionColor + ".xyz, " + data + ".w\n" + "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + refractionColor + ".xyz\n";
                regCache.removeFragmentTempUsage(refractionColor);

                // restore
                code += "neg " + viewDirReg + ".xyz, " + viewDirReg + ".xyz\n";

                return code;
            };
            return EffectRefractionEnvMapMethod;
        })(materials.EffectMethodBase);
        materials.EffectRefractionEnvMapMethod = EffectRefractionEnvMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.
        */
        var EffectRimLightMethod = (function (_super) {
            __extends(EffectRimLightMethod, _super);
            /**
            * Creates a new <code>EffectRimLightMethod</code> object.
            *
            * @param color The colour of the rim light.
            * @param strength The strength of the rim light.
            * @param power The power of the rim light. Higher values will result in a higher edge fall-off.
            * @param blend The blend mode with which to add the light to the object.
            */
            function EffectRimLightMethod(color, strength, power, blend) {
                if (typeof color === "undefined") { color = 0xffffff; }
                if (typeof strength === "undefined") { strength = .4; }
                if (typeof power === "undefined") { power = 2; }
                if (typeof blend === "undefined") { blend = "mix"; }
                _super.call(this);

                this._blendMode = blend;
                this._strength = strength;
                this._power = power;

                this.color = color;
            }
            /**
            * @inheritDoc
            */
            EffectRimLightMethod.prototype.iInitConstants = function (vo) {
                vo.fragmentData[vo.fragmentConstantsIndex + 3] = 1;
            };

            /**
            * @inheritDoc
            */
            EffectRimLightMethod.prototype.iInitVO = function (vo) {
                vo.needsNormals = true;
                vo.needsView = true;
            };

            Object.defineProperty(EffectRimLightMethod.prototype, "blendMode", {
                /**
                * The blend mode with which to add the light to the object.
                *
                * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.
                * EffectRimLightMethod.ADD adds the rim light with the material's colour.
                * EffectRimLightMethod.MIX provides normal alpha blending.
                */
                get: function () {
                    return this._blendMode;
                },
                set: function (value) {
                    if (this._blendMode == value)
                        return;
                    this._blendMode = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectRimLightMethod.prototype, "color", {
                /**
                * The color of the rim light.
                */
                get: function () {
                    return this._color;
                },
                set: function (value /*uint*/ ) {
                    this._color = value;
                    this._colorR = ((value >> 16) & 0xff) / 0xff;
                    this._colorG = ((value >> 8) & 0xff) / 0xff;
                    this._colorB = (value & 0xff) / 0xff;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectRimLightMethod.prototype, "strength", {
                /**
                * The strength of the rim light.
                */
                get: function () {
                    return this._strength;
                },
                set: function (value) {
                    this._strength = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EffectRimLightMethod.prototype, "power", {
                /**
                * The power of the rim light. Higher values will result in a higher edge fall-off.
                */
                get: function () {
                    return this._power;
                },
                set: function (value) {
                    this._power = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EffectRimLightMethod.prototype.iActivate = function (vo, stageGL) {
                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = this._colorR;
                data[index + 1] = this._colorG;
                data[index + 2] = this._colorB;
                data[index + 4] = this._strength;
                data[index + 5] = this._power;
            };

            /**
            * @inheritDoc
            */
            EffectRimLightMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var dataRegister = regCache.getFreeFragmentConstant();
                var dataRegister2 = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentVectorTemp();
                var code = "";

                vo.fragmentConstantsIndex = dataRegister.index * 4;

                code += "dp3 " + temp + ".x, " + this._sharedRegisters.viewDirFragment + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz	\n" + "sat " + temp + ".x, " + temp + ".x														\n" + "sub " + temp + ".x, " + dataRegister + ".w, " + temp + ".x								\n" + "pow " + temp + ".x, " + temp + ".x, " + dataRegister2 + ".y							\n" + "mul " + temp + ".x, " + temp + ".x, " + dataRegister2 + ".x							\n" + "sub " + temp + ".x, " + dataRegister + ".w, " + temp + ".x								\n" + "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".x						\n" + "sub " + temp + ".w, " + dataRegister + ".w, " + temp + ".x								\n";

                if (this._blendMode == EffectRimLightMethod.ADD) {
                    code += "mul " + temp + ".xyz, " + temp + ".w, " + dataRegister + ".xyz							\n" + "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz						\n";
                } else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {
                    code += "mul " + temp + ".xyz, " + temp + ".w, " + dataRegister + ".xyz							\n" + "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz						\n";
                } else {
                    code += "sub " + temp + ".xyz, " + dataRegister + ".xyz, " + targetReg + ".xyz				\n" + "mul " + temp + ".xyz, " + temp + ".xyz, " + temp + ".w								\n" + "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz					\n";
                }

                return code;
            };
            EffectRimLightMethod.ADD = "add";
            EffectRimLightMethod.MULTIPLY = "multiply";
            EffectRimLightMethod.MIX = "mix";
            return EffectRimLightMethod;
        })(materials.EffectMethodBase);
        materials.EffectRimLightMethod = EffectRimLightMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * NormalBasicMethod is the default method for standard tangent-space normal mapping.
        */
        var NormalBasicMethod = (function (_super) {
            __extends(NormalBasicMethod, _super);
            /**
            * Creates a new NormalBasicMethod object.
            */
            function NormalBasicMethod() {
                _super.call(this);
            }
            /**
            * @inheritDoc
            */
            NormalBasicMethod.prototype.iInitVO = function (vo) {
                if (this._texture) {
                    vo.needsUV = true;
                } else {
                    vo.needsUV = false;
                }
                //vo.needsUV = Boolean(_texture);
            };

            Object.defineProperty(NormalBasicMethod.prototype, "iTangentSpace", {
                /**
                * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.
                */
                get: function () {
                    return true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(NormalBasicMethod.prototype, "iHasOutput", {
                /**
                * Indicates if the normal method output is not based on a texture (if not, it will usually always return true)
                * Override if subclasses are different.
                */
                get: function () {
                    return this._useTexture;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            NormalBasicMethod.prototype.copyFrom = function (method) {
                var s = method;
                var bnm = method;

                if (bnm.normalMap != null)
                    this.normalMap = bnm.normalMap;
            };

            Object.defineProperty(NormalBasicMethod.prototype, "normalMap", {
                /**
                * The texture containing the normals per pixel.
                */
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._useTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format)))
                        this.iInvalidateShaderProgram();

                    this._useTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            NormalBasicMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._pNormalTextureRegister = null;
            };

            /**
            * @inheritDoc
            */
            NormalBasicMethod.prototype.dispose = function () {
                if (this._texture)
                    this._texture = null;
            };

            /**
            * @inheritDoc
            */
            NormalBasicMethod.prototype.iActivate = function (vo, stageGL) {
                if (vo.texturesIndex >= 0) {
                    stageGL.contextGL.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.stagegl.ContextGLWrapMode.REPEAT : away.stagegl.ContextGLWrapMode.CLAMP, vo.useSmoothTextures ? away.stagegl.ContextGLTextureFilter.LINEAR : away.stagegl.ContextGLTextureFilter.NEAREST, vo.useMipmapping ? away.stagegl.ContextGLMipFilter.MIPLINEAR : away.stagegl.ContextGLMipFilter.MIPNONE);
                    this._texture.activateTextureForStage(vo.texturesIndex, stageGL);
                }
            };

            /**
            * @inheritDoc
            */
            NormalBasicMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                this._pNormalTextureRegister = regCache.getFreeTextureReg();

                vo.texturesIndex = this._pNormalTextureRegister.index;

                return this.pGetTex2DSampleCode(vo, targetReg, this._pNormalTextureRegister, this._texture) + "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + this._sharedRegisters.commons + ".xxx\n" + "nrm " + targetReg + ".xyz, " + targetReg + "\n";
            };
            return NormalBasicMethod;
        })(materials.ShadingMethodBase);
        materials.NormalBasicMethod = NormalBasicMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.
        */
        var NormalHeightMapMethod = (function (_super) {
            __extends(NormalHeightMapMethod, _super);
            /**
            * Creates a new NormalHeightMapMethod method.
            *
            * @param heightMap The texture containing the height data. 0 means low, 1 means high.
            * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.
            * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.
            * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.
            */
            function NormalHeightMapMethod(heightMap, worldWidth, worldHeight, worldDepth) {
                _super.call(this);

                this.normalMap = heightMap;
                this._worldXYRatio = worldWidth / worldHeight;
                this._worldXZRatio = worldDepth / worldHeight;
            }
            /**
            * @inheritDoc
            */
            NormalHeightMapMethod.prototype.iInitConstants = function (vo) {
                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = 1 / this.normalMap.width;
                data[index + 1] = 1 / this.normalMap.height;
                data[index + 2] = 0;
                data[index + 3] = 1;
                data[index + 4] = this._worldXYRatio;
                data[index + 5] = this._worldXZRatio;
            };

            Object.defineProperty(NormalHeightMapMethod.prototype, "tangentSpace", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            NormalHeightMapMethod.prototype.copyFrom = function (method) {
                _super.prototype.copyFrom.call(this, method);

                this._worldXYRatio = method._worldXYRatio;
                this._worldXZRatio = method._worldXZRatio;
            };

            /**
            * @inheritDoc
            */
            NormalHeightMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var temp = regCache.getFreeFragmentVectorTemp();
                var dataReg = regCache.getFreeFragmentConstant();
                var dataReg2 = regCache.getFreeFragmentConstant();
                this._pNormalTextureRegister = regCache.getFreeTextureReg();
                vo.texturesIndex = this._pNormalTextureRegister.index;
                vo.fragmentConstantsIndex = dataReg.index * 4;

                return this.pGetTex2DSampleCode(vo, targetReg, this._pNormalTextureRegister, this.normalMap, this._sharedRegisters.uvVarying, "clamp") + "add " + temp + ", " + this._sharedRegisters.uvVarying + ", " + dataReg + ".xzzz\n" + this.pGetTex2DSampleCode(vo, temp, this._pNormalTextureRegister, this.normalMap, temp, "clamp") + "sub " + targetReg + ".x, " + targetReg + ".x, " + temp + ".x\n" + "add " + temp + ", " + this._sharedRegisters.uvVarying + ", " + dataReg + ".zyzz\n" + this.pGetTex2DSampleCode(vo, temp, this._pNormalTextureRegister, this.normalMap, temp, "clamp") + "sub " + targetReg + ".z, " + targetReg + ".z, " + temp + ".x\n" + "mov " + targetReg + ".y, " + dataReg + ".w\n" + "mul " + targetReg + ".xz, " + targetReg + ".xz, " + dataReg2 + ".xy\n" + "nrm " + targetReg + ".xyz, " + targetReg + ".xyz\n";
            };
            return NormalHeightMapMethod;
        })(materials.NormalBasicMethod);
        materials.NormalHeightMapMethod = NormalHeightMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.
        */
        var NormalSimpleWaterMethod = (function (_super) {
            __extends(NormalSimpleWaterMethod, _super);
            /**
            * Creates a new NormalSimpleWaterMethod object.
            * @param waveMap1 A normal map containing one layer of a wave structure.
            * @param waveMap2 A normal map containing a second layer of a wave structure.
            */
            function NormalSimpleWaterMethod(waveMap1, waveMap2) {
                _super.call(this);
                this._useSecondNormalMap = false;
                this._water1OffsetX = 0;
                this._water1OffsetY = 0;
                this._water2OffsetX = 0;
                this._water2OffsetY = 0;
                this.normalMap = waveMap1;
                this.secondaryNormalMap = waveMap2;
            }
            /**
            * @inheritDoc
            */
            NormalSimpleWaterMethod.prototype.iInitConstants = function (vo) {
                var index = vo.fragmentConstantsIndex;
                vo.fragmentData[index] = .5;
                vo.fragmentData[index + 1] = 0;
                vo.fragmentData[index + 2] = 0;
                vo.fragmentData[index + 3] = 1;
            };

            /**
            * @inheritDoc
            */
            NormalSimpleWaterMethod.prototype.iInitVO = function (vo) {
                _super.prototype.iInitVO.call(this, vo);

                this._useSecondNormalMap = this.normalMap != this.secondaryNormalMap;
            };

            Object.defineProperty(NormalSimpleWaterMethod.prototype, "water1OffsetX", {
                /**
                * The translation of the first wave layer along the X-axis.
                */
                get: function () {
                    return this._water1OffsetX;
                },
                set: function (value) {
                    this._water1OffsetX = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NormalSimpleWaterMethod.prototype, "water1OffsetY", {
                /**
                * The translation of the first wave layer along the Y-axis.
                */
                get: function () {
                    return this._water1OffsetY;
                },
                set: function (value) {
                    this._water1OffsetY = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NormalSimpleWaterMethod.prototype, "water2OffsetX", {
                /**
                * The translation of the second wave layer along the X-axis.
                */
                get: function () {
                    return this._water2OffsetX;
                },
                set: function (value) {
                    this._water2OffsetX = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NormalSimpleWaterMethod.prototype, "water2OffsetY", {
                /**
                * The translation of the second wave layer along the Y-axis.
                */
                get: function () {
                    return this._water2OffsetY;
                },
                set: function (value) {
                    this._water2OffsetY = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NormalSimpleWaterMethod.prototype, "secondaryNormalMap", {
                /**
                * A second normal map that will be combined with the first to create a wave-like animation pattern.
                */
                get: function () {
                    return this._texture2;
                },
                set: function (value) {
                    this._texture2 = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            NormalSimpleWaterMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._normalTextureRegister2 = null;
            };

            /**
            * @inheritDoc
            */
            NormalSimpleWaterMethod.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this._texture2 = null;
            };

            /**
            * @inheritDoc
            */
            NormalSimpleWaterMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);

                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;

                data[index + 4] = this._water1OffsetX;
                data[index + 5] = this._water1OffsetY;
                data[index + 6] = this._water2OffsetX;
                data[index + 7] = this._water2OffsetY;

                //if (this._useSecondNormalMap >= 0)
                if (this._useSecondNormalMap)
                    this._texture2.activateTextureForStage(vo.texturesIndex + 1, stageGL);
            };

            /**
            * @inheritDoc
            */
            NormalSimpleWaterMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var temp = regCache.getFreeFragmentVectorTemp();
                var dataReg = regCache.getFreeFragmentConstant();
                var dataReg2 = regCache.getFreeFragmentConstant();
                this._pNormalTextureRegister = regCache.getFreeTextureReg();
                this._normalTextureRegister2 = this._useSecondNormalMap ? regCache.getFreeTextureReg() : this._pNormalTextureRegister;
                vo.texturesIndex = this._pNormalTextureRegister.index;

                vo.fragmentConstantsIndex = dataReg.index * 4;

                return "add " + temp + ", " + this._sharedRegisters.uvVarying + ", " + dataReg2 + ".xyxy\n" + this.pGetTex2DSampleCode(vo, targetReg, this._pNormalTextureRegister, this.normalMap, temp) + "add " + temp + ", " + this._sharedRegisters.uvVarying + ", " + dataReg2 + ".zwzw\n" + this.pGetTex2DSampleCode(vo, temp, this._normalTextureRegister2, this._texture2, temp) + "add " + targetReg + ", " + targetReg + ", " + temp + "		\n" + "mul " + targetReg + ", " + targetReg + ", " + dataReg + ".x	\n" + "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + this._sharedRegisters.commons + ".xxx	\n" + "nrm " + targetReg + ".xyz, " + targetReg + ".xyz							\n";
            };
            return NormalSimpleWaterMethod;
        })(materials.NormalBasicMethod);
        materials.NormalSimpleWaterMethod = NormalSimpleWaterMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.
        */
        var ShadowMethodBase = (function (_super) {
            __extends(ShadowMethodBase, _super);
            /**
            * Creates a new ShadowMethodBase object.
            * @param castingLight The light used to cast shadows.
            */
            function ShadowMethodBase(castingLight) {
                this._pUsePoint = (castingLight instanceof away.lights.PointLight);
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            ShadowMethodBase.prototype.iInitVO = function (vo) {
                vo.needsView = true;
                vo.needsGlobalVertexPos = true;
                vo.needsGlobalFragmentPos = this._pUsePoint;
                vo.needsNormals = vo.numLights > 0;
            };

            /**
            * @inheritDoc
            */
            ShadowMethodBase.prototype.iInitConstants = function (vo) {
                var fragmentData = vo.fragmentData;
                var vertexData = vo.vertexData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index] = 1.0;
                fragmentData[index + 1] = 1 / 255.0;
                fragmentData[index + 2] = 1 / 65025.0;
                fragmentData[index + 3] = 1 / 16581375.0;

                fragmentData[index + 6] = 0;
                fragmentData[index + 7] = 1;

                if (this._pUsePoint) {
                    fragmentData[index + 8] = 0;
                    fragmentData[index + 9] = 0;
                    fragmentData[index + 10] = 0;
                    fragmentData[index + 11] = 1;
                }

                index = vo.vertexConstantsIndex;
                if (index != -1) {
                    vertexData[index] = .5;
                    vertexData[index + 1] = .5;
                    vertexData[index + 2] = 0.0;
                    vertexData[index + 3] = 1.0;
                }
            };

            Object.defineProperty(ShadowMethodBase.prototype, "_iDepthMapCoordReg", {
                /**
                * Wrappers that override the vertex shader need to set this explicitly
                */
                get: function () {
                    return this._pDepthMapCoordReg;
                },
                set: function (value) {
                    this._pDepthMapCoordReg = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowMethodBase.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);

                this._pDepthMapCoordReg = null;
            };

            /**
            * @inheritDoc
            */
            ShadowMethodBase.prototype.iGetVertexCode = function (vo, regCache) {
                return this._pUsePoint ? this._pGetPointVertexCode(vo, regCache) : this.pGetPlanarVertexCode(vo, regCache);
            };

            /**
            * Gets the vertex code for shadow mapping with a point light.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            */
            ShadowMethodBase.prototype._pGetPointVertexCode = function (vo, regCache) {
                vo.vertexConstantsIndex = -1;
                return "";
            };

            /**
            * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            */
            ShadowMethodBase.prototype.pGetPlanarVertexCode = function (vo, regCache) {
                var code = "";
                var temp = regCache.getFreeVertexVectorTemp();
                var dataReg = regCache.getFreeVertexConstant();
                var depthMapProj = regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                this._pDepthMapCoordReg = regCache.getFreeVarying();
                vo.vertexConstantsIndex = dataReg.index * 4;

                // todo: can epsilon be applied here instead of fragment shader?
                code += "m44 " + temp + ", " + this._sharedRegisters.globalPositionVertex + ", " + depthMapProj + "\n" + "div " + temp + ", " + temp + ", " + temp + ".w\n" + "mul " + temp + ".xy, " + temp + ".xy, " + dataReg + ".xy\n" + "add " + this._pDepthMapCoordReg + ", " + temp + ", " + dataReg + ".xxwz\n";

                //"sub " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".w\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            ShadowMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = this._pUsePoint ? this._pGetPointFragmentCode(vo, regCache, targetReg) : this._pGetPlanarFragmentCode(vo, regCache, targetReg);
                code += "add " + targetReg + ".w, " + targetReg + ".w, fc" + (vo.fragmentConstantsIndex / 4 + 1) + ".y\n" + "sat " + targetReg + ".w, " + targetReg + ".w\n";
                return code;
            };

            /**
            * Gets the fragment code for shadow mapping with a planar shadow map.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register to contain the shadow coverage
            * @return
            */
            ShadowMethodBase.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };

            /**
            * Gets the fragment code for shadow mapping with a point light.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register to contain the shadow coverage
            * @return
            */
            ShadowMethodBase.prototype._pGetPointFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };

            /**
            * @inheritDoc
            */
            ShadowMethodBase.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
                if (!this._pUsePoint)
                    this._pShadowMapper.iDepthProjection.copyRawDataTo(vo.vertexData, vo.vertexConstantsIndex + 4, true);
            };

            /**
            * Gets the fragment code for combining this method with a cascaded shadow map method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param decodeRegister The register containing the data to decode the shadow map depth value.
            * @param depthTexture The texture containing the shadow map.
            * @param depthProjection The projection of the fragment relative to the light.
            * @param targetRegister The register to contain the shadow coverage
            * @return
            */
            ShadowMethodBase.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                throw new Error("This shadow method is incompatible with cascade shadows");
            };

            /**
            * @inheritDoc
            */
            ShadowMethodBase.prototype.iActivate = function (vo, stageGL) {
                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;

                if (this._pUsePoint)
                    fragmentData[index + 4] = -Math.pow(1 / (this._pCastingLight.fallOff * this._pEpsilon), 2);
                else
                    vo.vertexData[vo.vertexConstantsIndex + 3] = -1 / (this._pShadowMapper.depth * this._pEpsilon);

                fragmentData[index + 5] = 1 - this._pAlpha;

                if (this._pUsePoint) {
                    var pos = this._pCastingLight.scenePosition;
                    fragmentData[index + 8] = pos.x;
                    fragmentData[index + 9] = pos.y;
                    fragmentData[index + 10] = pos.z;

                    // used to decompress distance
                    var f = this._pCastingLight.fallOff;
                    fragmentData[index + 11] = 1 / (2 * f * f);
                }
                this._pCastingLight.shadowMapper.depthMap.activateTextureForStage(vo.texturesIndex, stageGL);
            };

            /**
            * Sets the method state for cascade shadow mapping.
            */
            ShadowMethodBase.prototype.iActivateForCascade = function (vo, stageGL) {
                throw new Error("This shadow method is incompatible with cascade shadows");
            };
            return ShadowMethodBase;
        })(materials.ShadowMapMethodBase);
        materials.ShadowMethodBase = ShadowMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var ShadingMethodEvent = away.events.ShadingMethodEvent;
        var DirectionalLight = away.lights.DirectionalLight;

        var Event = away.events.Event;

        /**
        * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.
        * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.
        *
        * @see away.lights.CascadeShadowMapper
        */
        var ShadowCascadeMethod = (function (_super) {
            __extends(ShadowCascadeMethod, _super);
            /**
            * Creates a new ShadowCascadeMethod object.
            *
            * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)
            */
            function ShadowCascadeMethod(shadowMethodBase) {
                var _this = this;
                _super.call(this, shadowMethodBase.castingLight);

                this._baseMethod = shadowMethodBase;
                if (!(this._pCastingLight instanceof DirectionalLight))
                    throw new Error("ShadowCascadeMethod is only compatible with DirectionalLight");

                this._cascadeShadowMapper = this._pCastingLight.shadowMapper;

                if (!this._cascadeShadowMapper)
                    throw new Error("ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.");

                this._cascadeShadowMapper.addEventListener(Event.CHANGE, function (event) {
                    return _this.onCascadeChange(event);
                });
                this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, function (event) {
                    return _this.onShaderInvalidated(event);
                });
            }
            Object.defineProperty(ShadowCascadeMethod.prototype, "baseMethod", {
                /**
                * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction
                * with a DirectionalShadowMapper.
                *
                * @see ShadowHardMethod
                * @see ShadowSoftMethod
                */
                get: function () {
                    return this._baseMethod;
                },
                set: function (value) {
                    var _this = this;
                    if (this._baseMethod == value)
                        return;

                    this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, function (event) {
                        return _this.onShaderInvalidated(event);
                    });
                    this._baseMethod = value;
                    this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, function (event) {
                        return _this.onShaderInvalidated(event);
                    });
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowCascadeMethod.prototype.iInitVO = function (vo) {
                var tempVO = new materials.MethodVO();
                this._baseMethod.iInitVO(tempVO);
                vo.needsGlobalVertexPos = true;
                vo.needsProjection = true;
            };

            Object.defineProperty(ShadowCascadeMethod.prototype, "iSharedRegisters", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    this.setISharedRegisters(value);
                    this._baseMethod.iSharedRegisters = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            ShadowCascadeMethod.prototype.iInitConstants = function (vo) {
                var fragmentData = vo.fragmentData;
                var vertexData = vo.vertexData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index] = 1.0;
                fragmentData[index + 1] = 1 / 255.0;
                fragmentData[index + 2] = 1 / 65025.0;
                fragmentData[index + 3] = 1 / 16581375.0;

                fragmentData[index + 6] = .5;
                fragmentData[index + 7] = -.5;

                index = vo.vertexConstantsIndex;
                vertexData[index] = .5;
                vertexData[index + 1] = -.5;
                vertexData[index + 2] = 0;
            };

            /**
            * @inheritDoc
            */
            ShadowCascadeMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._cascadeProjections = null;
                this._depthMapCoordVaryings = null;
            };

            /**
            * @inheritDoc
            */
            ShadowCascadeMethod.prototype.iGetVertexCode = function (vo, regCache) {
                var code = "";
                var dataReg = regCache.getFreeVertexConstant();

                this.initProjectionsRegs(regCache);
                vo.vertexConstantsIndex = dataReg.index * 4;

                var temp = regCache.getFreeVertexVectorTemp();

                for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {
                    code += "m44 " + temp + ", " + this._sharedRegisters.globalPositionVertex + ", " + this._cascadeProjections[i] + "\n" + "add " + this._depthMapCoordVaryings[i] + ", " + temp + ", " + dataReg + ".zzwz\n";
                }

                return code;
            };

            /**
            * Creates the registers for the cascades' projection coordinates.
            */
            ShadowCascadeMethod.prototype.initProjectionsRegs = function (regCache) {
                this._cascadeProjections = new Array(this._cascadeShadowMapper.numCascades);
                this._depthMapCoordVaryings = new Array(this._cascadeShadowMapper.numCascades);

                for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {
                    this._depthMapCoordVaryings[i] = regCache.getFreeVarying();
                    this._cascadeProjections[i] = regCache.getFreeVertexConstant();
                    regCache.getFreeVertexConstant();
                    regCache.getFreeVertexConstant();
                    regCache.getFreeVertexConstant();
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCascadeMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var numCascades = this._cascadeShadowMapper.numCascades;
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();
                var planeDistanceReg = regCache.getFreeFragmentConstant();
                var planeDistances = Array(planeDistanceReg + ".x", planeDistanceReg + ".y", planeDistanceReg + ".z", planeDistanceReg + ".w");
                var code;

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                var inQuad = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(inQuad, 1);
                var uvCoord = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(uvCoord, 1);

                // assume lowest partition is selected, will be overwritten later otherwise
                code = "mov " + uvCoord + ", " + this._depthMapCoordVaryings[numCascades - 1] + "\n";

                for (var i = numCascades - 2; i >= 0; --i) {
                    var uvProjection = this._depthMapCoordVaryings[i];

                    // calculate if in texturemap (result == 0 or 1, only 1 for a single partition)
                    code += "slt " + inQuad + ".z, " + this._sharedRegisters.projectionFragment + ".z, " + planeDistances[i] + "\n"; // z = x > minX, w = y > minY

                    var temp = regCache.getFreeFragmentVectorTemp();

                    // linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)
                    code += "sub " + temp + ", " + uvProjection + ", " + uvCoord + "\n" + "mul " + temp + ", " + temp + ", " + inQuad + ".z\n" + "add " + uvCoord + ", " + uvCoord + ", " + temp + "\n";
                }

                regCache.removeFragmentTempUsage(inQuad);

                code += "div " + uvCoord + ", " + uvCoord + ", " + uvCoord + ".w\n" + "mul " + uvCoord + ".xy, " + uvCoord + ".xy, " + dataReg + ".zw\n" + "add " + uvCoord + ".xy, " + uvCoord + ".xy, " + dataReg + ".zz\n";

                code += this._baseMethod._iGetCascadeFragmentCode(vo, regCache, decReg, depthMapRegister, uvCoord, targetReg) + "add " + targetReg + ".w, " + targetReg + ".w, " + dataReg + ".y\n";

                regCache.removeFragmentTempUsage(uvCoord);

                return code;
            };

            /**
            * @inheritDoc
            */
            ShadowCascadeMethod.prototype.iActivate = function (vo, stageGL) {
                this._pCastingLight.shadowMapper.depthMap.activateTextureForStage(vo.texturesIndex, stageGL);

                var vertexData = vo.vertexData;
                var vertexIndex = vo.vertexConstantsIndex;

                vo.vertexData[vo.vertexConstantsIndex + 3] = -1 / (this._cascadeShadowMapper.depth * this._pEpsilon);

                var numCascades = this._cascadeShadowMapper.numCascades;
                vertexIndex += 4;
                for (var k = 0; k < numCascades; ++k) {
                    this._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);
                    vertexIndex += 16;
                }

                var fragmentData = vo.fragmentData;
                var fragmentIndex = vo.fragmentConstantsIndex;
                fragmentData[fragmentIndex + 5] = 1 - this._pAlpha;

                var nearPlaneDistances = this._cascadeShadowMapper._iNearPlaneDistances;

                fragmentIndex += 8;
                for (var i = 0; i < numCascades; ++i)
                    fragmentData[fragmentIndex + i] = nearPlaneDistances[i];

                this._baseMethod.iActivateForCascade(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            ShadowCascadeMethod.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
            };

            /**
            * Called when the shadow mappers cascade configuration changes.
            */
            ShadowCascadeMethod.prototype.onCascadeChange = function (event) {
                this.iInvalidateShaderProgram();
            };

            /**
            * Called when the base method's shader code is invalidated.
            */
            ShadowCascadeMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return ShadowCascadeMethod;
        })(materials.ShadowMapMethodBase);
        materials.ShadowCascadeMethod = ShadowCascadeMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.
        */
        var ShadowDitheredMethod = (function (_super) {
            __extends(ShadowDitheredMethod, _super);
            /**
            * Creates a new ShadowDitheredMethod object.
            * @param castingLight The light casting the shadows
            * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.
            */
            function ShadowDitheredMethod(castingLight, numSamples, range) {
                if (typeof numSamples === "undefined") { numSamples = 4; }
                if (typeof range === "undefined") { range = 1; }
                _super.call(this, castingLight);

                this._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;

                this.numSamples = numSamples;
                this.range = range;

                ++ShadowDitheredMethod._grainUsages;

                if (!ShadowDitheredMethod._grainTexture)
                    this.initGrainTexture();
            }
            Object.defineProperty(ShadowDitheredMethod.prototype, "numSamples", {
                /**
                * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the
                * complexity of the shader.
                */
                get: function () {
                    return this._numSamples;
                },
                set: function (value /*int*/ ) {
                    this._numSamples = value;
                    if (this._numSamples < 1)
                        this._numSamples = 1;
                    else if (this._numSamples > 24)
                        this._numSamples = 24;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowDitheredMethod.prototype.iInitVO = function (vo) {
                _super.prototype.iInitVO.call(this, vo);
                vo.needsProjection = true;
            };

            /**
            * @inheritDoc
            */
            ShadowDitheredMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index + 8] = 1 / this._numSamples;
            };

            Object.defineProperty(ShadowDitheredMethod.prototype, "range", {
                /**
                * The range in the shadow map in which to distribute the samples.
                */
                get: function () {
                    return this._range * 2;
                },
                set: function (value) {
                    this._range = value / 2;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Creates a texture containing the dithering noise texture.
            */
            ShadowDitheredMethod.prototype.initGrainTexture = function () {
                ShadowDitheredMethod._grainBitmapData = new away.base.BitmapData(64, 64, false);
                var vec = new Array();
                var len = 4096;
                var step = 1 / (this._depthMapSize * this._range);
                var r, g;

                for (var i = 0; i < len; ++i) {
                    r = 2 * (Math.random() - .5);
                    g = 2 * (Math.random() - .5);
                    if (r < 0)
                        r -= step;
                    else
                        r += step;
                    if (g < 0)
                        g -= step;
                    else
                        g += step;
                    if (r > 1)
                        r = 1;
                    else if (r < -1)
                        r = -1;
                    if (g > 1)
                        g = 1;
                    else if (g < -1)
                        g = -1;
                    vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);
                }

                ShadowDitheredMethod._grainBitmapData.setVector(ShadowDitheredMethod._grainBitmapData.rect, vec);
                ShadowDitheredMethod._grainTexture = new away.textures.BitmapTexture(ShadowDitheredMethod._grainBitmapData);
            };

            /**
            * @inheritDoc
            */
            ShadowDitheredMethod.prototype.dispose = function () {
                if (--ShadowDitheredMethod._grainUsages == 0) {
                    ShadowDitheredMethod._grainTexture.dispose();
                    ShadowDitheredMethod._grainBitmapData.dispose();
                    ShadowDitheredMethod._grainTexture = null;
                }
            };

            /**
            * @inheritDoc
            */
            ShadowDitheredMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index + 9] = (stageGL.width - 1) / 63;
                data[index + 10] = (stageGL.height - 1) / 63;
                data[index + 11] = 2 * this._range / this._depthMapSize;
                ShadowDitheredMethod._grainTexture.activateTextureForStage(vo.texturesIndex + 1, stageGL);
            };

            /**
            * @inheritDoc
            */
            ShadowDitheredMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();
                var customDataReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                return this.getSampleCode(regCache, customDataReg, depthMapRegister, decReg, targetReg);
            };

            /**
            * Get the actual shader code for shadow mapping
            * @param regCache The register cache managing the registers.
            * @param depthMapRegister The texture register containing the depth map.
            * @param decReg The register containing the depth map decoding data.
            * @param targetReg The target register to add the shadow coverage.
            */
            ShadowDitheredMethod.prototype.getSampleCode = function (regCache, customDataReg, depthMapRegister, decReg, targetReg) {
                var code = "";
                var grainRegister = regCache.getFreeTextureReg();
                var uvReg = regCache.getFreeFragmentVectorTemp();
                var numSamples = this._numSamples;
                regCache.addFragmentTempUsages(uvReg, 1);

                var temp = regCache.getFreeFragmentVectorTemp();

                var projectionReg = this._sharedRegisters.projectionFragment;

                code += "div " + uvReg + ", " + projectionReg + ", " + projectionReg + ".w\n" + "mul " + uvReg + ".xy, " + uvReg + ".xy, " + customDataReg + ".yz\n";

                while (numSamples > 0) {
                    if (numSamples == this._numSamples)
                        code += "tex " + uvReg + ", " + uvReg + ", " + grainRegister + " <2d,nearest,repeat,mipnone>\n";
                    else
                        code += "tex " + uvReg + ", " + uvReg + ".zwxy, " + grainRegister + " <2d,nearest,repeat,mipnone>\n";

                    // keep grain in uvReg.zw
                    code += "sub " + uvReg + ".zw, " + uvReg + ".xy, fc0.xx\n" + "mul " + uvReg + ".zw, " + uvReg + ".zw, " + customDataReg + ".w\n"; // (tex unpack scale and tex scale in one)

                    // first sample
                    if (numSamples == this._numSamples) {
                        // first sample
                        code += "add " + uvReg + ".xy, " + uvReg + ".zw, " + this._pDepthMapCoordReg + ".xy\n" + "tex " + temp + ", " + uvReg + ", " + depthMapRegister + " <2d,nearest,clamp,mipnone>\n" + "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" + "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n"; // 0 if in shadow
                    } else
                        code += this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);

                    if (numSamples > 4) {
                        code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 1) {
                        code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 5) {
                        code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 2) {
                        code += "neg " + uvReg + ".w, " + uvReg + ".w\n"; // will be rotated 90 degrees when being accessed as wz

                        code += "add " + uvReg + ".xy, " + uvReg + ".wz, " + this._pDepthMapCoordReg + ".xy\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 6) {
                        code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 3) {
                        code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 7) {
                        code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    numSamples -= 8;
                }

                regCache.removeFragmentTempUsage(uvReg);
                code += "mul " + targetReg + ".w, " + targetReg + ".w, " + customDataReg + ".x\n"; // average
                return code;
            };

            /**
            * Adds the code for another tap to the shader code.
            * @param uvReg The uv register for the tap.
            * @param depthMapRegister The texture register containing the depth map.
            * @param decReg The register containing the depth map decoding data.
            * @param targetReg The target register to add the tap comparison result.
            * @param regCache The register cache managing the registers.
            * @return
            */
            ShadowDitheredMethod.prototype.addSample = function (uvReg, depthMapRegister, decReg, targetReg, regCache) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + uvReg + ", " + depthMapRegister + " <2d,nearest,clamp,mipnone>\n" + "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" + "slt " + temp + ".z, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + temp + ".z\n";
            };

            /**
            * @inheritDoc
            */
            ShadowDitheredMethod.prototype.iActivateForCascade = function (vo, stageGL) {
                var data = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                data[index] = 1 / this._numSamples;
                data[index + 1] = (stageGL.width - 1) / 63;
                data[index + 2] = (stageGL.height - 1) / 63;
                data[index + 3] = 2 * this._range / this._depthMapSize;
                ShadowDitheredMethod._grainTexture.activateTextureForStage(vo.texturesIndex + 1, stageGL);
            };

            /**
            * @inheritDoc
            */
            ShadowDitheredMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                this._pDepthMapCoordReg = depthProjection;

                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;

                return this.getSampleCode(regCache, dataReg, depthTexture, decodeRegister, targetRegister);
            };
            return ShadowDitheredMethod;
        })(materials.ShadowMethodBase);
        materials.ShadowDitheredMethod = ShadowDitheredMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison
        * results of neighbouring pixels.
        */
        var ShadowFilteredMethod = (function (_super) {
            __extends(ShadowFilteredMethod, _super);
            /**
            * Creates a new DiffuseBasicMethod object.
            *
            * @param castingLight The light casting the shadow
            */
            function ShadowFilteredMethod(castingLight) {
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            ShadowFilteredMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index + 8] = .5;
                var size = this.castingLight.shadowMapper.depthMapSize;
                fragmentData[index + 9] = size;
                fragmentData[index + 10] = 1 / size;
            };

            /**
            * @inheritDoc
            */
            ShadowFilteredMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();

                // TODO: not used
                dataReg = dataReg;
                var customDataReg = regCache.getFreeFragmentConstant();
                var depthCol = regCache.getFreeFragmentVectorTemp();
                var uvReg;
                var code = "";
                vo.fragmentConstantsIndex = decReg.index * 4;

                regCache.addFragmentTempUsages(depthCol, 1);

                uvReg = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(uvReg, 1);

                code += "mov " + uvReg + ", " + this._pDepthMapCoordReg + "\n" + "tex " + depthCol + ", " + this._pDepthMapCoordReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + targetReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" + "mov " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x\n" + "add " + uvReg + ".y, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + uvReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + targetReg + ".w\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + uvReg + ".w\n";

                regCache.removeFragmentTempUsage(depthCol);
                regCache.removeFragmentTempUsage(uvReg);

                vo.texturesIndex = depthMapRegister.index;

                return code;
            };

            /**
            * @inheritDoc
            */
            ShadowFilteredMethod.prototype.iActivateForCascade = function (vo, stageGL) {
                var size = this.castingLight.shadowMapper.depthMapSize;
                var index = vo.secondaryFragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = size;
                data[index + 1] = 1 / size;
            };

            /**
            * @inheritDoc
            */
            ShadowFilteredMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                var code;
                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;
                var temp = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(temp, 1);
                var predicate = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(predicate, 1);

                code = "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".x, " + depthProjection + ".z, " + temp + ".z\n" + "add " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".z, " + depthProjection + ".z, " + temp + ".z\n" + "add " + depthProjection + ".y, " + depthProjection + ".y, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".w, " + depthProjection + ".z, " + temp + ".z\n" + "sub " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".y, " + depthProjection + ".z, " + temp + ".z\n" + "mul " + temp + ".xy, " + depthProjection + ".xy, " + dataReg + ".x\n" + "frc " + temp + ".xy, " + temp + ".xy\n" + "sub " + depthProjection + ", " + predicate + ".xyzw, " + predicate + ".zwxy\n" + "mul " + depthProjection + ", " + depthProjection + ", " + temp + ".x\n" + "add " + predicate + ".xy, " + predicate + ".xy, " + depthProjection + ".zw\n" + "sub " + predicate + ".y, " + predicate + ".y, " + predicate + ".x\n" + "mul " + predicate + ".y, " + predicate + ".y, " + temp + ".y\n" + "add " + targetRegister + ".w, " + predicate + ".x, " + predicate + ".y\n";

                regCache.removeFragmentTempUsage(temp);
                regCache.removeFragmentTempUsage(predicate);
                return code;
            };
            return ShadowFilteredMethod;
        })(materials.ShadowMethodBase);
        materials.ShadowFilteredMethod = ShadowFilteredMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.
        */
        var ShadowHardMethod = (function (_super) {
            __extends(ShadowHardMethod, _super);
            /**
            * Creates a new ShadowHardMethod object.
            */
            function ShadowHardMethod(castingLight) {
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            ShadowHardMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();

                // needs to be reserved anyway. DO NOT REMOVE
                var dataReg = regCache.getFreeFragmentConstant();

                // TODO not used
                dataReg = dataReg;
                var depthCol = regCache.getFreeFragmentVectorTemp();
                var code = "";

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                code += "tex " + depthCol + ", " + this._pDepthMapCoordReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n"; // 0 if in shadow

                return code;
            };

            /**
            * @inheritDoc
            */
            ShadowHardMethod.prototype._pGetPointFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var epsReg = regCache.getFreeFragmentConstant();
                var posReg = regCache.getFreeFragmentConstant();
                var depthSampleCol = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(depthSampleCol, 1);
                var lightDir = regCache.getFreeFragmentVectorTemp();
                var code = "";

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                code += "sub " + lightDir + ", " + this._sharedRegisters.globalPositionVarying + ", " + posReg + "\n" + "dp3 " + lightDir + ".w, " + lightDir + ".xyz, " + lightDir + ".xyz\n" + "mul " + lightDir + ".w, " + lightDir + ".w, " + posReg + ".w\n" + "nrm " + lightDir + ".xyz, " + lightDir + ".xyz\n" + "tex " + depthSampleCol + ", " + lightDir + ", " + depthMapRegister + " <cube, nearest, clamp>\n" + "dp4 " + depthSampleCol + ".z, " + depthSampleCol + ", " + decReg + "\n" + "add " + targetReg + ".w, " + lightDir + ".w, " + epsReg + ".x\n" + "slt " + targetReg + ".w, " + targetReg + ".w, " + depthSampleCol + ".z\n"; // 0 if in shadow

                regCache.removeFragmentTempUsage(depthSampleCol);

                return code;
            };

            /**
            * @inheritDoc
            */
            ShadowHardMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + targetRegister + ".w, " + depthProjection + ".z, " + temp + ".z\n";
            };

            /**
            * @inheritDoc
            */
            ShadowHardMethod.prototype.iActivateForCascade = function (vo, stageGL) {
            };
            return ShadowHardMethod;
        })(materials.ShadowMethodBase);
        materials.ShadowHardMethod = ShadowHardMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var Delegate = away.utils.Delegate;

        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        // TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work
        /**
        * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize
        * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.
        *
        * @see away.lights.NearDirectionalShadowMapper
        */
        var ShadowNearMethod = (function (_super) {
            __extends(ShadowNearMethod, _super);
            /**
            * Creates a new ShadowNearMethod object.
            * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)
            * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
            */
            function ShadowNearMethod(baseMethod, fadeRatio) {
                if (typeof fadeRatio === "undefined") { fadeRatio = .1; }
                _super.call(this, baseMethod.castingLight);

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                this._baseMethod = baseMethod;
                this._fadeRatio = fadeRatio;
                this._nearShadowMapper = this._pCastingLight.shadowMapper;
                if (!this._nearShadowMapper)
                    throw new Error("ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.");
                this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            }
            Object.defineProperty(ShadowNearMethod.prototype, "baseMethod", {
                /**
                * The base shadow map method on which this method's shading is based.
                */
                get: function () {
                    return this._baseMethod;
                },
                set: function (value) {
                    if (this._baseMethod == value)
                        return;
                    this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this._baseMethod = value;
                    this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);
                this._baseMethod.iInitConstants(vo);

                var fragmentData = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                fragmentData[index + 2] = 0;
                fragmentData[index + 3] = 1;
            };

            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iInitVO = function (vo) {
                this._baseMethod.iInitVO(vo);
                vo.needsProjection = true;
            };

            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.dispose = function () {
                this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            };

            Object.defineProperty(ShadowNearMethod.prototype, "alpha", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this._baseMethod.alpha;
                },
                set: function (value) {
                    this._baseMethod.alpha = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowNearMethod.prototype, "epsilon", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this._baseMethod.epsilon;
                },
                set: function (value) {
                    this._baseMethod.epsilon = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowNearMethod.prototype, "fadeRatio", {
                /**
                * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
                */
                get: function () {
                    return this._fadeRatio;
                },
                set: function (value) {
                    this._fadeRatio = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = this._baseMethod.iGetFragmentCode(vo, regCache, targetReg);
                var dataReg = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentSingleTemp();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;

                code += "abs " + temp + ", " + this._sharedRegisters.projectionFragment + ".w\n" + "sub " + temp + ", " + temp + ", " + dataReg + ".x\n" + "mul " + temp + ", " + temp + ", " + dataReg + ".y\n" + "sat " + temp + ", " + temp + "\n" + "sub " + temp + ", " + dataReg + ".w," + temp + "\n" + "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n" + "mul " + targetReg + ".w, " + targetReg + ".w, " + temp + "\n" + "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iActivate = function (vo, stageGL) {
                this._baseMethod.iActivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iDeactivate = function (vo, stageGL) {
                this._baseMethod.iDeactivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iSetRenderState = function (vo, renderable, stageGL, camera) {
                // todo: move this to activate (needs camera)
                var near = camera.projection.near;
                var d = camera.projection.far - near;
                var maxDistance = this._nearShadowMapper.coverageRatio;
                var minDistance = maxDistance * (1 - this._fadeRatio);

                maxDistance = near + maxDistance * d;
                minDistance = near + minDistance * d;

                var fragmentData = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                fragmentData[index] = minDistance;
                fragmentData[index + 1] = 1 / (maxDistance - minDistance);
                this._baseMethod.iSetRenderState(vo, renderable, stageGL, camera);
            };

            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iGetVertexCode = function (vo, regCache) {
                return this._baseMethod.iGetVertexCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iReset = function () {
                this._baseMethod.iReset();
            };

            /**
            * @inheritDoc
            */
            ShadowNearMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._baseMethod.iCleanCompilationData();
            };

            Object.defineProperty(ShadowNearMethod.prototype, "iSharedRegisters", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    this._sharedRegisters = this._baseMethod.iSharedRegisters = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called when the base method's shader code is invalidated.
            */
            ShadowNearMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return ShadowNearMethod;
        })(materials.ShadowMethodBase);
        materials.ShadowNearMethod = ShadowNearMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.
        */
        var ShadowSoftMethod = (function (_super) {
            __extends(ShadowSoftMethod, _super);
            /**
            * Creates a new DiffuseBasicMethod object.
            *
            * @param castingLight The light casting the shadows
            * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.
            */
            function ShadowSoftMethod(castingLight, numSamples, range) {
                if (typeof numSamples === "undefined") { numSamples = 5; }
                if (typeof range === "undefined") { range = 1; }
                _super.call(this, castingLight);
                this._range = 1;

                this.numSamples = numSamples;
                this.range = range;
            }
            Object.defineProperty(ShadowSoftMethod.prototype, "numSamples", {
                /**
                * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the
                * complexity of the shader.
                */
                get: function () {
                    return this._numSamples;
                },
                set: function (value /*int*/ ) {
                    this._numSamples = value;
                    if (this._numSamples < 1)
                        this._numSamples = 1;
                    else if (this._numSamples > 32)
                        this._numSamples = 32;

                    this._offsets = away.geom.PoissonLookup.getDistribution(this._numSamples);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowSoftMethod.prototype, "range", {
                /**
                * The range in the shadow map in which to distribute the samples.
                */
                get: function () {
                    return this._range;
                },
                set: function (value) {
                    this._range = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowSoftMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                vo.fragmentData[vo.fragmentConstantsIndex + 8] = 1 / this._numSamples;
                vo.fragmentData[vo.fragmentConstantsIndex + 9] = 0;
            };

            /**
            * @inheritDoc
            */
            ShadowSoftMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var texRange = .5 * this._range / this._pCastingLight.shadowMapper.depthMapSize;
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex + 10;
                var len = this._numSamples << 1;

                for (var i = 0; i < len; ++i)
                    data[index + i] = this._offsets[i] * texRange;
            };

            /**
            * @inheritDoc
            */
            ShadowSoftMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                // todo: move some things to super
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();
                var customDataReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                return this.getSampleCode(regCache, depthMapRegister, decReg, targetReg, customDataReg);
            };

            /**
            * Adds the code for another tap to the shader code.
            * @param uv The uv register for the tap.
            * @param texture The texture register containing the depth map.
            * @param decode The register containing the depth map decoding data.
            * @param target The target register to add the tap comparison result.
            * @param regCache The register cache managing the registers.
            * @return
            */
            ShadowSoftMethod.prototype.addSample = function (uv, texture, decode, target, regCache) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + uv + ", " + texture + " <2d,nearest,clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decode + "\n" + "slt " + uv + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" + "add " + target + ".w, " + target + ".w, " + uv + ".w\n";
            };

            /**
            * @inheritDoc
            */
            ShadowSoftMethod.prototype.iActivateForCascade = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var texRange = this._range / this._pCastingLight.shadowMapper.depthMapSize;
                var data = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                var len = this._numSamples << 1;
                data[index] = 1 / this._numSamples;
                data[index + 1] = 0;
                index += 2;
                for (var i = 0; i < len; ++i)
                    data[index + i] = this._offsets[i] * texRange;

                if (len % 4 == 0) {
                    data[index + len] = 0;
                    data[index + len + 1] = 0;
                }
            };

            /**
            * @inheritDoc
            */
            ShadowSoftMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                this._pDepthMapCoordReg = depthProjection;

                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;

                return this.getSampleCode(regCache, depthTexture, decodeRegister, targetRegister, dataReg);
            };

            /**
            * Get the actual shader code for shadow mapping
            * @param regCache The register cache managing the registers.
            * @param depthTexture The texture register containing the depth map.
            * @param decodeRegister The register containing the depth map decoding data.
            * @param targetReg The target register to add the shadow coverage.
            * @param dataReg The register containing additional data.
            */
            ShadowSoftMethod.prototype.getSampleCode = function (regCache, depthTexture, decodeRegister, targetRegister, dataReg) {
                var uvReg;
                var code;
                var offsets = new Array(dataReg + ".zw");
                uvReg = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(uvReg, 1);

                var temp = regCache.getFreeFragmentVectorTemp();

                var numRegs = this._numSamples >> 1;
                for (var i = 0; i < numRegs; ++i) {
                    var reg = regCache.getFreeFragmentConstant();
                    offsets.push(reg + ".xy");
                    offsets.push(reg + ".zw");
                }

                for (i = 0; i < this._numSamples; ++i) {
                    if (i == 0) {
                        code = "add " + uvReg + ", " + this._pDepthMapCoordReg + ", " + dataReg + ".zwyy\n";
                        code += "tex " + temp + ", " + uvReg + ", " + depthTexture + " <2d,nearest,clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + targetRegister + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n"; // 0 if in shadow;
                    } else {
                        code += "add " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + offsets[i] + "\n";
                        code += this.addSample(uvReg, depthTexture, decodeRegister, targetRegister, regCache);
                    }
                }

                regCache.removeFragmentTempUsage(uvReg);
                code += "mul " + targetRegister + ".w, " + targetRegister + ".w, " + dataReg + ".x\n"; // average
                return code;
            };
            return ShadowSoftMethod;
        })(materials.ShadowMethodBase);
        materials.ShadowSoftMethod = ShadowSoftMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away.*;
        //import away.managers.*;
        //import away.materials.compilation.*;
        //import away.textures.*;
        //use namespace arcane;
        /**
        * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated
        * version of Phong specularity).
        */
        var SpecularBasicMethod = (function (_super) {
            __extends(SpecularBasicMethod, _super);
            /**
            * Creates a new SpecularBasicMethod object.
            */
            function SpecularBasicMethod() {
                _super.call(this);
                this._gloss = 50;
                this._specular = 1;
                this._specularColor = 0xffffff;
                this._iSpecularR = 1;
                this._iSpecularG = 1;
                this._iSpecularB = 1;
            }
            /**
            * @inheritDoc
            */
            SpecularBasicMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._pUseTexture;
                vo.needsNormals = vo.numLights > 0;
                vo.needsView = vo.numLights > 0;
            };

            Object.defineProperty(SpecularBasicMethod.prototype, "gloss", {
                /**
                * The sharpness of the specular highlight.
                */
                get: function () {
                    return this._gloss;
                },
                set: function (value) {
                    this._gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SpecularBasicMethod.prototype, "specular", {
                /**
                * The overall strength of the specular highlights.
                */
                get: function () {
                    return this._specular;
                },
                set: function (value) {
                    if (value == this._specular)
                        return;

                    this._specular = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SpecularBasicMethod.prototype, "specularColor", {
                /**
                * The colour of the specular reflection of the surface.
                */
                get: function () {
                    return this._specularColor;
                },
                set: function (value) {
                    if (this._specularColor == value)
                        return;

                    // specular is now either enabled or disabled
                    if (this._specularColor == 0 || value == 0)
                        this.iInvalidateShaderProgram();

                    this._specularColor = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SpecularBasicMethod.prototype, "texture", {
                /**
                * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness
                * in the green channel. You can use SpecularBitmapTexture if you want to easily set specular and gloss maps
                * from grayscale images, but prepared images are preferred.
                */
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._pUseTexture || (value && this._texture && (value.hasMipmaps != this._texture.hasMipmaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }
                    this._pUseTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SpecularBasicMethod.prototype.copyFrom = function (method) {
                var m = method;
                var bsm = method;

                var spec = bsm;
                this.texture = spec.texture;
                this.specular = spec.specular;
                this.specularColor = spec.specularColor;
                this.gloss = spec.gloss;
            };

            /**
            * @inheritDoc
            */
            SpecularBasicMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._shadowRegister = null;
                this._pTotalLightColorReg = null;
                this._pSpecularTextureRegister = null;
                this._pSpecularTexData = null;
                this._pSpecularDataRegister = null;
            };

            /**
            * @inheritDoc
            */
            SpecularBasicMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                var code = "";

                this._pIsFirstLight = true;

                if (vo.numLights > 0) {
                    this._pSpecularDataRegister = regCache.getFreeFragmentConstant();
                    vo.fragmentConstantsIndex = this._pSpecularDataRegister.index * 4;

                    if (this._pUseTexture) {
                        this._pSpecularTexData = regCache.getFreeFragmentVectorTemp();
                        regCache.addFragmentTempUsages(this._pSpecularTexData, 1);
                        this._pSpecularTextureRegister = regCache.getFreeTextureReg();
                        vo.texturesIndex = this._pSpecularTextureRegister.index;
                        code = this.pGetTex2DSampleCode(vo, this._pSpecularTexData, this._pSpecularTextureRegister, this._texture);
                    } else {
                        this._pSpecularTextureRegister = null;
                    }

                    this._pTotalLightColorReg = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            SpecularBasicMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                if (this._pIsFirstLight) {
                    t = this._pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                var viewDirReg = this._sharedRegisters.viewDirFragment;
                var normalReg = this._sharedRegisters.normalFragment;

                // blinn-phong half vector model
                //TODO: AGAL <> GLSL
                code += "add " + t + ", " + lightDirReg + ", " + viewDirReg + "\n" + "nrm " + t + ".xyz, " + t + "\n" + "dp3 " + t + ".w, " + normalReg + ", " + t + "\n" + "sat " + t + ".w, " + t + ".w\n";

                if (this._pUseTexture) {
                    //TODO: AGAL <> GLSL
                    // apply gloss modulation from texture
                    code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" + "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
                } else {
                    //TODO: AGAL <> GLSL
                    code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
                }

                // attenuate
                if (vo.useLightFallOff) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
                }

                if (this._iModulateMethod != null)
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);

                //TODO: AGAL <> GLSL
                code += "mul " + t + ".xyz, " + lightColReg + ", " + t + ".w\n";

                if (!this._pIsFirstLight) {
                    //TODO: AGAL <> GLSL
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";

                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            SpecularBasicMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = "";
                var t;

                // write in temporary if not first light, so we can add to total diffuse colour
                if (this._pIsFirstLight) {
                    t = this._pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                var normalReg = this._sharedRegisters.normalFragment;
                var viewDirReg = this._sharedRegisters.viewDirFragment;

                //TODO: AGAL <> GLSL
                code += "dp3 " + t + ".w, " + normalReg + ", " + viewDirReg + "\n" + "add " + t + ".w, " + t + ".w, " + t + ".w\n" + "mul " + t + ", " + t + ".w, " + normalReg + "\n" + "sub " + t + ", " + t + ", " + viewDirReg + "\n" + "tex " + t + ", " + t + ", " + cubeMapReg + " <cube," + (vo.useSmoothTextures ? "linear" : "nearest") + ",miplinear>\n" + "mul " + t + ".xyz, " + t + ", " + weightRegister + "\n";

                if (this._iModulateMethod != null)
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);

                /*
                if (this._iModulateMethod!= null)
                {
                
                //TODO: AGAL <> GLSL
                code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);
                
                }
                */
                if (!this._pIsFirstLight) {
                    //TODO: AGAL <> GLSL
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";

                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            SpecularBasicMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code = "";

                if (vo.numLights == 0)
                    return code;

                if (this._shadowRegister) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._shadowRegister + ".w\n";
                }

                if (this._pUseTexture) {
                    // apply strength modulation from texture
                    //TODO: AGAL <> GLSL
                    code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularTexData + ".x\n";

                    regCache.removeFragmentTempUsage(this._pSpecularTexData);
                }

                // apply material's specular reflection
                //TODO: AGAL <> GLSL
                code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularDataRegister + "\n" + "add " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n";

                regCache.removeFragmentTempUsage(this._pTotalLightColorReg);

                return code;
            };

            /**
            * @inheritDoc
            */
            SpecularBasicMethod.prototype.iActivate = function (vo, stageGL) {
                //var context:ContextGL = stageGL._contextGL;
                if (vo.numLights == 0)
                    return;

                if (this._pUseTexture) {
                    stageGL.contextGL.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.stagegl.ContextGLWrapMode.REPEAT : away.stagegl.ContextGLWrapMode.CLAMP, vo.useSmoothTextures ? away.stagegl.ContextGLTextureFilter.LINEAR : away.stagegl.ContextGLTextureFilter.NEAREST, vo.useMipmapping ? away.stagegl.ContextGLMipFilter.MIPLINEAR : away.stagegl.ContextGLMipFilter.MIPNONE);
                    this._texture.activateTextureForStage(vo.texturesIndex, stageGL);
                }

                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = this._iSpecularR;
                data[index + 1] = this._iSpecularG;
                data[index + 2] = this._iSpecularB;
                data[index + 3] = this._gloss;
            };

            /**
            * Updates the specular color data used by the render state.
            */
            SpecularBasicMethod.prototype.updateSpecular = function () {
                this._iSpecularR = ((this._specularColor >> 16) & 0xff) / 0xff * this._specular;
                this._iSpecularG = ((this._specularColor >> 8) & 0xff) / 0xff * this._specular;
                this._iSpecularB = (this._specularColor & 0xff) / 0xff * this._specular;
            };

            Object.defineProperty(SpecularBasicMethod.prototype, "iShadowRegister", {
                /**
                * Set internally by the compiler, so the method knows the register containing the shadow calculation.
                */
                set: function (shadowReg) {
                    this._shadowRegister = shadowReg;
                },
                enumerable: true,
                configurable: true
            });

            SpecularBasicMethod.prototype.setIShadowRegister = function (shadowReg) {
                this._shadowRegister = shadowReg;
            };
            return SpecularBasicMethod;
        })(materials.LightingMethodBase);
        materials.SpecularBasicMethod = SpecularBasicMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var Delegate = away.utils.Delegate;

        var ShadingMethodEvent = away.events.ShadingMethodEvent;

        /**
        * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the
        * calculated specular reflection strength.
        */
        var SpecularCompositeMethod = (function (_super) {
            __extends(SpecularCompositeMethod, _super);
            /**
            * Creates a new <code>SpecularCompositeMethod</code> object.
            *
            * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.
            * @param baseMethod The base specular method on which this method's shading is based.
            */
            function SpecularCompositeMethod(modulateMethod, baseMethod) {
                if (typeof baseMethod === "undefined") { baseMethod = null; }
                _super.call(this);

                this._onShaderInvalidatedDelegate = Delegate.create(this, this.onShaderInvalidated);

                this._baseMethod = baseMethod || new materials.SpecularBasicMethod();
                this._baseMethod._iModulateMethod = modulateMethod;
                this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            }
            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iInitVO = function (vo) {
                this._baseMethod.iInitVO(vo);
            };

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iInitConstants = function (vo) {
                this._baseMethod.iInitConstants(vo);
            };

            Object.defineProperty(SpecularCompositeMethod.prototype, "baseMethod", {
                /**
                * The base specular method on which this method's shading is based.
                */
                get: function () {
                    return this._baseMethod;
                },
                set: function (value) {
                    if (this._baseMethod == value)
                        return;

                    this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this._baseMethod = value;
                    this._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SpecularCompositeMethod.prototype, "gloss", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this._baseMethod.gloss;
                },
                set: function (value) {
                    this._baseMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SpecularCompositeMethod.prototype, "specular", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this._baseMethod.specular;
                },
                set: function (value) {
                    this._baseMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SpecularCompositeMethod.prototype, "passes", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this._baseMethod.passes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.dispose = function () {
                this._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
                this._baseMethod.dispose();
            };

            Object.defineProperty(SpecularCompositeMethod.prototype, "texture", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this._baseMethod.texture;
                },
                set: function (value) {
                    this._baseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iActivate = function (vo, stageGL) {
                this._baseMethod.iActivate(vo, stageGL);
            };

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iDeactivate = function (vo, stageGL) {
                this._baseMethod.iDeactivate(vo, stageGL);
            };

            Object.defineProperty(SpecularCompositeMethod.prototype, "iSharedRegisters", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    _super.prototype.setISharedRegisters.call(this, value);
                    this._baseMethod.setISharedRegisters(value);
                },
                enumerable: true,
                configurable: true
            });

            SpecularCompositeMethod.prototype.setISharedRegisters = function (value) {
                _super.prototype.setISharedRegisters.call(this, value);
                this._baseMethod.setISharedRegisters(value);
            };

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iGetVertexCode = function (vo, regCache) {
                return this._baseMethod.iGetVertexCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return this._baseMethod.iGetFragmentPreLightingCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                return this._baseMethod.iGetFragmentCodePerLight(vo, lightDirReg, lightColReg, regCache);
            };

            /**
            * @inheritDoc
            * @return
            */
            SpecularCompositeMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                return this._baseMethod.iGetFragmentCodePerProbe(vo, cubeMapReg, weightRegister, regCache);
            };

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return this._baseMethod.iGetFragmentPostLightingCode(vo, regCache, targetReg);
            };

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iReset = function () {
                this._baseMethod.iReset();
            };

            /**
            * @inheritDoc
            */
            SpecularCompositeMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._baseMethod.iCleanCompilationData();
            };

            Object.defineProperty(SpecularCompositeMethod.prototype, "iShadowRegister", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    this.setIShadowRegister(value);
                    this._baseMethod.setIShadowRegister(value);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called when the base method's shader code is invalidated.
            */
            SpecularCompositeMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return SpecularCompositeMethod;
        })(materials.SpecularBasicMethod);
        materials.SpecularCompositeMethod = SpecularCompositeMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    /**
    *
    */
    (function (materials) {
        /**
        * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for
        * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.
        * The tangent vectors are used as the surface groove directions.
        */
        var SpecularAnisotropicMethod = (function (_super) {
            __extends(SpecularAnisotropicMethod, _super);
            /**
            * Creates a new SpecularAnisotropicMethod object.
            */
            function SpecularAnisotropicMethod() {
                _super.call(this);
            }
            /**
            * @inheritDoc
            */
            SpecularAnisotropicMethod.prototype.iInitVO = function (vo) {
                vo.needsTangents = true;
                vo.needsView = true;
            };

            /**
            * @inheritDoc
            */
            SpecularAnisotropicMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                if (this._pIsFirstLight)
                    t = this._pTotalLightColorReg;
                else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                // (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k
                code += "nrm " + t + ".xyz, " + this._sharedRegisters.tangentVarying + ".xyz\n" + "dp3 " + t + ".w, " + t + ".xyz, " + lightDirReg + ".xyz\n" + "dp3 " + t + ".z, " + t + ".xyz, " + this._sharedRegisters.viewDirFragment + ".xyz\n";

                // (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k
                code += "sin " + t + ".x, " + t + ".w\n" + "sin " + t + ".y, " + t + ".z\n" + "mul " + t + ".x, " + t + ".x, " + t + ".y\n" + "cos " + t + ".z, " + t + ".z\n" + "cos " + t + ".w, " + t + ".w\n" + "mul " + t + ".w, " + t + ".w, " + t + ".z\n" + "sub " + t + ".w, " + t + ".x, " + t + ".w\n";

                if (this._pUseTexture) {
                    // apply gloss modulation from texture
                    code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" + "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
                } else
                    code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";

                // attenuate
                code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";

                if (this._iModulateMethod != null)
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);

                code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";

                if (!this._pIsFirstLight) {
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };
            return SpecularAnisotropicMethod;
        })(materials.SpecularBasicMethod);
        materials.SpecularAnisotropicMethod = SpecularAnisotropicMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.
        */
        var SpecularCelMethod = (function (_super) {
            __extends(SpecularCelMethod, _super);
            /**
            * Creates a new SpecularCelMethod object.
            * @param specularCutOff The threshold at which the specular highlight should be shown.
            * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.
            */
            function SpecularCelMethod(specularCutOff, baseMethod) {
                if (typeof specularCutOff === "undefined") { specularCutOff = .5; }
                if (typeof baseMethod === "undefined") { baseMethod = null; }
                var _this = this;
                _super.call(this, null, baseMethod);
                this._smoothness = .1;
                this._specularCutOff = .1;

                this.baseMethod._iModulateMethod = function (vo, target, regCache, sharedRegisters) {
                    return _this.clampSpecular(vo, target, regCache, sharedRegisters);
                };

                this._specularCutOff = specularCutOff;
            }
            Object.defineProperty(SpecularCelMethod.prototype, "smoothness", {
                /**
                * The smoothness of the highlight edge.
                */
                get: function () {
                    return this._smoothness;
                },
                set: function (value) {
                    this._smoothness = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SpecularCelMethod.prototype, "specularCutOff", {
                /**
                * The threshold at which the specular highlight should be shown.
                */
                get: function () {
                    return this._specularCutOff;
                },
                set: function (value) {
                    this._specularCutOff = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SpecularCelMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var index = vo.secondaryFragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = this._smoothness;
                data[index + 1] = this._specularCutOff;
            };

            /**
            * @inheritDoc
            */
            SpecularCelMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._dataReg = null;
            };

            /**
            * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff
            * @param vo The MethodVO used to compile the current shader.
            * @param t The register containing the specular strength in the "w" component, and either the half-vector or the reflection vector in "xyz".
            * @param regCache The register cache used for the shader compilation.
            * @param sharedRegisters The shared register data for this shader.
            * @return The AGAL fragment code for the method.
            */
            SpecularCelMethod.prototype.clampSpecular = function (methodVO, target, regCache, sharedRegisters) {
                methodVO = methodVO;
                regCache = regCache;
                sharedRegisters = sharedRegisters;
                return "sub " + target + ".y, " + target + ".w, " + this._dataReg + ".y\n" + "div " + target + ".y, " + target + ".y, " + this._dataReg + ".x\n" + "sat " + target + ".y, " + target + ".y\n" + "sge " + target + ".w, " + target + ".w, " + this._dataReg + ".y\n" + "mul " + target + ".w, " + target + ".w, " + target + ".y\n";
            };

            /**
            * @inheritDoc
            */
            SpecularCelMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                this._dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
                return _super.prototype.iGetFragmentPreLightingCode.call(this, vo, regCache);
            };
            return SpecularCelMethod;
        })(materials.SpecularCompositeMethod);
        materials.SpecularCelMethod = SpecularCelMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.
        */
        var SpecularFresnelMethod = (function (_super) {
            __extends(SpecularFresnelMethod, _super);
            /**
            * Creates a new SpecularFresnelMethod object.
            * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
            * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.
            */
            function SpecularFresnelMethod(basedOnSurface, baseMethod) {
                if (typeof basedOnSurface === "undefined") { basedOnSurface = true; }
                if (typeof baseMethod === "undefined") { baseMethod = null; }
                var _this = this;
                // may want to offer diff speculars
                _super.call(this, null, baseMethod);
                this._fresnelPower = 5;
                this._normalReflectance = .028;

                this.baseMethod._iModulateMethod = function (vo, target, regCache, sharedRegisters) {
                    return _this.modulateSpecular(vo, target, regCache, sharedRegisters);
                };

                this._incidentLight = !basedOnSurface;
            }
            /**
            * @inheritDoc
            */
            SpecularFresnelMethod.prototype.iInitConstants = function (vo) {
                var index = vo.secondaryFragmentConstantsIndex;
                vo.fragmentData[index + 2] = 1;
                vo.fragmentData[index + 3] = 0;
            };

            Object.defineProperty(SpecularFresnelMethod.prototype, "basedOnSurface", {
                /**
                * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
                */
                get: function () {
                    return !this._incidentLight;
                },
                set: function (value) {
                    if (this._incidentLight != value)
                        return;

                    this._incidentLight = !value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SpecularFresnelMethod.prototype, "fresnelPower", {
                /**
                * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
                */
                get: function () {
                    return this._fresnelPower;
                },
                set: function (value) {
                    this._fresnelPower = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SpecularFresnelMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._dataReg = null;
            };

            Object.defineProperty(SpecularFresnelMethod.prototype, "normalReflectance", {
                /**
                * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
                */
                get: function () {
                    return this._normalReflectance;
                },
                set: function (value) {
                    this._normalReflectance = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SpecularFresnelMethod.prototype.iActivate = function (vo, stageGL) {
                _super.prototype.iActivate.call(this, vo, stageGL);
                var fragmentData = vo.fragmentData;

                var index = vo.secondaryFragmentConstantsIndex;
                fragmentData[index] = this._normalReflectance;
                fragmentData[index + 1] = this._fresnelPower;
            };

            /**
            * @inheritDoc
            */
            SpecularFresnelMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                this._dataReg = regCache.getFreeFragmentConstant();

                console.log('SpecularFresnelMethod', 'iGetFragmentPreLightingCode', this._dataReg);

                vo.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
                return _super.prototype.iGetFragmentPreLightingCode.call(this, vo, regCache);
            };

            /**
            * Applies the fresnel effect to the specular strength.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param target The register containing the specular strength in the "w" component, and the half-vector/reflection vector in "xyz".
            * @param regCache The register cache used for the shader compilation.
            * @param sharedRegisters The shared registers created by the compiler.
            * @return The AGAL fragment code for the method.
            */
            SpecularFresnelMethod.prototype.modulateSpecular = function (vo, target, regCache, sharedRegisters) {
                var code;

                code = "dp3 " + target + ".y, " + sharedRegisters.viewDirFragment + ".xyz, " + (this._incidentLight ? target + ".xyz\n" : sharedRegisters.normalFragment + ".xyz\n") + "sub " + target + ".y, " + this._dataReg + ".z, " + target + ".y\n" + "pow " + target + ".x, " + target + ".y, " + this._dataReg + ".y\n" + "sub " + target + ".y, " + this._dataReg + ".z, " + target + ".y\n" + "mul " + target + ".y, " + this._dataReg + ".x, " + target + ".y\n" + "add " + target + ".y, " + target + ".x, " + target + ".y\n" + "mul " + target + ".w, " + target + ".w, " + target + ".y\n";

                console.log('SpecularFresnelMethod', 'modulateSpecular', code);

                return code;
            };
            return SpecularFresnelMethod;
        })(materials.SpecularCompositeMethod);
        materials.SpecularFresnelMethod = SpecularFresnelMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * SpecularPhongMethod provides a specular method that provides Phong highlights.
        */
        var SpecularPhongMethod = (function (_super) {
            __extends(SpecularPhongMethod, _super);
            /**
            * Creates a new SpecularPhongMethod object.
            */
            function SpecularPhongMethod() {
                _super.call(this);
            }
            /**
            * @inheritDoc
            */
            SpecularPhongMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                if (this._pIsFirstLight) {
                    t = this._pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                var viewDirReg = this._sharedRegisters.viewDirFragment;
                var normalReg = this._sharedRegisters.normalFragment;

                // phong model
                code += "dp3 " + t + ".w, " + lightDirReg + ", " + normalReg + "\n" + "add " + t + ".w, " + t + ".w, " + t + ".w\n" + "mul " + t + ".xyz, " + normalReg + ", " + t + ".w\n" + "sub " + t + ".xyz, " + t + ", " + lightDirReg + "\n" + "add " + t + ".w, " + t + ".w, " + this._sharedRegisters.commons + ".w\n" + "sat " + t + ".w, " + t + ".w\n" + "mul " + t + ".xyz, " + t + ", " + t + ".w\n" + "dp3 " + t + ".w, " + t + ", " + viewDirReg + "\n" + "sat " + t + ".w, " + t + ".w\n";

                if (this._pUseTexture) {
                    // apply gloss modulation from texture
                    code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" + "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
                } else
                    code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";

                // attenuate
                if (vo.useLightFallOff)
                    code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";

                if (this._iModulateMethod != null)
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);

                code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";

                if (!this._pIsFirstLight) {
                    code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
                    regCache.removeFragmentTempUsage(t);
                }

                this._pIsFirstLight = false;

                return code;
            };
            return SpecularPhongMethod;
        })(materials.SpecularBasicMethod);
        materials.SpecularPhongMethod = SpecularPhongMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * LightPickerBase provides an abstract base clase for light picker classes. These classes are responsible for
        * feeding materials with relevant lights. Usually, StaticLightPicker can be used, but LightPickerBase can be
        * extended to provide more application-specific dynamic selection of lights.
        *
        * @see StaticLightPicker
        */
        var LightPickerBase = (function (_super) {
            __extends(LightPickerBase, _super);
            /**
            * Creates a new LightPickerBase object.
            */
            function LightPickerBase() {
                _super.call(this);
                this._pNumPointLights = 0;
                this._pNumDirectionalLights = 0;
                this._pNumCastingPointLights = 0;
                this._pNumCastingDirectionalLights = 0;
                this._pNumLightProbes = 0;
            }
            /**
            * Disposes resources used by the light picker.
            */
            LightPickerBase.prototype.dispose = function () {
            };

            Object.defineProperty(LightPickerBase.prototype, "assetType", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return away.library.AssetType.LIGHT_PICKER;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
                /**
                * The maximum amount of directional lights that will be provided.
                */
                get: function () {
                    return this._pNumDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
                /**
                * The maximum amount of point lights that will be provided.
                */
                get: function () {
                    return this._pNumPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numCastingDirectionalLights", {
                /**
                * The maximum amount of directional lights that cast shadows.
                */
                get: function () {
                    return this._pNumCastingDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numCastingPointLights", {
                /**
                * The amount of point lights that cast shadows.
                */
                get: function () {
                    return this._pNumCastingPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numLightProbes", {
                /**
                * The maximum amount of light probes that will be provided.
                */
                get: function () {
                    return this._pNumLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "pointLights", {
                /**
                * The collected point lights to be used for shading.
                */
                get: function () {
                    return this._pPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
                /**
                * The collected directional lights to be used for shading.
                */
                get: function () {
                    return this._pDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "castingPointLights", {
                /**
                * The collected point lights that cast shadows to be used for shading.
                */
                get: function () {
                    return this._pCastingPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "castingDirectionalLights", {
                /**
                * The collected directional lights that cast shadows to be used for shading.
                */
                get: function () {
                    return this._pCastingDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "lightProbes", {
                /**
                * The collected light probes to be used for shading.
                */
                get: function () {
                    return this._pLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "lightProbeWeights", {
                /**
                * The weights for each light probe, defining their influence on the object.
                */
                get: function () {
                    return this._pLightProbeWeights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
                /**
                * A collection of all the collected lights.
                */
                get: function () {
                    return this._pAllPickedLights;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates set of lights for a given renderable and EntityCollector. Always call super.collectLights() after custom overridden code.
            */
            LightPickerBase.prototype.collectLights = function (renderable, entityCollector) {
                this.updateProbeWeights(renderable);
            };

            /**
            * Updates the weights for the light probes, based on the renderable's position relative to them.
            * @param renderable The renderble for which to calculate the light probes' influence.
            */
            LightPickerBase.prototype.updateProbeWeights = function (renderable) {
                // todo: this will cause the same calculations to occur per TriangleSubMesh. See if this can be improved.
                var objectPos = renderable.sourceEntity.scenePosition;
                var lightPos;

                var rx = objectPos.x, ry = objectPos.y, rz = objectPos.z;
                var dx, dy, dz;
                var w, total = 0;
                var i;

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    lightPos = this._pLightProbes[i].scenePosition;
                    dx = rx - lightPos.x;
                    dy = ry - lightPos.y;
                    dz = rz - lightPos.z;

                    // weight is inversely proportional to square of distance
                    w = dx * dx + dy * dy + dz * dz;

                    // just... huge if at the same spot
                    w = w > .00001 ? 1 / w : 50000000;
                    this._pLightProbeWeights[i] = w;
                    total += w;
                }

                // normalize
                total = 1 / total;

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    this._pLightProbeWeights[i] *= total;
                }
            };
            return LightPickerBase;
        })(away.library.NamedAssetBase);
        materials.LightPickerBase = LightPickerBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var Delegate = away.utils.Delegate;

        var LightEvent = away.events.LightEvent;
        var DirectionalLight = away.lights.DirectionalLight;

        var LightProbe = away.lights.LightProbe;
        var PointLight = away.lights.PointLight;

        /**
        * StaticLightPicker is a light picker that provides a static set of lights. The lights can be reassigned, but
        * if the configuration changes (number of directional lights, point lights, etc), a material recompilation may
        * occur.
        */
        var StaticLightPicker = (function (_super) {
            __extends(StaticLightPicker, _super);
            /**
            * Creates a new StaticLightPicker object.
            * @param lights The lights to be used for shading.
            */
            function StaticLightPicker(lights) {
                _super.call(this);

                this._onCastShadowChangeDelegate = Delegate.create(this, this.onCastShadowChange);

                this.lights = lights;
            }
            Object.defineProperty(StaticLightPicker.prototype, "lights", {
                /**
                * The lights used for shading.
                */
                get: function () {
                    return this._lights;
                },
                set: function (value) {
                    var numPointLights = 0;
                    var numDirectionalLights = 0;
                    var numCastingPointLights = 0;
                    var numCastingDirectionalLights = 0;
                    var numLightProbes = 0;
                    var light;

                    if (this._lights)
                        this.clearListeners();

                    this._lights = value;
                    this._pAllPickedLights = value;
                    this._pPointLights = new Array();
                    this._pCastingPointLights = new Array();
                    this._pDirectionalLights = new Array();
                    this._pCastingDirectionalLights = new Array();
                    this._pLightProbes = new Array();

                    var len = value.length;

                    for (var i = 0; i < len; ++i) {
                        light = value[i];
                        light.addEventListener(LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);

                        if (light instanceof PointLight) {
                            if (light.castsShadows)
                                this._pCastingPointLights[numCastingPointLights++] = light;
                            else
                                this._pPointLights[numPointLights++] = light;
                        } else if (light instanceof DirectionalLight) {
                            if (light.castsShadows)
                                this._pCastingDirectionalLights[numCastingDirectionalLights++] = light;
                            else
                                this._pDirectionalLights[numDirectionalLights++] = light;
                        } else if (light instanceof LightProbe) {
                            this._pLightProbes[numLightProbes++] = light;
                        }
                    }

                    if (this._pNumDirectionalLights == numDirectionalLights && this._pNumPointLights == numPointLights && this._pNumLightProbes == numLightProbes && this._pNumCastingPointLights == numCastingPointLights && this._pNumCastingDirectionalLights == numCastingDirectionalLights) {
                        return;
                    }

                    this._pNumDirectionalLights = numDirectionalLights;
                    this._pNumCastingDirectionalLights = numCastingDirectionalLights;
                    this._pNumPointLights = numPointLights;
                    this._pNumCastingPointLights = numCastingPointLights;
                    this._pNumLightProbes = numLightProbes;

                    // MUST HAVE MULTIPLE OF 4 ELEMENTS!
                    this._pLightProbeWeights = new Array(Math.ceil(numLightProbes / 4) * 4);

                    // notify material lights have changed
                    this.dispatchEvent(new away.events.Event(away.events.Event.CHANGE));
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Remove configuration change listeners on the lights.
            */
            StaticLightPicker.prototype.clearListeners = function () {
                var len = this._lights.length;
                for (var i = 0; i < len; ++i)
                    this._lights[i].removeEventListener(away.events.LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
            };

            /**
            * Notifies the material of a configuration change.
            */
            StaticLightPicker.prototype.onCastShadowChange = function (event) {
                // TODO: Assign to special caster collections, just append it to the lights in SinglePass
                // But keep seperated in multipass
                var light = event.target;

                if (light instanceof PointLight) {
                    var pl = light;
                    this.updatePointCasting(pl);
                } else if (light instanceof DirectionalLight) {
                    var dl = light;
                    this.updateDirectionalCasting(dl);
                }

                this.dispatchEvent(new away.events.Event(away.events.Event.CHANGE));
            };

            /**
            * Called when a directional light's shadow casting configuration changes.
            */
            StaticLightPicker.prototype.updateDirectionalCasting = function (light) {
                var dl = light;

                if (light.castsShadows) {
                    --this._pNumDirectionalLights;
                    ++this._pNumCastingDirectionalLights;

                    this._pDirectionalLights.splice(this._pDirectionalLights.indexOf(dl), 1);
                    this._pCastingDirectionalLights.push(light);
                } else {
                    ++this._pNumDirectionalLights;
                    --this._pNumCastingDirectionalLights;

                    this._pCastingDirectionalLights.splice(this._pCastingDirectionalLights.indexOf(dl), 1);
                    this._pDirectionalLights.push(light);
                }
            };

            /**
            * Called when a point light's shadow casting configuration changes.
            */
            StaticLightPicker.prototype.updatePointCasting = function (light) {
                var pl = light;

                if (light.castsShadows) {
                    --this._pNumPointLights;
                    ++this._pNumCastingPointLights;
                    this._pPointLights.splice(this._pPointLights.indexOf(pl), 1);
                    this._pCastingPointLights.push(light);
                } else {
                    ++this._pNumPointLights;
                    --this._pNumCastingPointLights;

                    this._pCastingPointLights.splice(this._pCastingPointLights.indexOf(pl), 1);
                    this._pPointLights.push(light);
                }
            };
            return StaticLightPicker;
        })(materials.LightPickerBase);
        materials.StaticLightPicker = StaticLightPicker;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShaderRegister Cache provides the usage management system for all registers during shading compilation.
        */
        var ShaderRegisterCache = (function () {
            /**
            * Create a new ShaderRegisterCache object.
            *
            * @param profile The compatibility profile used by the renderer.
            */
            function ShaderRegisterCache(profile) {
                this._numUsedVertexConstants = 0;
                this._numUsedFragmentConstants = 0;
                this._numUsedStreams = 0;
                this._numUsedTextures = 0;
                this._numUsedVaryings = 0;
                this._profile = profile;
            }
            /**
            * Resets all registers.
            */
            ShaderRegisterCache.prototype.reset = function () {
                //TODO: AGAL <> GLSL Conversion
                this._fragmentTempCache = new materials.RegisterPool("ft", 8, false);
                this._vertexTempCache = new materials.RegisterPool("vt", 8, false);
                this._varyingCache = new materials.RegisterPool("v", 8);
                this._textureCache = new materials.RegisterPool("fs", 8);
                this._vertexAttributesCache = new materials.RegisterPool("va", 8);
                this._fragmentConstantsCache = new materials.RegisterPool("fc", 28);
                this._vertexConstantsCache = new materials.RegisterPool("vc", 128);
                this._fragmentOutputRegister = new materials.ShaderRegisterElement("oc", -1);
                this._vertexOutputRegister = new materials.ShaderRegisterElement("op", -1);
                this._numUsedVertexConstants = 0;
                this._numUsedStreams = 0;
                this._numUsedTextures = 0;
                this._numUsedVaryings = 0;
                this._numUsedFragmentConstants = 0;

                var i;

                for (i = 0; i < this._vertexAttributesOffset; ++i)
                    this.getFreeVertexAttribute();

                for (i = 0; i < this._vertexConstantOffset; ++i)
                    this.getFreeVertexConstant();

                for (i = 0; i < this._varyingsOffset; ++i)
                    this.getFreeVarying();

                for (i = 0; i < this._fragmentConstantOffset; ++i)
                    this.getFreeFragmentConstant();
            };

            /**
            * Disposes all resources used.
            */
            ShaderRegisterCache.prototype.dispose = function () {
                this._fragmentTempCache.dispose();
                this._vertexTempCache.dispose();
                this._varyingCache.dispose();
                this._fragmentConstantsCache.dispose();
                this._vertexAttributesCache.dispose();

                this._fragmentTempCache = null;
                this._vertexTempCache = null;
                this._varyingCache = null;
                this._fragmentConstantsCache = null;
                this._vertexAttributesCache = null;
                this._fragmentOutputRegister = null;
                this._vertexOutputRegister = null;
            };

            /**
            * Marks a fragment temporary register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            ShaderRegisterCache.prototype.addFragmentTempUsages = function (register, usageCount) {
                this._fragmentTempCache.addUsage(register, usageCount);
            };

            /**
            * Removes a usage from a fragment temporary register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            ShaderRegisterCache.prototype.removeFragmentTempUsage = function (register) {
                this._fragmentTempCache.removeUsage(register);
            };

            /**
            * Marks a vertex temporary register as used, so it cannot be retrieved. The register won't be able to be used
            * until removeUsage has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            ShaderRegisterCache.prototype.addVertexTempUsages = function (register, usageCount) {
                this._vertexTempCache.addUsage(register, usageCount);
            };

            /**
            * Removes a usage from a vertex temporary register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            ShaderRegisterCache.prototype.removeVertexTempUsage = function (register) {
                this._vertexTempCache.removeUsage(register);
            };

            /**
            * Retrieve an entire fragment temporary register that's still available. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            */
            ShaderRegisterCache.prototype.getFreeFragmentVectorTemp = function () {
                return this._fragmentTempCache.requestFreeVectorReg();
            };

            /**
            * Retrieve a single component from a fragment temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeFragmentSingleTemp = function () {
                return this._fragmentTempCache.requestFreeRegComponent();
            };

            /**
            * Retrieve an available varying register
            */
            ShaderRegisterCache.prototype.getFreeVarying = function () {
                ++this._numUsedVaryings;
                return this._varyingCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available fragment constant register
            */
            ShaderRegisterCache.prototype.getFreeFragmentConstant = function () {
                ++this._numUsedFragmentConstants;
                return this._fragmentConstantsCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available vertex constant register
            */
            ShaderRegisterCache.prototype.getFreeVertexConstant = function () {
                ++this._numUsedVertexConstants;
                return this._vertexConstantsCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an entire vertex temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeVertexVectorTemp = function () {
                return this._vertexTempCache.requestFreeVectorReg();
            };

            /**
            * Retrieve a single component from a vertex temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeVertexSingleTemp = function () {
                return this._vertexTempCache.requestFreeRegComponent();
            };

            /**
            * Retrieve an available vertex attribute register
            */
            ShaderRegisterCache.prototype.getFreeVertexAttribute = function () {
                ++this._numUsedStreams;
                return this._vertexAttributesCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available texture register
            */
            ShaderRegisterCache.prototype.getFreeTextureReg = function () {
                ++this._numUsedTextures;
                return this._textureCache.requestFreeVectorReg();
            };

            Object.defineProperty(ShaderRegisterCache.prototype, "vertexConstantOffset", {
                /**
                * Indicates the start index from which to retrieve vertex constants.
                */
                get: function () {
                    return this._vertexConstantOffset;
                },
                set: function (vertexConstantOffset) {
                    this._vertexConstantOffset = vertexConstantOffset;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "vertexAttributesOffset", {
                /**
                * Indicates the start index from which to retrieve vertex attributes.
                */
                get: function () {
                    return this._vertexAttributesOffset;
                },
                set: function (value) {
                    this._vertexAttributesOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "varyingsOffset", {
                /**
                * Indicates the start index from which to retrieve varying registers.
                */
                get: function () {
                    return this._varyingsOffset;
                },
                set: function (value) {
                    this._varyingsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "fragmentConstantOffset", {
                /**
                * Indicates the start index from which to retrieve fragment constants.
                */
                get: function () {
                    return this._fragmentConstantOffset;
                },
                set: function (value) {
                    this._fragmentConstantOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "fragmentOutputRegister", {
                /**
                * The fragment output register.
                */
                get: function () {
                    return this._fragmentOutputRegister;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVertexConstants", {
                /**
                * The amount of used vertex constant registers.
                */
                get: function () {
                    return this._numUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedFragmentConstants", {
                /**
                * The amount of used fragment constant registers.
                */
                get: function () {
                    return this._numUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedStreams", {
                /**
                * The amount of used vertex streams.
                */
                get: function () {
                    return this._numUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedTextures", {
                /**
                * The amount of used texture slots.
                */
                get: function () {
                    return this._numUsedTextures;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVaryings", {
                /**
                * The amount of used varying registers.
                */
                get: function () {
                    return this._numUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });
            return ShaderRegisterCache;
        })();
        materials.ShaderRegisterCache = ShaderRegisterCache;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * A single register element (an entire register or a single register's component) used by the RegisterPool.
        */
        var ShaderRegisterElement = (function () {
            /**
            * Creates a new ShaderRegisterElement object.
            * @param regName The name of the register.
            * @param index The index of the register.
            * @param component The register's component, if not the entire register is represented.
            */
            function ShaderRegisterElement(regName, index, component) {
                if (typeof component === "undefined") { component = -1; }
                this._component = component;
                this._regName = regName;
                this._index = index;

                this._toStr = this._regName;

                if (this._index >= 0) {
                    this._toStr += this._index;
                }

                if (component > -1) {
                    this._toStr += "." + ShaderRegisterElement.COMPONENTS[component];
                }
            }
            /**
            * Converts the register or the components AGAL string representation.
            */
            ShaderRegisterElement.prototype.toString = function () {
                return this._toStr;
            };

            Object.defineProperty(ShaderRegisterElement.prototype, "regName", {
                /**
                * The register's name.
                */
                get: function () {
                    return this._regName;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterElement.prototype, "index", {
                /**
                * The register's index.
                */
                get: function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            ShaderRegisterElement.COMPONENTS = ["x", "y", "z", "w"];
            return ShaderRegisterElement;
        })();
        materials.ShaderRegisterElement = ShaderRegisterElement;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShaderRegisterData contains the "named" registers, generated by the compiler and to be passed on to the methods.
        */
        var ShaderRegisterData = (function () {
            function ShaderRegisterData() {
            }
            return ShaderRegisterData;
        })();
        materials.ShaderRegisterData = ShaderRegisterData;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.materials.LightSources;
        //import away3d.materials.methods.MethodVO;
        /**
        * MethodDependencyCounter keeps track of the number of dependencies for "named registers" used across methods.
        * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
        * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
        * each time a method has been compiled into the shader.
        *
        * @see RegisterPool.addUsage
        */
        var MethodDependencyCounter = (function () {
            /**
            * Creates a new MethodDependencyCounter object.
            */
            function MethodDependencyCounter() {
                this._usesGlobalPosFragment = false;
            }
            /**
            * Clears dependency counts for all registers. Called when recompiling a pass.
            */
            MethodDependencyCounter.prototype.reset = function () {
                this._projectionDependencies = 0;
                this._normalDependencies = 0;
                this._viewDirDependencies = 0;
                this._uvDependencies = 0;
                this._secondaryUVDependencies = 0;
                this._globalPosDependencies = 0;
                this._tangentDependencies = 0;
                this._usesGlobalPosFragment = false;
            };

            /**
            * Sets the amount of lights that have a position associated with them.
            * @param numPointLights The amount of point lights.
            * @param lightSourceMask The light source types used by the material.
            */
            MethodDependencyCounter.prototype.setPositionedLights = function (numPointLights, lightSourceMask) {
                this._numPointLights = numPointLights;
                this._lightSourceMask = lightSourceMask;
            };

            /**
            * Increases dependency counters for the named registers listed as required by the given MethodVO.
            * @param methodVO the MethodVO object for which to include dependencies.
            */
            MethodDependencyCounter.prototype.includeMethodVO = function (methodVO) {
                if (methodVO.needsProjection) {
                    ++this._projectionDependencies;
                }

                if (methodVO.needsGlobalVertexPos) {
                    ++this._globalPosDependencies;

                    if (methodVO.needsGlobalFragmentPos) {
                        this._usesGlobalPosFragment = true;
                    }
                } else if (methodVO.needsGlobalFragmentPos) {
                    ++this._globalPosDependencies;
                    this._usesGlobalPosFragment = true;
                }

                if (methodVO.needsNormals) {
                    ++this._normalDependencies;
                }

                if (methodVO.needsTangents) {
                    ++this._tangentDependencies;
                }

                if (methodVO.needsView) {
                    ++this._viewDirDependencies;
                }

                if (methodVO.needsUV) {
                    ++this._uvDependencies;
                }

                if (methodVO.needsSecondaryUV) {
                    ++this._secondaryUVDependencies;
                }
            };

            Object.defineProperty(MethodDependencyCounter.prototype, "tangentDependencies", {
                /**
                * The amount of tangent vector dependencies (fragment shader).
                */
                get: function () {
                    return this._tangentDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "usesGlobalPosFragment", {
                /**
                * Indicates whether there are any dependencies on the world-space position vector.
                */
                get: function () {
                    return this._usesGlobalPosFragment;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "projectionDependencies", {
                /**
                * The amount of dependencies on the projected position.
                */
                get: function () {
                    return this._projectionDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "normalDependencies", {
                /**
                * The amount of dependencies on the normal vector.
                */
                get: function () {
                    return this._normalDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "viewDirDependencies", {
                /**
                * The amount of dependencies on the view direction.
                */
                get: function () {
                    return this._viewDirDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "uvDependencies", {
                /**
                * The amount of dependencies on the primary UV coordinates.
                */
                get: function () {
                    return this._uvDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "secondaryUVDependencies", {
                /**
                * The amount of dependencies on the secondary UV coordinates.
                */
                get: function () {
                    return this._secondaryUVDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "globalPosDependencies", {
                /**
                * The amount of dependencies on the global position. This can be 0 while hasGlobalPosDependencies is true when
                * the global position is used as a temporary value (fe to calculate the view direction)
                */
                get: function () {
                    return this._globalPosDependencies;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds any external world space dependencies, used to force world space calculations.
            */
            MethodDependencyCounter.prototype.addWorldSpaceDependencies = function (fragmentLights) {
                if (this._viewDirDependencies > 0) {
                    ++this._globalPosDependencies;
                }

                if (this._numPointLights > 0 && (this._lightSourceMask & materials.LightSources.LIGHTS)) {
                    ++this._globalPosDependencies;

                    if (fragmentLights) {
                        this._usesGlobalPosFragment = true;
                    }
                }
            };
            return MethodDependencyCounter;
        })();
        materials.MethodDependencyCounter = MethodDependencyCounter;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import flash.utils.Dictionary;
        /**
        * RegisterPool is used by the shader compilation process to keep track of which registers of a certain type are
        * currently used and should not be allowed to be written to. Either entire registers can be requested and locked,
        * or single components (x, y, z, w) of a single register.
        * It is used by ShaderRegisterCache to track usages of individual register types.
        *
        * @see away3d.materials.compilation.ShaderRegisterCache
        */
        var RegisterPool = (function () {
            /**
            * Creates a new RegisterPool object.
            * @param regName The base name of the register type ("ft" for fragment temporaries, "vc" for vertex constants, etc)
            * @param regCount The amount of available registers of this type.
            * @param persistent Whether or not registers, once reserved, can be freed again. For example, temporaries are not persistent, but constants are.
            */
            function RegisterPool(regName, regCount, persistent) {
                if (typeof persistent === "undefined") { persistent = true; }
                this._regName = regName;
                this._regCount = regCount;
                this._persistent = persistent;
                this.initRegisters(regName, regCount);
            }
            /**
            * Retrieve an entire vector register that's still available.
            */
            RegisterPool.prototype.requestFreeVectorReg = function () {
                for (var i = 0; i < this._regCount; ++i) {
                    if (!this.isRegisterUsed(i)) {
                        if (this._persistent)
                            this._usedVectorCount[i]++;

                        return this._vectorRegisters[i];
                    }
                }

                throw new Error("Register overflow!");
            };

            /**
            * Retrieve a single vector component that's still available.
            */
            RegisterPool.prototype.requestFreeRegComponent = function () {
                for (var i = 0; i < this._regCount; ++i) {
                    //away.Debug.log( 'RegisterPool' , 'requestFreeRegComponent' , this._regCount , 'this._usedVectorCount:' + this._usedVectorCount[i] );
                    if (this._usedVectorCount[i] > 0)
                        continue;

                    for (var j = 0; j < 4; ++j) {
                        if (this._usedSingleCount[j][i] == 0) {
                            if (this._persistent)
                                this._usedSingleCount[j][i]++;

                            return this._registerComponents[j][i];
                        }
                    }
                }

                throw new Error("Register overflow!");
            };

            /**
            * Marks a register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            RegisterPool.prototype.addUsage = function (register, usageCount) {
                if (register._component > -1)
                    this._usedSingleCount[register._component][register.index] += usageCount;
                else
                    this._usedVectorCount[register.index] += usageCount;
            };

            /**
            * Removes a usage from a register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            RegisterPool.prototype.removeUsage = function (register) {
                if (register._component > -1) {
                    if (--this._usedSingleCount[register._component][register.index] < 0)
                        throw new Error("More usages removed than exist!");
                } else {
                    if (--this._usedVectorCount[register.index] < 0)
                        throw new Error("More usages removed than exist!");
                }
            };

            /**
            * Disposes any resources used by the current RegisterPool object.
            */
            RegisterPool.prototype.dispose = function () {
                this._vectorRegisters = null;
                this._registerComponents = null;
                this._usedSingleCount = null;
                this._usedVectorCount = null;
            };

            /**
            * Indicates whether or not any registers are in use.
            */
            RegisterPool.prototype.hasRegisteredRegs = function () {
                for (var i = 0; i < this._regCount; ++i)
                    if (this.isRegisterUsed(i))
                        return true;

                return false;
            };

            /**
            * Initializes all registers.
            */
            RegisterPool.prototype.initRegisters = function (regName, regCount) {
                var hash = RegisterPool._initPool(regName, regCount);

                this._vectorRegisters = RegisterPool._regPool[hash];
                this._registerComponents = RegisterPool._regCompsPool[hash];

                this._usedVectorCount = this._initArray(Array(regCount), 0); //new Vector.<uint>(regCount, true);

                this._usedSingleCount = new Array(4); //this._usedSingleCount = new Vector.<Vector.<uint>>(4, true);
                this._usedSingleCount[0] = this._initArray(new Array(regCount), 0); //new Array<number>(regCount ) ;//, true);
                this._usedSingleCount[1] = this._initArray(new Array(regCount), 0); //new Array<number>(regCount ) ;//new Vector.<uint>(regCount, true);
                this._usedSingleCount[2] = this._initArray(new Array(regCount), 0); //new Array<number>(regCount ) ;//new Vector.<uint>(regCount, true);
                this._usedSingleCount[3] = this._initArray(new Array(regCount), 0); //new Array<number>(regCount ) ;//new Vector.<uint>(regCount, true);
                //console.log( 'this._usedVectorCount: ' , this._usedVectorCount );
                //console.log( 'this._usedSingleCount: ' , this._usedSingleCount );
            };

            RegisterPool._initPool = function (regName, regCount) {
                var hash = regName + regCount;

                if (RegisterPool._regPool[hash] != undefined)
                    return hash;

                var vectorRegisters = new Array(regCount);
                RegisterPool._regPool[hash] = vectorRegisters;

                var registerComponents = [
                    [],
                    [],
                    [],
                    []
                ];
                RegisterPool._regCompsPool[hash] = registerComponents;

                for (var i = 0; i < regCount; ++i) {
                    vectorRegisters[i] = new materials.ShaderRegisterElement(regName, i);

                    for (var j = 0; j < 4; ++j)
                        registerComponents[j][i] = new materials.ShaderRegisterElement(regName, i, j);
                }

                //console.log ( 'RegisterPool._regCompsPool[hash] : ' , RegisterPool._regCompsPool[hash]  );
                //console.log ( 'RegisterPool._regPool[hash] : ' , RegisterPool._regPool[hash]  );
                return hash;
            };

            /**
            * Check if the temp register is either used for single or vector use
            */
            RegisterPool.prototype.isRegisterUsed = function (index) {
                if (this._usedVectorCount[index] > 0)
                    return true;

                for (var i = 0; i < 4; ++i)
                    if (this._usedSingleCount[i][index] > 0)
                        return true;

                return false;
            };

            RegisterPool.prototype._initArray = function (a, val) {
                var l = a.length;

                for (var c = 0; c < l; c++)
                    a[c] = val;

                return a;
            };
            RegisterPool._regPool = new Object();
            RegisterPool._regCompsPool = new Object();
            return RegisterPool;
        })();
        materials.RegisterPool = RegisterPool;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ShaderCompiler is an abstract base class for shader compilers that use modular shader methods to assemble a
        * material. Concrete subclasses are used by the default materials.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var ShaderCompiler = (function () {
            /**
            * Creates a new ShaderCompiler object.
            * @param profile The compatibility profile of the renderer.
            */
            function ShaderCompiler(profile) {
                this._preserveAlpha = true;
                this._pVertexCode = '';
                this._pFragmentCode = '';
                this._commonsDataIndex = -1;
                this._uvBufferIndex = -1;
                this._uvTransformIndex = -1;
                this._secondaryUVBufferIndex = -1;
                this._pNormalBufferIndex = -1;
                this._pTangentBufferIndex = -1;
                this._pLightFragmentConstantIndex = -1;
                this._sceneMatrixIndex = -1;
                this._pSceneNormalMatrixIndex = -1;
                this._pCameraPositionIndex = -1;
                this._pProbeWeightsIndex = -1;
                this._pSharedRegisters = new materials.ShaderRegisterData();
                this._pDependencyCounter = new materials.MethodDependencyCounter();
                this._pProfile = profile;
                this.initRegisterCache(profile);
            }
            Object.defineProperty(ShaderCompiler.prototype, "enableLightFallOff", {
                /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                get: function () {
                    return this._pEnableLightFallOff;
                },
                set: function (value) {
                    this._pEnableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "needUVAnimation", {
                /**
                * Indicates whether the compiled code needs UV animation.
                */
                get: function () {
                    return this._needUVAnimation;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "UVTarget", {
                /**
                * The target register to place the animated UV coordinate.
                */
                get: function () {
                    return this._UVTarget;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "UVSource", {
                /**
                * The souce register providing the UV coordinate to animate.
                */
                get: function () {
                    return this._UVSource;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "forceSeperateMVP", {
                /**
                * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
                * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
                * projection code.
                */
                get: function () {
                    return this._forceSeperateMVP;
                },
                set: function (value) {
                    this._forceSeperateMVP = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Initialized the register cache.
            * @param profile The compatibility profile of the renderer.
            */
            ShaderCompiler.prototype.initRegisterCache = function (profile) {
                this._pRegisterCache = new materials.ShaderRegisterCache(profile);
                this._pRegisterCache.vertexAttributesOffset = 1;
                this._pRegisterCache.reset();
            };

            Object.defineProperty(ShaderCompiler.prototype, "animateUVs", {
                /**
                * Indicate whether UV coordinates need to be animated using the renderable's transformUV matrix.
                */
                get: function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "alphaPremultiplied", {
                /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied.
                */
                get: function () {
                    return this._pAlphaPremultiplied;
                },
                set: function (value) {
                    this._pAlphaPremultiplied = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "preserveAlpha", {
                /**
                * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
                */
                get: function () {
                    return this._preserveAlpha;
                },
                set: function (value) {
                    this._preserveAlpha = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Sets the default texture sampling properties.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to true.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to true.
            */
            ShaderCompiler.prototype.setTextureSampling = function (smooth, repeat, mipmap) {
                this._smooth = smooth;
                this._repeat = repeat;
                this._mipmap = mipmap;
            };

            /**
            * Sets the constant buffers allocated by the material. This allows setting constant data during compilation.
            * @param vertexConstantData The vertex constant data buffer.
            * @param fragmentConstantData The fragment constant data buffer.
            */
            ShaderCompiler.prototype.setConstantDataBuffers = function (vertexConstantData, fragmentConstantData) {
                this._vertexConstantData = vertexConstantData;
                this._fragmentConstantData = fragmentConstantData;
            };

            Object.defineProperty(ShaderCompiler.prototype, "methodSetup", {
                /**
                * The shader method setup object containing the method configuration and their value objects for the material being compiled.
                */
                get: function () {
                    return this._pMethodSetup;
                },
                set: function (value) {
                    this._pMethodSetup = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Compiles the code after all setup on the compiler has finished.
            */
            ShaderCompiler.prototype.compile = function () {
                this.pInitRegisterIndices();
                this.pInitLightData();

                this._pAnimatableAttributes = new Array("va0"); //Vector.<String>(["va0"]);
                this._pAnimationTargetRegisters = new Array("vt0"); //Vector.<String>(["vt0"]);
                this._pVertexCode = "";
                this._pFragmentCode = "";

                this._pSharedRegisters.localPosition = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.localPosition, 1);

                this.createCommons();
                this.pCalculateDependencies();
                this.updateMethodRegisters();

                for (var i = 0; i < 4; ++i)
                    this._pRegisterCache.getFreeVertexConstant();

                this.pCreateNormalRegisters();

                if (this._pDependencyCounter.globalPosDependencies > 0 || this._forceSeperateMVP)
                    this.pCompileGlobalPositionCode();

                this.compileProjectionCode();
                this.pCompileMethodsCode();
                this.compileFragmentOutput();
                this._fragmentPostLightCode = this.fragmentCode;
            };

            /**
            * Creates the registers to contain the normal data.
            */
            ShaderCompiler.prototype.pCreateNormalRegisters = function () {
            };

            /**
            * Compile the code for the methods.
            */
            ShaderCompiler.prototype.pCompileMethodsCode = function () {
                if (this._pDependencyCounter.uvDependencies > 0)
                    this.compileUVCode();

                if (this._pDependencyCounter.secondaryUVDependencies > 0)
                    this.compileSecondaryUVCode();

                if (this._pDependencyCounter.normalDependencies > 0)
                    this.pCompileNormalCode();

                if (this._pDependencyCounter.viewDirDependencies > 0)
                    this.pCompileViewDirCode();

                this.pCompileLightingCode();
                this._fragmentLightCode = this._pFragmentCode;
                this._pFragmentCode = "";
                this.pCompileMethods();
            };

            /**
            * Compile the lighting code.
            */
            ShaderCompiler.prototype.pCompileLightingCode = function () {
            };

            /**
            * Calculate the view direction.
            */
            ShaderCompiler.prototype.pCompileViewDirCode = function () {
            };

            /**
            * Calculate the normal.
            */
            ShaderCompiler.prototype.pCompileNormalCode = function () {
            };

            /**
            * Calculate the (possibly animated) UV coordinates.
            */
            ShaderCompiler.prototype.compileUVCode = function () {
                var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
                this._uvBufferIndex = uvAttributeReg.index;

                var varying = this._pRegisterCache.getFreeVarying();

                this._pSharedRegisters.uvVarying = varying;

                if (this.animateUVs) {
                    // a, b, 0, tx
                    // c, d, 0, ty
                    var uvTransform1 = this._pRegisterCache.getFreeVertexConstant();
                    var uvTransform2 = this._pRegisterCache.getFreeVertexConstant();
                    this._uvTransformIndex = uvTransform1.index * 4;

                    // TODO: AGAL <> GLSL
                    this._pVertexCode += "dp4 " + varying + ".x, " + uvAttributeReg + ", " + uvTransform1 + "\n" + "dp4 " + varying + ".y, " + uvAttributeReg + ", " + uvTransform2 + "\n" + "mov " + varying + ".zw, " + uvAttributeReg + ".zw \n";
                } else {
                    this._uvTransformIndex = -1;
                    this._needUVAnimation = true;
                    this._UVTarget = varying.toString();
                    this._UVSource = uvAttributeReg.toString();
                }
            };

            /**
            * Provide the secondary UV coordinates.
            */
            ShaderCompiler.prototype.compileSecondaryUVCode = function () {
                // TODO: AGAL <> GLSL
                var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
                this._secondaryUVBufferIndex = uvAttributeReg.index;
                this._pSharedRegisters.secondaryUVVarying = this._pRegisterCache.getFreeVarying();
                this._pVertexCode += "mov " + this._pSharedRegisters.secondaryUVVarying + ", " + uvAttributeReg + "\n";
            };

            /**
            * Compile the world-space position.
            */
            ShaderCompiler.prototype.pCompileGlobalPositionCode = function () {
                // TODO: AGAL <> GLSL
                this._pSharedRegisters.globalPositionVertex = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.globalPositionVertex, this._pDependencyCounter.globalPosDependencies);
                var positionMatrixReg = this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._sceneMatrixIndex = positionMatrixReg.index * 4;

                this._pVertexCode += "m44 " + this._pSharedRegisters.globalPositionVertex + ", " + this._pSharedRegisters.localPosition + ", " + positionMatrixReg + "\n";

                if (this._pDependencyCounter.usesGlobalPosFragment) {
                    this._pSharedRegisters.globalPositionVarying = this._pRegisterCache.getFreeVarying();
                    this._pVertexCode += "mov " + this._pSharedRegisters.globalPositionVarying + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                }
            };

            /**
            * Get the projection coordinates.
            */
            ShaderCompiler.prototype.compileProjectionCode = function () {
                var pos = (this._pDependencyCounter.globalPosDependencies > 0 || this._forceSeperateMVP) ? this._pSharedRegisters.globalPositionVertex.toString() : this._pAnimationTargetRegisters[0];
                var code;

                // TODO: AGAL <> GLSL
                if (this._pDependencyCounter.projectionDependencies > 0) {
                    this._pSharedRegisters.projectionFragment = this._pRegisterCache.getFreeVarying();

                    code = "m44 vt5, " + pos + ", vc0		\n" + "mov " + this._pSharedRegisters.projectionFragment + ", vt5\n" + "mov op, vt5\n";
                } else {
                    code = "m44 op, " + pos + ", vc0		\n";
                }

                this._pVertexCode += code;
            };

            /**
            * Assign the final output colour the the output register.
            */
            ShaderCompiler.prototype.compileFragmentOutput = function () {
                // TODO: AGAL <> GLSL
                this._pFragmentCode += "mov " + this._pRegisterCache.fragmentOutputRegister + ", " + this._pSharedRegisters.shadedTarget + "\n";
                this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.shadedTarget);
            };

            /**
            * Reset all the indices to "unused".
            */
            ShaderCompiler.prototype.pInitRegisterIndices = function () {
                this._commonsDataIndex = -1;
                this._pCameraPositionIndex = -1;
                this._uvBufferIndex = -1;
                this._uvTransformIndex = -1;
                this._secondaryUVBufferIndex = -1;
                this._pNormalBufferIndex = -1;
                this._pTangentBufferIndex = -1;
                this._pLightFragmentConstantIndex = -1;
                this._sceneMatrixIndex = -1;
                this._pSceneNormalMatrixIndex = -1;
                this._pProbeWeightsIndex = -1;
            };

            /**
            * Prepares the setup for the light code.
            */
            ShaderCompiler.prototype.pInitLightData = function () {
                this._pNumLights = this._pNumPointLights + this._pNumDirectionalLights;
                this._pNumProbeRegisters = Math.ceil(this._pNumLightProbes / 4);

                if (this._pMethodSetup._iSpecularMethod) {
                    this._combinedLightSources = this._specularLightSources | this._diffuseLightSources;
                } else {
                    this._combinedLightSources = this._diffuseLightSources;
                }

                this._usingSpecularMethod = Boolean(this._pMethodSetup._iSpecularMethod && (this.pUsesLightsForSpecular() || this.pUsesProbesForSpecular()));
            };

            /**
            * Create the commonly shared constant register.
            */
            ShaderCompiler.prototype.createCommons = function () {
                this._pSharedRegisters.commons = this._pRegisterCache.getFreeFragmentConstant();
                this._commonsDataIndex = this._pSharedRegisters.commons.index * 4;
            };

            /**
            * Figure out which named registers are required, and how often.
            */
            ShaderCompiler.prototype.pCalculateDependencies = function () {
                this._pDependencyCounter.reset();

                var methods = this._pMethodSetup._iMethods;
                var len;

                this.setupAndCountMethodDependencies(this._pMethodSetup._iDiffuseMethod, this._pMethodSetup._iDiffuseMethodVO);

                if (this._pMethodSetup._iShadowMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iShadowMethod, this._pMethodSetup._iShadowMethodVO);

                this.setupAndCountMethodDependencies(this._pMethodSetup._iAmbientMethod, this._pMethodSetup._iAmbientMethodVO);

                if (this._usingSpecularMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iSpecularMethod, this._pMethodSetup._iSpecularMethodVO);

                if (this._pMethodSetup._iColorTransformMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iColorTransformMethod, this._pMethodSetup._iColorTransformMethodVO);

                len = methods.length;

                for (var i = 0; i < len; ++i)
                    this.setupAndCountMethodDependencies(methods[i].method, methods[i].data);

                if (this.usesNormals)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iNormalMethod, this._pMethodSetup._iNormalMethodVO);

                // todo: add spotlights to count check
                this._pDependencyCounter.setPositionedLights(this._pNumPointLights, this._combinedLightSources);
            };

            /**
            * Counts the dependencies for a given method.
            * @param method The method to count the dependencies for.
            * @param methodVO The method's data for this material.
            */
            ShaderCompiler.prototype.setupAndCountMethodDependencies = function (method, methodVO) {
                this.setupMethod(method, methodVO);
                this._pDependencyCounter.includeMethodVO(methodVO);
            };

            /**
            * Assigns all prerequisite data for the methods, so we can calculate dependencies for them.
            */
            ShaderCompiler.prototype.setupMethod = function (method, methodVO) {
                method.iReset();
                methodVO.reset();

                methodVO.vertexData = this._vertexConstantData;
                methodVO.fragmentData = this._fragmentConstantData;
                methodVO.useSmoothTextures = this._smooth;
                methodVO.repeatTextures = this._repeat;
                methodVO.useMipmapping = this._mipmap;
                methodVO.useLightFallOff = this._pEnableLightFallOff && this._pProfile != "baselineConstrained";
                methodVO.numLights = this._pNumLights + this._pNumLightProbes;

                method.iInitVO(methodVO);
            };

            Object.defineProperty(ShaderCompiler.prototype, "commonsDataIndex", {
                /**
                * The index for the common data register.
                */
                get: function () {
                    return this._commonsDataIndex;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Assigns the shared register data to all methods.
            */
            ShaderCompiler.prototype.updateMethodRegisters = function () {
                this._pMethodSetup._iNormalMethod.iSharedRegisters = this._pSharedRegisters;
                this._pMethodSetup._iDiffuseMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iSharedRegisters = this._pSharedRegisters;

                this._pMethodSetup._iAmbientMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iSharedRegisters = this._pSharedRegisters;

                var methods = this._pMethodSetup._iMethods;

                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iSharedRegisters = this._pSharedRegisters;
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "numUsedVertexConstants", {
                /**
                * The amount of vertex constants used by the material. Any animation code to be added can append its vertex
                * constant data after this.
                */
                get: function () {
                    return this._pRegisterCache.numUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedFragmentConstants", {
                /**
                * The amount of fragment constants used by the material. Any animation code to be added can append its vertex
                * constant data after this.
                */
                get: function () {
                    return this._pRegisterCache.numUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedStreams", {
                /**
                * The amount of vertex attribute streams used by the material. Any animation code to be added can add its
                * streams after this. Also used to automatically disable attribute slots on pass deactivation.
                */
                get: function () {
                    return this._pRegisterCache.numUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedTextures", {
                /**
                * The amount of textures used by the material. Used to automatically disable texture slots on pass deactivation.
                */
                get: function () {
                    return this._pRegisterCache.numUsedTextures;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedVaryings", {
                /**
                * Number of used varyings. Any animation code to be added can add its used varyings after this.
                */
                get: function () {
                    return this._pRegisterCache.numUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates whether lights are used for specular reflections.
            */
            ShaderCompiler.prototype.pUsesLightsForSpecular = function () {
                return this._pNumLights > 0 && (this._specularLightSources & materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Indicates whether lights are used for diffuse reflections.
            */
            ShaderCompiler.prototype.pUsesLightsForDiffuse = function () {
                return this._pNumLights > 0 && (this._diffuseLightSources & materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Disposes all resources used by the compiler.
            */
            ShaderCompiler.prototype.dispose = function () {
                this.cleanUpMethods();
                this._pRegisterCache.dispose();
                this._pRegisterCache = null;
                this._pSharedRegisters = null;
            };

            /**
            * Clean up method's compilation data after compilation finished.
            */
            ShaderCompiler.prototype.cleanUpMethods = function () {
                if (this._pMethodSetup._iNormalMethod)
                    this._pMethodSetup._iNormalMethod.iCleanCompilationData();

                if (this._pMethodSetup._iDiffuseMethod)
                    this._pMethodSetup._iDiffuseMethod.iCleanCompilationData();

                if (this._pMethodSetup._iAmbientMethod)
                    this._pMethodSetup._iAmbientMethod.iCleanCompilationData();

                if (this._pMethodSetup._iSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iCleanCompilationData();

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iCleanCompilationData();

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iCleanCompilationData();

                var methods = this._pMethodSetup._iMethods;

                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iCleanCompilationData();
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "specularLightSources", {
                /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                get: function () {
                    return this._specularLightSources;
                },
                set: function (value) {
                    this._specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "diffuseLightSources", {
                /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                get: function () {
                    return this._diffuseLightSources;
                },
                set: function (value) {
                    this._diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Indicates whether light probes are being used for specular reflections.
            */
            ShaderCompiler.prototype.pUsesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._specularLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether light probes are being used for diffuse reflections.
            */
            ShaderCompiler.prototype.pUsesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._diffuseLightSources & materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used.
            */
            ShaderCompiler.prototype.pUsesProbes = function () {
                return this._pNumLightProbes > 0 && ((this._diffuseLightSources | this._specularLightSources) & materials.LightSources.PROBES) != 0;
            };

            Object.defineProperty(ShaderCompiler.prototype, "uvBufferIndex", {
                /**
                * The index for the UV vertex attribute stream.
                */
                get: function () {
                    return this._uvBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "uvTransformIndex", {
                /**
                * The index for the UV transformation matrix vertex constant.
                */
                get: function () {
                    return this._uvTransformIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "secondaryUVBufferIndex", {
                /**
                * The index for the secondary UV vertex attribute stream.
                */
                get: function () {
                    return this._secondaryUVBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "normalBufferIndex", {
                /**
                * The index for the vertex normal attribute stream.
                */
                get: function () {
                    return this._pNormalBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "tangentBufferIndex", {
                /**
                * The index for the vertex tangent attribute stream.
                */
                get: function () {
                    return this._pTangentBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "lightFragmentConstantIndex", {
                /**
                * The first index for the fragment constants containing the light data.
                */
                get: function () {
                    return this._pLightFragmentConstantIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "cameraPositionIndex", {
                /**
                * The index of the vertex constant containing the camera position.
                */
                get: function () {
                    return this._pCameraPositionIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "sceneMatrixIndex", {
                /**
                * The index of the vertex constant containing the scene matrix.
                */
                get: function () {
                    return this._sceneMatrixIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "sceneNormalMatrixIndex", {
                /**
                * The index of the vertex constant containing the uniform scene matrix (the inverse transpose).
                */
                get: function () {
                    return this._pSceneNormalMatrixIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "probeWeightsIndex", {
                /**
                * The index of the fragment constant containing the weights for the light probes.
                */
                get: function () {
                    return this._pProbeWeightsIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "vertexCode", {
                /**
                * The generated vertex code.
                */
                get: function () {
                    return this._pVertexCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentCode", {
                /**
                * The generated fragment code.
                */
                get: function () {
                    return this._pFragmentCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentLightCode", {
                /**
                * The code containing the lighting calculations.
                */
                get: function () {
                    return this._fragmentLightCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentPostLightCode", {
                /**
                * The code containing the post-lighting calculations.
                */
                get: function () {
                    return this._fragmentPostLightCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "shadedTarget", {
                /**
                * The register name containing the final shaded colour.
                */
                get: function () {
                    return this._pSharedRegisters.shadedTarget.toString();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numPointLights", {
                /**
                * The amount of point lights that need to be supported.
                */
                get: function () {
                    return this._pNumPointLights;
                },
                set: function (numPointLights) {
                    this._pNumPointLights = numPointLights;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "numDirectionalLights", {
                /**
                * The amount of directional lights that need to be supported.
                */
                get: function () {
                    return this._pNumDirectionalLights;
                },
                set: function (value) {
                    this._pNumDirectionalLights = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "numLightProbes", {
                /**
                * The amount of light probes that need to be supported.
                */
                get: function () {
                    return this._pNumLightProbes;
                },
                set: function (value) {
                    this._pNumLightProbes = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "usingSpecularMethod", {
                /**
                * Indicates whether the specular method is used.
                */
                get: function () {
                    return this._usingSpecularMethod;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "animatableAttributes", {
                /**
                * The attributes that need to be animated by animators.
                */
                get: function () {
                    return this._pAnimatableAttributes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "animationTargetRegisters", {
                /**
                * The target registers for animated properties, written to by the animators.
                */
                get: function () {
                    return this._pAnimationTargetRegisters;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "usesNormals", {
                /**
                * Indicates whether the compiled shader uses normals.
                */
                get: function () {
                    return this._pDependencyCounter.normalDependencies > 0 && this._pMethodSetup._iNormalMethod.iHasOutput;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates whether the compiled shader uses lights.
            */
            ShaderCompiler.prototype.pUsesLights = function () {
                return this._pNumLights > 0 && (this._combinedLightSources & materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Compiles the code for the methods.
            */
            ShaderCompiler.prototype.pCompileMethods = function () {
                var methods = this._pMethodSetup._iMethods;

                var numMethods = methods.length;
                var method;
                var data;
                var alphaReg;

                // TODO: AGAL <> GLSL
                if (this._preserveAlpha) {
                    alphaReg = this._pRegisterCache.getFreeFragmentSingleTemp();
                    this._pRegisterCache.addFragmentTempUsages(alphaReg, 1);
                    this._pFragmentCode += "mov " + alphaReg + ", " + this._pSharedRegisters.shadedTarget + ".w\n";
                }

                for (var i = 0; i < numMethods; ++i) {
                    method = methods[i].method;
                    data = methods[i].data;

                    this._pVertexCode += method.iGetVertexCode(data, this._pRegisterCache);

                    if (data.needsGlobalVertexPos || data.needsGlobalFragmentPos)
                        this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);

                    this._pFragmentCode += method.iGetFragmentCode(data, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                    if (data.needsNormals)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);

                    if (data.needsView)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._preserveAlpha) {
                    this._pFragmentCode += "mov " + this._pSharedRegisters.shadedTarget + ".w, " + alphaReg + "\n";

                    this._pRegisterCache.removeFragmentTempUsage(alphaReg);
                }

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pVertexCode += this._pMethodSetup._iColorTransformMethod.iGetVertexCode(this._pMethodSetup._iColorTransformMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iColorTransformMethod.iGetFragmentCode(this._pMethodSetup._iColorTransformMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "lightProbeDiffuseIndices", {
                /**
                * Indices for the light probe diffuse textures.
                */
                get: function () {
                    return this._pLightProbeDiffuseIndices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "lightProbeSpecularIndices", {
                /**
                * Indices for the light probe specular textures.
                */
                get: function () {
                    return this._pLightProbeSpecularIndices;
                },
                enumerable: true,
                configurable: true
            });
            return ShaderCompiler;
        })();
        materials.ShaderCompiler = ShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away3d.arcane;
        /**
        * SuperShaderCompiler is a compiler that generates shaders that perform both lighting and "effects" through methods.
        * This is used by the single-pass materials.
        */
        var SuperShaderCompiler = (function (_super) {
            __extends(SuperShaderCompiler, _super);
            /**
            * Creates a new SuperShaderCompiler object.
            * @param profile The compatibility profile used by the renderer.
            */
            function SuperShaderCompiler(profile) {
                _super.call(this, profile);
            }
            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pInitLightData = function () {
                _super.prototype.pInitLightData.call(this);

                this._pointLightRegisters = new Array(this._pNumPointLights * 3); //Vector.<ShaderRegisterElement>(_numPointLights*3, true);
                this._dirLightRegisters = new Array(this._pNumDirectionalLights * 3); //Vector.<ShaderRegisterElement>(_numDirectionalLights*3, true);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCalculateDependencies = function () {
                _super.prototype.pCalculateDependencies.call(this);
                this._pDependencyCounter.addWorldSpaceDependencies(true);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileNormalCode = function () {
                var normalMatrix = new Array(3);

                this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pDependencyCounter.normalDependencies);

                if (this._pMethodSetup._iNormalMethod.iHasOutput && !this._pMethodSetup._iNormalMethod.iTangentSpace) {
                    this._pVertexCode += this._pMethodSetup._iNormalMethod.iGetVertexCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                    return;
                }

                this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();

                normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
                normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
                normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();

                this._pRegisterCache.getFreeVertexConstant();
                this._pSceneNormalMatrixIndex = normalMatrix[0].index * 4;

                if (this._pMethodSetup._iNormalMethod.iHasOutput) {
                    // tangent stream required
                    this.compileTangentVertexCode(normalMatrix);
                    this.compileTangentNormalMapFragmentCode();
                } else {
                    // TODO: AGAL <> GLSL
                    //*
                    this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.animatedNormal + ".w	\n";

                    this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalVarying + "\n" + "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w		\n";

                    if (this._pDependencyCounter.tangentDependencies > 0) {
                        this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                        this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;
                        this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();

                        this._pVertexCode += "mov " + this._pSharedRegisters.tangentVarying + ", " + this._pSharedRegisters.tangentInput + "\n";
                    }
                    //*/
                }

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedNormal);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCreateNormalRegisters = function () {
                if (this._pDependencyCounter.normalDependencies > 0) {
                    this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pNormalBufferIndex = this._pSharedRegisters.normalInput.index;
                    this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);
                    this._pAnimatableAttributes.push(this._pSharedRegisters.normalInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedNormal.toString());
                }

                if (this._pMethodSetup._iNormalMethod.iHasOutput) {
                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;

                    this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);

                    this._pAnimatableAttributes.push(this._pSharedRegisters.tangentInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedTangent.toString());
                }
            };

            /**
            * Compiles the vertex shader code for tangent-space normal maps.
            * @param matrix The register containing the scene transformation matrix for normals.
            */
            SuperShaderCompiler.prototype.compileTangentVertexCode = function (matrix) {
                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.bitangentVarying = this._pRegisterCache.getFreeVarying();
                var temp = this._pRegisterCache.getFreeVertexVectorTemp();

                //TODO: AGAL <> GLSL
                this._pVertexCode += "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + matrix[0] + "\n" + "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + temp + "\n";

                this._pVertexCode += "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedTangent + ", " + matrix[0] + "\n" + "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + temp + "\n";

                this._pVertexCode += "mov " + this._pSharedRegisters.tangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".x  \n" + "mov " + this._pSharedRegisters.tangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".x  \n" + "mov " + this._pSharedRegisters.tangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".y  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".y  \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "mov " + this._pSharedRegisters.normalVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".z  \n" + "mov " + this._pSharedRegisters.normalVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".z  \n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" + "crs " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + this._pSharedRegisters.tangentVarying + ".y, " + temp + ".x    \n" + "mov " + this._pSharedRegisters.bitangentVarying + ".y, " + temp + ".y  \n" + "mov " + this._pSharedRegisters.normalVarying + ".y, " + temp + ".z    \n";

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedTangent);
            };

            /**
            * Compiles the fragment shader code for tangent-space normal maps.
            */
            SuperShaderCompiler.prototype.compileTangentNormalMapFragmentCode = function () {
                var t;
                var b;
                var n;

                t = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(t, 1);
                b = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(b, 1);
                n = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(n, 1);

                //TODO: AGAL <> GLSL
                this._pFragmentCode += "nrm " + t + ".xyz, " + this._pSharedRegisters.tangentVarying + "\n" + "mov " + t + ".w, " + this._pSharedRegisters.tangentVarying + ".w	\n" + "nrm " + b + ".xyz, " + this._pSharedRegisters.bitangentVarying + "\n" + "nrm " + n + ".xyz, " + this._pSharedRegisters.normalVarying + "\n";

                var temp = this._pRegisterCache.getFreeFragmentVectorTemp();

                this._pRegisterCache.addFragmentTempUsages(temp, 1);

                //TODO: AGAL <> GLSL
                this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, temp) + "m33 " + this._pSharedRegisters.normalFragment + ".xyz, " + temp + ", " + t + "	\n" + "mov " + this._pSharedRegisters.normalFragment + ".w,   " + this._pSharedRegisters.normalVarying + ".w			\n";

                this._pRegisterCache.removeFragmentTempUsage(temp);

                if (this._pMethodSetup._iNormalMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iNormalMethodVO.needsGlobalVertexPos || this._pMethodSetup._iNormalMethodVO.needsGlobalFragmentPos) {
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }

                this._pRegisterCache.removeFragmentTempUsage(b);
                this._pRegisterCache.removeFragmentTempUsage(t);
                this._pRegisterCache.removeFragmentTempUsage(n);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileViewDirCode = function () {
                var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();

                this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pDependencyCounter.viewDirDependencies);

                this._pCameraPositionIndex = cameraPositionReg.index * 4;

                //TODO: AGAL <> GLSL
                this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment + ".xyz, " + this._pSharedRegisters.viewDirVarying + "\n" + "mov " + this._pSharedRegisters.viewDirFragment + ".w,   " + this._pSharedRegisters.viewDirVarying + ".w 		\n";

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileLightingCode = function () {
                var shadowReg;

                this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);

                this._pVertexCode += this._pMethodSetup._iDiffuseMethod.iGetVertexCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);

                if (this._usingSpecularMethod) {
                    this._pVertexCode += this._pMethodSetup._iSpecularMethod.iGetVertexCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                }

                if (this.pUsesLights()) {
                    this.initLightRegisters();
                    this.compileDirectionalLightCode();
                    this.compilePointLightCode();
                }

                if (this.pUsesProbes()) {
                    this.compileLightProbeCode();
                }

                // only need to create and reserve _shadedTargetReg here, no earlier?
                this._pVertexCode += this._pMethodSetup._iAmbientMethod.iGetVertexCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iAmbientMethod.iGetFragmentCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pMethodSetup._iAmbientMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iAmbientMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iShadowMethod) {
                    this._pVertexCode += this._pMethodSetup._iShadowMethod.iGetVertexCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache);

                    // using normal to contain shadow data if available is perhaps risky :s
                    // todo: improve compilation with lifetime analysis so this isn't necessary?
                    if (this._pDependencyCounter.normalDependencies == 0) {
                        shadowReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                        this._pRegisterCache.addFragmentTempUsages(shadowReg, 1);
                    } else {
                        shadowReg = this._pSharedRegisters.normalFragment;
                    }

                    this._pMethodSetup._iDiffuseMethod.iShadowRegister = shadowReg;
                    this._pFragmentCode += this._pMethodSetup._iShadowMethod.iGetFragmentCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache, shadowReg);
                }

                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pAlphaPremultiplied) {
                    //TODO: AGAL <> GLSL
                    this._pFragmentCode += "add " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "div " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ".w\n" + "sub " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "sat " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + "\n";
                }

                // resolve other dependencies as well?
                if (this._pMethodSetup._iDiffuseMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iDiffuseMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._usingSpecularMethod) {
                    this._pMethodSetup._iSpecularMethod.iShadowRegister = shadowReg;
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                    if (this._pMethodSetup._iSpecularMethodVO.needsNormals) {
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                    }

                    if (this._pMethodSetup._iSpecularMethodVO.needsView) {
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                    }
                }
            };

            /**
            * Initializes the registers containing the lighting data.
            */
            SuperShaderCompiler.prototype.initLightRegisters = function () {
                // init these first so we're sure they're in sequence
                var i, len;

                len = this._dirLightRegisters.length;

                for (i = 0; i < len; ++i) {
                    this._dirLightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._dirLightRegisters[i].index * 4;
                    }
                }

                len = this._pointLightRegisters.length;

                for (i = 0; i < len; ++i) {
                    this._pointLightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._pointLightRegisters[i].index * 4;
                    }
                }
            };

            SuperShaderCompiler.prototype.compileDirectionalLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightDirReg;
                var regIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumDirectionalLights; ++i) {
                    lightDirReg = this._dirLightRegisters[regIndex++];

                    diffuseColorReg = this._dirLightRegisters[regIndex++];

                    specularColorReg = this._dirLightRegisters[regIndex++];

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }
                }
            };

            SuperShaderCompiler.prototype.compilePointLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightPosReg;
                var lightDirReg;
                var regIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();

                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumPointLights; ++i) {
                    lightPosReg = this._pointLightRegisters[regIndex++];
                    diffuseColorReg = this._pointLightRegisters[regIndex++];
                    specularColorReg = this._pointLightRegisters[regIndex++];
                    lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                    this._pRegisterCache.addFragmentTempUsages(lightDirReg, 1);

                    // calculate attenuation
                    this._pFragmentCode += "sub " + lightDirReg + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVarying + "\n" + "dp3 " + lightDirReg + ".w, " + lightDirReg + ", " + lightDirReg + "\n" + "sub " + lightDirReg + ".w, " + lightDirReg + ".w, " + diffuseColorReg + ".w\n" + "mul " + lightDirReg + ".w, " + lightDirReg + ".w, " + specularColorReg + ".w\n" + "sat " + lightDirReg + ".w, " + lightDirReg + ".w\n" + "sub " + lightDirReg + ".w, " + lightPosReg + ".w, " + lightDirReg + ".w\n" + "nrm " + lightDirReg + ".xyz, " + lightDirReg + "\n";

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = lightPosReg.index * 4;
                    }

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    this._pRegisterCache.removeFragmentTempUsage(lightDirReg);
                }
            };

            SuperShaderCompiler.prototype.compileLightProbeCode = function () {
                var weightReg;
                var weightComponents = [".x", ".y", ".z", ".w"];
                var weightRegisters = new Array();
                var i;
                var texReg;
                var addSpec = this._usingSpecularMethod && this.pUsesProbesForSpecular();
                var addDiff = this.pUsesProbesForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                if (addDiff) {
                    this._pLightProbeDiffuseIndices = new Array(); //Vector.<uint>();
                }

                if (addSpec) {
                    this._pLightProbeSpecularIndices = new Array(); //Vector.<uint>();
                }

                for (i = 0; i < this._pNumProbeRegisters; ++i) {
                    weightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (i == 0) {
                        this._pProbeWeightsIndex = weightRegisters[i].index * 4;
                    }
                }

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];

                    if (addDiff) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeDiffuseIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iDiffuseMethodVO, texReg, weightReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeSpecularIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iSpecularMethodVO, texReg, weightReg, this._pRegisterCache);
                    }
                }
            };
            return SuperShaderCompiler;
        })(materials.ShaderCompiler);
        materials.SuperShaderCompiler = SuperShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    (function (materials) {
        /**
        * Enumeration class for defining which lighting types affect the specific material
        * lighting component (diffuse and specular). This can be useful if, for example, you
        * want to use light probes for diffuse global lighting, but want specular reflections from
        * traditional light sources without those affecting the diffuse light.
        *
        * @see away3d.materials.ColorMaterial.diffuseLightSources
        * @see away3d.materials.ColorMaterial.specularLightSources
        * @see away3d.materials.TextureMaterial.diffuseLightSources
        * @see away3d.materials.TextureMaterial.specularLightSources
        */
        var LightSources = (function () {
            function LightSources() {
            }
            LightSources.LIGHTS = 0x01;

            LightSources.PROBES = 0x02;

            LightSources.ALL = 0x03;
            return LightSources;
        })();
        materials.LightSources = LightSources;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var BlendMode = away.base.BlendMode;

        var ContextGLCompareMode = away.stagegl.ContextGLCompareMode;
        var Event = away.events.Event;

        var AssetType = away.library.AssetType;
        var Delegate = away.utils.Delegate;

        var DepthMapPass = away.materials.DepthMapPass;
        var DistanceMapPass = away.materials.DistanceMapPass;

        /**
        * MaterialBase forms an abstract base class for any material.
        * A material consists of several passes, each of which constitutes at least one render call. Several passes could
        * be used for special effects (render lighting for many lights in several passes, render an outline in a separate
        * pass) or to provide additional render-to-texture passes (rendering diffuse light to texture for texture-space
        * subsurface scattering, or rendering a depth map for specialized self-shadowing).
        *
        * Away3D provides default materials trough SinglePassMaterialBase and MultiPassMaterialBase, which use modular
        * methods to build the shader code. MaterialBase can be extended to build specific and high-performant custom
        * shaders, or entire new material frameworks.
        */
        var MaterialBase = (function (_super) {
            __extends(MaterialBase, _super);
            /**
            * Creates a new MaterialBase object.
            */
            function MaterialBase() {
                _super.call(this);
                /**
                * An id for this material used to sort the renderables by shader program, which reduces Program state changes.
                *
                * @private
                */
                this._iMaterialId = 0;
                /**
                * An id for this material used to sort the renderables by shader program, which reduces Program state changes.
                *
                * @private
                */
                this._iRenderOrderId = 0;
                this._bothSides = false;
                this._pBlendMode = BlendMode.NORMAL;
                this._numPasses = 0;
                this._pMipmap = false;
                this._smooth = true;
                this._repeat = false;
                this._pDepthCompareMode = ContextGLCompareMode.LESS_EQUAL;
                this._pHeight = 1;
                this._pWidth = 1;

                this._iMaterialId = Number(this.id);

                this._owners = new Array();
                this._passes = new Array();
                this._pDepthPass = new DepthMapPass();
                this._pDistancePass = new DistanceMapPass();

                this._onPassChangeDelegate = Delegate.create(this, this.onPassChange);
                this._onDepthPassChangeDelegate = Delegate.create(this, this.onDepthPassChange);
                this._onDistancePassChangeDelegate = Delegate.create(this, this.onDistancePassChange);

                this._pDepthPass.addEventListener(Event.CHANGE, this._onDepthPassChangeDelegate);
                this._pDistancePass.addEventListener(Event.CHANGE, this._onDistancePassChangeDelegate);

                this.alphaPremultiplied = false; //TODO: work out why this is different for WebGL
            }
            Object.defineProperty(MaterialBase.prototype, "assetType", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return AssetType.MATERIAL;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialBase.prototype, "height", {
                /**
                *
                */
                get: function () {
                    return this._pHeight;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialBase.prototype, "lightPicker", {
                /**
                * The light picker used by the material to provide lights to the material if it supports lighting.
                *
                * @see LightPickerBase
                * @see StaticLightPicker
                */
                get: function () {
                    return this._pLightPicker;
                },
                set: function (value) {
                    this.setLightPicker(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setLightPicker = function (value) {
                if (value != this._pLightPicker) {
                    this._pLightPicker = value;
                    var len = this._passes.length;

                    for (var i = 0; i < len; ++i)
                        this._passes[i].lightPicker = this._pLightPicker;
                }
            };

            Object.defineProperty(MaterialBase.prototype, "mipmap", {
                /**
                * Indicates whether or not any used textures should use mipmapping. Defaults to true.
                */
                get: function () {
                    return this._pMipmap;
                },
                set: function (value) {
                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setMipMap = function (value) {
                this._pMipmap = value;

                for (var i = 0; i < this._numPasses; ++i)
                    this._passes[i].mipmap = value;
            };

            Object.defineProperty(MaterialBase.prototype, "smooth", {
                /**
                * Indicates whether or not any used textures should use smoothing.
                */
                get: function () {
                    return this._smooth;
                },
                set: function (value) {
                    this._smooth = value;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].smooth = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "depthCompareMode", {
                /**
                * The depth compare mode used to render the renderables using this material.
                *
                * @see away.stagegl.ContextGLCompareMode
                */
                get: function () {
                    return this._pDepthCompareMode;
                },
                set: function (value) {
                    this.setDepthCompareMode(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setDepthCompareMode = function (value) {
                this._pDepthCompareMode = value;
            };

            Object.defineProperty(MaterialBase.prototype, "repeat", {
                /**
                * Indicates whether or not any used textures should be tiled. If set to false, texture samples are clamped to
                * the texture's borders when the uv coordinates are outside the [0, 1] interval.
                */
                get: function () {
                    return this._repeat;
                },
                set: function (value) {
                    this._repeat = value;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].repeat = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Cleans up resources owned by the material, including passes. Textures are not owned by the material since they
            * could be used by other materials and will not be disposed.
            */
            MaterialBase.prototype.dispose = function () {
                var i;

                for (i = 0; i < this._numPasses; ++i)
                    this._passes[i].dispose();

                this._pDepthPass.dispose();
                this._pDistancePass.dispose();

                this._pDepthPass.removeEventListener(Event.CHANGE, this._onDepthPassChangeDelegate);
                this._pDistancePass.removeEventListener(Event.CHANGE, this._onDistancePassChangeDelegate);
            };

            Object.defineProperty(MaterialBase.prototype, "bothSides", {
                /**
                * Defines whether or not the material should cull triangles facing away from the camera.
                */
                get: function () {
                    return this._bothSides;
                },
                set: function (value) {
                    this._bothSides = value;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].bothSides = value;

                    this._pDepthPass.bothSides = value;
                    this._pDistancePass.bothSides = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "blendMode", {
                /**
                * The blend mode to use when drawing this renderable. The following blend modes are supported:
                * <ul>
                * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
                * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
                * <li>BlendMode.MULTIPLY</li>
                * <li>BlendMode.ADD</li>
                * <li>BlendMode.ALPHA</li>
                * </ul>
                */
                get: function () {
                    return this.getBlendMode();
                },
                set: function (value) {
                    this.setBlendMode(value);
                },
                enumerable: true,
                configurable: true
            });

            MaterialBase.prototype.getBlendMode = function () {
                return this._pBlendMode;
            };


            MaterialBase.prototype.setBlendMode = function (value) {
                this._pBlendMode = value;
            };

            Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
                /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied. Toggle this if you are seeing black halos around your
                * blended alpha edges.
                */
                get: function () {
                    return this._alphaPremultiplied;
                },
                set: function (value) {
                    this._alphaPremultiplied = value;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].alphaPremultiplied = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "requiresBlending", {
                /**
                * Indicates whether or not the material requires alpha blending during rendering.
                */
                get: function () {
                    return this.getRequiresBlending();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialBase.prototype, "width", {
                /**
                *
                */
                get: function () {
                    return this._pWidth;
                },
                enumerable: true,
                configurable: true
            });

            MaterialBase.prototype.getRequiresBlending = function () {
                return this._pBlendMode != away.base.BlendMode.NORMAL;
            };

            Object.defineProperty(MaterialBase.prototype, "_iNumPasses", {
                /**
                * The amount of passes used by the material.
                *
                * @private
                */
                get: function () {
                    return this._numPasses;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates that the depth pass uses transparency testing to discard pixels.
            *
            * @private
            */
            MaterialBase.prototype.iHasDepthAlphaThreshold = function () {
                return this._pDepthPass.alphaThreshold > 0;
            };

            /**
            * Sets the render state for the depth pass that is independent of the rendered object. Used when rendering
            * depth or distances (fe: shadow maps, depth pre-pass).
            *
            * @param stageGL The StageGL used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @param distanceBased Whether or not the depth pass or distance pass should be activated. The distance pass
            * is required for shadow cube maps.
            *
            * @internal
            */
            MaterialBase.prototype.iActivateForDepth = function (stageGL, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                this._distanceBasedDepthRender = distanceBased;

                if (distanceBased)
                    this._pDistancePass.iActivate(stageGL, camera);
                else
                    this._pDepthPass.iActivate(stageGL, camera);
            };

            /**
            * Clears the render state for the depth pass.
            *
            * @param stageGL The StageGL used for rendering.
            *
            * @internal
            */
            MaterialBase.prototype.iDeactivateForDepth = function (stageGL) {
                if (this._distanceBasedDepthRender)
                    this._pDistancePass.iDeactivate(stageGL);
                else
                    this._pDepthPass.iDeactivate(stageGL);
            };

            /**
            * Renders a renderable using the depth pass.
            *
            * @param renderable The RenderableBase instance that needs to be rendered.
            * @param stageGL The StageGL used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
            * camera.viewProjection as it includes the scaling factors when rendering to textures.
            *
            * @internal
            */
            MaterialBase.prototype.iRenderDepth = function (renderable, stageGL, camera, viewProjection) {
                if (this._distanceBasedDepthRender) {
                    if (renderable.materialOwner.animator)
                        this._pDistancePass.iUpdateAnimationState(renderable, stageGL, camera);

                    this._pDistancePass.iRender(renderable, stageGL, camera, viewProjection);
                } else {
                    if (renderable.materialOwner.animator)
                        this._pDepthPass.iUpdateAnimationState(renderable, stageGL, camera);

                    this._pDepthPass.iRender(renderable, stageGL, camera, viewProjection);
                }
            };

            //*/
            /**
            * Indicates whether or not the pass with the given index renders to texture or not.
            * @param index The index of the pass.
            * @return True if the pass renders to texture, false otherwise.
            *
            * @internal
            */
            MaterialBase.prototype.iPassRendersToTexture = function (index) {
                return this._passes[index].renderToTexture;
            };

            /**
            * Sets the render state for a pass that is independent of the rendered object. This needs to be called before
            * calling renderPass. Before activating a pass, the previously used pass needs to be deactivated.
            * @param index The index of the pass to activate.
            * @param stageGL The StageGL object which is currently used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @private
            */
            MaterialBase.prototype.iActivatePass = function (index, stageGL, camera) {
                this._passes[index].iActivate(stageGL, camera);
            };

            /**
            * Clears the render state for a pass. This needs to be called before activating another pass.
            * @param index The index of the pass to deactivate.
            * @param stageGL The StageGL used for rendering
            *
            * @internal
            */
            MaterialBase.prototype.iDeactivatePass = function (index, stageGL) {
                this._passes[index].iDeactivate(stageGL);
            };

            /**
            * Renders the current pass. Before calling renderPass, activatePass needs to be called with the same index.
            * @param index The index of the pass used to render the renderable.
            * @param renderable The RenderableBase object to draw.
            * @param stageGL The StageGL object used for rendering.
            * @param entityCollector The EntityCollector object that contains the visible scene data.
            * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
            * camera.viewProjection as it includes the scaling factors when rendering to textures.
            *
            * @internal
            */
            MaterialBase.prototype.iRenderPass = function (index, renderable, stageGL, entityCollector, viewProjection) {
                if (this._pLightPicker)
                    this._pLightPicker.collectLights(renderable, entityCollector);

                var pass = this._passes[index];

                if (renderable.materialOwner.animator)
                    pass.iUpdateAnimationState(renderable, stageGL, entityCollector.camera);

                pass.iRender(renderable, stageGL, entityCollector.camera, viewProjection);
            };

            //
            // MATERIAL MANAGEMENT
            //
            /**
            * Mark an IMaterialOwner as owner of this material.
            * Assures we're not using the same material across renderables with different animations, since the
            * Programs depend on animation. This method needs to be called when a material is assigned.
            *
            * @param owner The IMaterialOwner that had this material assigned
            *
            * @internal
            */
            MaterialBase.prototype.iAddOwner = function (owner) {
                this._owners.push(owner);

                var animationSet;
                var animator = owner.animator;

                if (animator)
                    animationSet = animator.animationSet;

                if (owner.animator) {
                    if (this._animationSet && animationSet != this._animationSet) {
                        throw new Error("A Material instance cannot be shared across material owners with different animation sets");
                    } else {
                        if (this._animationSet != animationSet) {
                            this._animationSet = animationSet;

                            for (var i = 0; i < this._numPasses; ++i)
                                this._passes[i].animationSet = this._animationSet;

                            this._pDepthPass.animationSet = this._animationSet;
                            this._pDistancePass.animationSet = this._animationSet;

                            this.iInvalidatePasses(null);
                        }
                    }
                }
            };

            /**
            * Removes an IMaterialOwner as owner.
            * @param owner
            *
            * @internal
            */
            MaterialBase.prototype.iRemoveOwner = function (owner) {
                this._owners.splice(this._owners.indexOf(owner), 1);

                if (this._owners.length == 0) {
                    this._animationSet = null;

                    for (var i = 0; i < this._numPasses; ++i)
                        this._passes[i].animationSet = this._animationSet;

                    this._pDepthPass.animationSet = this._animationSet;
                    this._pDistancePass.animationSet = this._animationSet;
                    this.iInvalidatePasses(null);
                }
            };

            Object.defineProperty(MaterialBase.prototype, "iOwners", {
                /**
                * A list of the IMaterialOwners that use this material
                *
                * @private
                */
                get: function () {
                    return this._owners;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Performs any processing that needs to occur before any of its passes are used.
            *
            * @private
            */
            MaterialBase.prototype.iUpdateMaterial = function (context) {
                //throw new away.errors.AbstractMethodError();
            };

            /**
            * Deactivates the last pass of the material.
            *
            * @private
            */
            MaterialBase.prototype.iDeactivate = function (stageGL) {
                this._passes[this._numPasses - 1].iDeactivate(stageGL);
            };

            /**
            * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
            * @param triggerPass The pass triggering the invalidation, if any. This is passed to prevent invalidating the
            * triggering pass, which would result in an infinite loop.
            *
            * @private
            */
            MaterialBase.prototype.iInvalidatePasses = function (triggerPass) {
                var owner;
                var animator;

                var l;
                var c;

                this._pDepthPass.iInvalidateShaderProgram();
                this._pDistancePass.iInvalidateShaderProgram();

                // test if the depth and distance passes support animating the animation set in the vertex shader
                // if any object using this material fails to support accelerated animations for any of the passes,
                // we should do everything on cpu (otherwise we have the cost of both gpu + cpu animations)
                if (this._animationSet) {
                    this._animationSet.resetGPUCompatibility();

                    l = this._owners.length;

                    for (c = 0; c < l; c++) {
                        owner = this._owners[c];
                        animator = owner.animator;

                        if (animator) {
                            animator.testGPUCompatibility(this._pDepthPass);
                            animator.testGPUCompatibility(this._pDistancePass);
                        }
                    }
                }

                for (var i = 0; i < this._numPasses; ++i) {
                    // only invalidate the pass if it wasn't the triggering pass
                    if (this._passes[i] != triggerPass)
                        this._passes[i].iInvalidateShaderProgram(false);

                    // test if animation will be able to run on gpu BEFORE compiling materials
                    // test if the pass supports animating the animation set in the vertex shader
                    // if any object using this material fails to support accelerated animations for any of the passes,
                    // we should do everything on cpu (otherwise we have the cost of both gpu + cpu animations)
                    if (this._animationSet) {
                        l = this._owners.length;

                        for (c = 0; c < l; c++) {
                            owner = this._owners[c];
                            animator = owner.animator;

                            if (animator)
                                animator.testGPUCompatibility(this._passes[i]);
                        }
                    }
                }
            };

            /**
            * Removes a pass from the material.
            * @param pass The pass to be removed.
            */
            MaterialBase.prototype.pRemovePass = function (pass) {
                this._passes.splice(this._passes.indexOf(pass), 1);
                --this._numPasses;
            };

            /**
            * Removes all passes from the material
            */
            MaterialBase.prototype.pClearPasses = function () {
                for (var i = 0; i < this._numPasses; ++i)
                    this._passes[i].removeEventListener(Event.CHANGE, this._onPassChangeDelegate);

                this._passes.length = 0;
                this._numPasses = 0;
            };

            /**
            * Adds a pass to the material
            * @param pass
            */
            MaterialBase.prototype.pAddPass = function (pass) {
                this._passes[this._numPasses++] = pass;

                pass.animationSet = this._animationSet;
                pass.alphaPremultiplied = this._alphaPremultiplied;
                pass.mipmap = this._pMipmap;
                pass.smooth = this._smooth;
                pass.repeat = this._repeat;
                pass.lightPicker = this._pLightPicker;
                pass.bothSides = this._bothSides;
                pass.addEventListener(Event.CHANGE, this._onPassChangeDelegate);

                this.iInvalidatePasses(null);
            };

            /**
            * Listener for when a pass's shader code changes. It recalculates the render order id.
            */
            MaterialBase.prototype.onPassChange = function (event) {
                var mult = 1;
                var ids;
                var len;

                this._iRenderOrderId = 0;

                for (var i = 0; i < this._numPasses; ++i) {
                    ids = this._passes[i]._iProgramids;
                    len = ids.length;

                    for (var j = 0; j < len; ++j) {
                        if (ids[j] != -1) {
                            this._iRenderOrderId += mult * ids[j];
                            j = len;
                        }
                    }

                    mult *= 1000;
                }
            };

            /**
            * Listener for when the distance pass's shader code changes. It recalculates the depth pass id.
            */
            MaterialBase.prototype.onDistancePassChange = function (event) {
                var ids = this._pDistancePass._iProgramids;
                var len = ids.length;

                this._iDepthPassId = 0;

                for (var j = 0; j < len; ++j) {
                    if (ids[j] != -1) {
                        this._iDepthPassId += ids[j];
                        j = len;
                    }
                }
            };

            /**
            * Listener for when the depth pass's shader code changes. It recalculates the depth pass id.
            */
            MaterialBase.prototype.onDepthPassChange = function (event) {
                var ids = this._pDepthPass._iProgramids;
                var len = ids.length;

                this._iDepthPassId = 0;

                for (var j = 0; j < len; ++j) {
                    if (ids[j] != -1) {
                        this._iDepthPassId += ids[j];
                        j = len;
                    }
                }
            };
            return MaterialBase;
        })(away.library.NamedAssetBase);
        materials.MaterialBase = MaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * SinglePassMaterialBase forms an abstract base class for the default single-pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var SinglePassMaterialBase = (function (_super) {
            __extends(SinglePassMaterialBase, _super);
            /**
            * Creates a new SinglePassMaterialBase object.
            */
            function SinglePassMaterialBase() {
                _super.call(this);
                this._alphaBlending = false;

                this.pAddPass(this._pScreenPass = new materials.SuperShaderPass(this));
            }
            Object.defineProperty(SinglePassMaterialBase.prototype, "enableLightFallOff", {
                /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                get: function () {
                    return this._pScreenPass.enableLightFallOff;
                },
                set: function (value) {
                    this._pScreenPass.enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "alphaThreshold", {
                /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                get: function () {
                    return this._pScreenPass.diffuseMethod.alphaThreshold;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.alphaThreshold = value;

                    this._pDepthPass.alphaThreshold = value;
                    this._pDistancePass.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "blendMode", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    _super.prototype.setBlendMode.call(this, value);
                    this._pScreenPass.setBlendMode((this._pBlendMode == away.base.BlendMode.NORMAL) && this.requiresBlending ? away.base.BlendMode.LAYER : this._pBlendMode);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SinglePassMaterialBase.prototype, "depthCompareMode", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    this._pDepthCompareMode = value;
                    this._pScreenPass.depthCompareMode = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SinglePassMaterialBase.prototype.iActivateForDepth = function (stageGL, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                if (distanceBased) {
                    this._pDistancePass.alphaMask = this._pScreenPass.diffuseMethod.texture;
                } else {
                    this._pDepthPass.alphaMask = this._pScreenPass.diffuseMethod.texture;
                }

                _super.prototype.iActivateForDepth.call(this, stageGL, camera, distanceBased);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "specularLightSources", {
                /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                get: function () {
                    return this._pScreenPass.specularLightSources;
                },
                set: function (value) {
                    this._pScreenPass.specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "diffuseLightSources", {
                /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                get: function () {
                    return this._pScreenPass.diffuseLightSources;
                },
                set: function (value) {
                    this._pScreenPass.diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "requiresBlending", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this.getRequiresBlending();
                },
                enumerable: true,
                configurable: true
            });

            SinglePassMaterialBase.prototype.getRequiresBlending = function () {
                var ct = this._pScreenPass.colorTransform;

                if (ct) {
                    return (this._pBlendMode != away.base.BlendMode.NORMAL) || this._alphaBlending || (ct.alphaMultiplier < 1);
                }
                return (this._pBlendMode != away.base.BlendMode.NORMAL) || this._alphaBlending;
                //return super.getRequiresBlending() || this._alphaBlending || ( this._pScreenPass.colorTransform && this._pScreenPass.colorTransform.alphaMultiplier < 1);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "colorTransform", {
                /**
                * The ColorTransform object to transform the colour of the material with. Defaults to null.
                */
                get: function () {
                    return this._pScreenPass.colorTransform;
                },
                set: function (value) {
                    this.setColorTransform(value);
                },
                enumerable: true,
                configurable: true
            });


            SinglePassMaterialBase.prototype.setColorTransform = function (value) {
                this._pScreenPass.colorTransform = value;
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "ambientMethod", {
                /**
                * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
                */
                get: function () {
                    return this._pScreenPass.ambientMethod;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "shadowMethod", {
                /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                get: function () {
                    return this._pScreenPass.shadowMethod;
                },
                set: function (value) {
                    this._pScreenPass.shadowMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "diffuseMethod", {
                /**
                * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
                */
                get: function () {
                    return this._pScreenPass.diffuseMethod;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "normalMethod", {
                /**
                * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
                */
                get: function () {
                    return this._pScreenPass.normalMethod;
                },
                set: function (value) {
                    this._pScreenPass.normalMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularMethod", {
                /**
                * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
                */
                get: function () {
                    return this._pScreenPass.specularMethod;
                },
                set: function (value) {
                    this._pScreenPass.specularMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            SinglePassMaterialBase.prototype.addMethod = function (method) {
                this._pScreenPass.addMethod(method);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "numMethods", {
                /**
                * The number of "effect" methods added to the material.
                */
                get: function () {
                    return this._pScreenPass.numMethods;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            SinglePassMaterialBase.prototype.hasMethod = function (method) {
                return this._pScreenPass.hasMethod(method);
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            SinglePassMaterialBase.prototype.getMethodAt = function (index) {
                return this._pScreenPass.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            SinglePassMaterialBase.prototype.addMethodAt = function (method, index) {
                this._pScreenPass.addMethodAt(method, index);
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            SinglePassMaterialBase.prototype.removeMethod = function (method) {
                this._pScreenPass.removeMethod(method);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "mipmap", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    if (this._pMipmap == value)
                        return;

                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SinglePassMaterialBase.prototype, "normalMap", {
                /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                get: function () {
                    return this._pScreenPass.normalMap;
                },
                set: function (value) {
                    this._pScreenPass.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularMap", {
                /**
                * A specular map that defines the strength of specular reflections for each texel in the red channel,
                * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
                * specular and gloss maps from grayscale images, but correctly authored images are preferred.
                */
                get: function () {
                    return this._pScreenPass.specularMethod.texture;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod) {
                        this._pScreenPass.specularMethod.texture = value;
                    } else {
                        throw new away.errors.Error("No specular method was set to assign the specularGlossMap to");
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "gloss", {
                /**
                * The glossiness of the material (sharpness of the specular highlight).
                */
                get: function () {
                    return this._pScreenPass.specularMethod ? this._pScreenPass.specularMethod.gloss : 0;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod)
                        this._pScreenPass.specularMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "ambient", {
                /**
                * The strength of the ambient reflection.
                */
                get: function () {
                    return this._pScreenPass.ambientMethod.ambient;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specular", {
                /**
                * The overall strength of the specular reflection.
                */
                get: function () {
                    return this._pScreenPass.specularMethod ? this._pScreenPass.specularMethod.specular : 0;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod)
                        this._pScreenPass.specularMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "ambientColor", {
                /**
                * The colour of the ambient reflection.
                */
                get: function () {
                    return this._pScreenPass.ambientMethod.ambientColor;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularColor", {
                /**
                * The colour of the specular reflection.
                */
                get: function () {
                    return this._pScreenPass.specularMethod.specularColor;
                },
                set: function (value) {
                    this._pScreenPass.specularMethod.specularColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "alphaBlending", {
                /**
                * Indicates whether or not the material has transparency. If binary transparency is sufficient, for
                * example when using textures of foliage, consider using alphaThreshold instead.
                */
                get: function () {
                    return this._alphaBlending;
                },
                set: function (value) {
                    this._alphaBlending = value;
                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.base.BlendMode.NORMAL && this.requiresBlending ? away.base.BlendMode.LAYER : this.getBlendMode());
                    this._pScreenPass.preserveAlpha = this.requiresBlending;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SinglePassMaterialBase.prototype.iUpdateMaterial = function (context) {
                if (this._pScreenPass._iPassesDirty) {
                    this.pClearPasses();

                    if (this._pScreenPass._iPasses) {
                        var len = this._pScreenPass._iPasses.length;

                        for (var i = 0; i < len; ++i) {
                            this.pAddPass(this._pScreenPass._iPasses[i]);
                        }
                    }

                    this.pAddPass(this._pScreenPass);
                    this._pScreenPass._iPassesDirty = false;
                }
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "lightPicker", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    _super.prototype.setLightPicker.call(this, value);
                    this._pScreenPass.lightPicker = value;
                },
                enumerable: true,
                configurable: true
            });
            return SinglePassMaterialBase;
        })(materials.MaterialBase);
        materials.SinglePassMaterialBase = SinglePassMaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        var Delegate = away.utils.Delegate;

        /**
        * MultiPassMaterialBase forms an abstract base class for the default multi-pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var MultiPassMaterialBase = (function (_super) {
            __extends(MultiPassMaterialBase, _super);
            /**
            * Creates a new MultiPassMaterialBase object.
            */
            function MultiPassMaterialBase() {
                _super.call(this);
                this._alphaThreshold = 0;
                this._specularLightSources = 0x01;
                this._diffuseLightSources = 0x03;
                this._ambientMethod = new materials.AmbientBasicMethod();
                this._diffuseMethod = new materials.DiffuseBasicMethod();
                this._normalMethod = new materials.NormalBasicMethod();
                this._specularMethod = new materials.SpecularBasicMethod();
                this._screenPassesInvalid = true;
                this._enableLightFallOff = true;

                this._onLightChangeDelegate = Delegate.create(this, this.onLightsChange);
            }
            Object.defineProperty(MultiPassMaterialBase.prototype, "enableLightFallOff", {
                /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                get: function () {
                    return this._enableLightFallOff;
                },
                set: function (value) {
                    if (this._enableLightFallOff != value)
                        this.pInvalidateScreenPasses();

                    this._enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "alphaThreshold", {
                /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                get: function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    this._alphaThreshold = value;
                    this._diffuseMethod.alphaThreshold = value;
                    this._pDepthPass.alphaThreshold = value;
                    this._pDistancePass.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "depthCompareMode", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    _super.prototype.setDepthCompareMode.call(this, value);
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "blendMode", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    _super.prototype.setBlendMode.call(this, value);
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iActivateForDepth = function (stageGL, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                if (distanceBased)
                    this._pDistancePass.alphaMask = this._diffuseMethod.texture;
                else
                    this._pDepthPass.alphaMask = this._diffuseMethod.texture;

                _super.prototype.iActivateForDepth.call(this, stageGL, camera, distanceBased);
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "specularLightSources", {
                /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                get: function () {
                    return this._specularLightSources;
                },
                set: function (value) {
                    this._specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "diffuseLightSources", {
                /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                get: function () {
                    return this._diffuseLightSources;
                },
                set: function (value) {
                    this._diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "lightPicker", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    if (this._pLightPicker)
                        this._pLightPicker.removeEventListener(away.events.Event.CHANGE, this._onLightChangeDelegate);

                    _super.prototype.setLightPicker.call(this, value);

                    if (this._pLightPicker)
                        this._pLightPicker.addEventListener(away.events.Event.CHANGE, this._onLightChangeDelegate);

                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "requiresBlending", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "ambientMethod", {
                /**
                * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
                */
                get: function () {
                    return this._ambientMethod;
                },
                set: function (value) {
                    value.copyFrom(this._ambientMethod);
                    this._ambientMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "shadowMethod", {
                /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                get: function () {
                    return this._shadowMethod;
                },
                set: function (value) {
                    if (value && this._shadowMethod)
                        value.copyFrom(this._shadowMethod);

                    this._shadowMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "diffuseMethod", {
                /**
                * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
                */
                get: function () {
                    return this._diffuseMethod;
                },
                set: function (value) {
                    value.copyFrom(this._diffuseMethod);
                    this._diffuseMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularMethod", {
                /**
                * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
                */
                get: function () {
                    return this._specularMethod;
                },
                set: function (value) {
                    if (value && this._specularMethod)
                        value.copyFrom(this._specularMethod);

                    this._specularMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "normalMethod", {
                /**
                * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
                */
                get: function () {
                    return this._normalMethod;
                },
                set: function (value) {
                    value.copyFrom(this._normalMethod);
                    this._normalMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            MultiPassMaterialBase.prototype.addMethod = function (method) {
                if (this._pEffectsPass == null)
                    this._pEffectsPass = new materials.SuperShaderPass(this);

                this._pEffectsPass.addMethod(method);
                this.pInvalidateScreenPasses();
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "numMethods", {
                /**
                * The number of "effect" methods added to the material.
                */
                get: function () {
                    return this._pEffectsPass ? this._pEffectsPass.numMethods : 0;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            MultiPassMaterialBase.prototype.hasMethod = function (method) {
                return this._pEffectsPass ? this._pEffectsPass.hasMethod(method) : false;
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            MultiPassMaterialBase.prototype.getMethodAt = function (index) {
                return this._pEffectsPass.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            MultiPassMaterialBase.prototype.addMethodAt = function (method, index) {
                if (this._pEffectsPass == null)
                    this._pEffectsPass = new materials.SuperShaderPass(this);

                this._pEffectsPass.addMethodAt(method, index);
                this.pInvalidateScreenPasses();
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            MultiPassMaterialBase.prototype.removeMethod = function (method) {
                if (this._pEffectsPass)
                    return;

                this._pEffectsPass.removeMethod(method);

                // reconsider
                if (this._pEffectsPass.numMethods == 0)
                    this.pInvalidateScreenPasses();
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "mipmap", {
                /**
                * @inheritDoc
                */
                set: function (value) {
                    if (this._pMipmap == value)
                        return;

                    _super.prototype.setMipMap.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "normalMap", {
                /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                get: function () {
                    return this._normalMethod.normalMap;
                },
                set: function (value) {
                    this._normalMethod.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularMap", {
                /**
                * A specular map that defines the strength of specular reflections for each texel in the red channel,
                * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
                * specular and gloss maps from grayscale images, but correctly authored images are preferred.
                */
                get: function () {
                    return this._specularMethod.texture;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.texture = value;
                    else
                        throw new Error("No specular method was set to assign the specularGlossMap to");
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "gloss", {
                /**
                * The glossiness of the material (sharpness of the specular highlight).
                */
                get: function () {
                    return this._specularMethod ? this._specularMethod.gloss : 0;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "ambient", {
                /**
                * The strength of the ambient reflection.
                */
                get: function () {
                    return this._ambientMethod.ambient;
                },
                set: function (value) {
                    this._ambientMethod.ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specular", {
                /**
                * The overall strength of the specular reflection.
                */
                get: function () {
                    return this._specularMethod ? this._specularMethod.specular : 0;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "ambientColor", {
                /**
                * The colour of the ambient reflection.
                */
                get: function () {
                    return this._ambientMethod.ambientColor;
                },
                set: function (value) {
                    this._ambientMethod.ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularColor", {
                /**
                * The colour of the specular reflection.
                */
                get: function () {
                    return this._specularMethod.specularColor;
                },
                set: function (value) {
                    this._specularMethod.specularColor = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iUpdateMaterial = function (context) {
                var passesInvalid;

                if (this._screenPassesInvalid) {
                    this.pUpdateScreenPasses();
                    passesInvalid = true;
                }

                if (passesInvalid || this.isAnyScreenPassInvalid()) {
                    this.pClearPasses();

                    this.addChildPassesFor(this._casterLightPass);

                    if (this._nonCasterLightPasses) {
                        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
                            this.addChildPassesFor(this._nonCasterLightPasses[i]);
                    }

                    this.addChildPassesFor(this._pEffectsPass);

                    this.addScreenPass(this._casterLightPass);

                    if (this._nonCasterLightPasses) {
                        for (i = 0; i < this._nonCasterLightPasses.length; ++i) {
                            this.addScreenPass(this._nonCasterLightPasses[i]);
                        }
                    }

                    this.addScreenPass(this._pEffectsPass);
                }
            };

            /**
            * Adds a compiled pass that renders to the screen.
            * @param pass The pass to be added.
            */
            MultiPassMaterialBase.prototype.addScreenPass = function (pass) {
                if (pass) {
                    this.pAddPass(pass);
                    pass._iPassesDirty = false;
                }
            };

            /**
            * Tests if any pass that renders to the screen is invalid. This would trigger a new setup of the multiple passes.
            * @return
            */
            MultiPassMaterialBase.prototype.isAnyScreenPassInvalid = function () {
                if ((this._casterLightPass && this._casterLightPass._iPassesDirty) || (this._pEffectsPass && this._pEffectsPass._iPassesDirty))
                    return true;

                if (this._nonCasterLightPasses) {
                    for (var i = 0; i < this._nonCasterLightPasses.length; ++i) {
                        if (this._nonCasterLightPasses[i]._iPassesDirty)
                            return true;
                    }
                }

                return false;
            };

            /**
            * Adds any additional passes on which the given pass is dependent.
            * @param pass The pass that my need additional passes.
            */
            MultiPassMaterialBase.prototype.addChildPassesFor = function (pass) {
                if (!pass)
                    return;

                if (pass._iPasses) {
                    var len = pass._iPasses.length;

                    for (var i = 0; i < len; ++i) {
                        this.pAddPass(pass._iPasses[i]);
                    }
                }
            };

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iActivatePass = function (index, stageGL, camera) {
                if (index == 0)
                    stageGL.contextGL.setBlendFactors(away.stagegl.ContextGLBlendFactor.ONE, away.stagegl.ContextGLBlendFactor.ZERO);

                _super.prototype.iActivatePass.call(this, index, stageGL, camera);
            };

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iDeactivate = function (stageGL) {
                _super.prototype.iDeactivate.call(this, stageGL);

                stageGL.contextGL.setBlendFactors(away.stagegl.ContextGLBlendFactor.ONE, away.stagegl.ContextGLBlendFactor.ZERO);
            };

            /**
            * Updates screen passes when they were found to be invalid.
            */
            MultiPassMaterialBase.prototype.pUpdateScreenPasses = function () {
                this.initPasses();
                this.setBlendAndCompareModes();

                this._screenPassesInvalid = false;
            };

            /**
            * Initializes all the passes and their dependent passes.
            */
            MultiPassMaterialBase.prototype.initPasses = function () {
                // let the effects pass handle everything if there are no lights,
                // or when there are effect methods applied after shading.
                if (this.numLights == 0 || this.numMethods > 0)
                    this.initEffectsPass();
                else if (this._pEffectsPass && this.numMethods == 0)
                    this.removeEffectsPass();

                // only use a caster light pass if shadows need to be rendered
                if (this._shadowMethod)
                    this.initCasterLightPass();
                else
                    this.removeCasterLightPass();

                // only use non caster light passes if there are lights that don't cast
                if (this.numNonCasters > 0)
                    this.initNonCasterLightPasses();
                else
                    this.removeNonCasterLightPasses();
            };

            /**
            * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.
            */
            MultiPassMaterialBase.prototype.setBlendAndCompareModes = function () {
                var forceSeparateMVP = (this._casterLightPass || this._pEffectsPass);

                // caster light pass is always first if it exists, hence it uses normal blending
                if (this._casterLightPass) {
                    this._casterLightPass.setBlendMode(away.base.BlendMode.NORMAL);
                    this._casterLightPass.depthCompareMode = this._pDepthCompareMode;
                    this._casterLightPass.forceSeparateMVP = forceSeparateMVP;
                }

                if (this._nonCasterLightPasses) {
                    var firstAdditiveIndex = 0;

                    // if there's no caster light pass, the first non caster light pass will be the first
                    // and should use normal blending
                    if (!this._casterLightPass) {
                        this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;
                        this._nonCasterLightPasses[0].setBlendMode(away.base.BlendMode.NORMAL);
                        this._nonCasterLightPasses[0].depthCompareMode = this._pDepthCompareMode;
                        firstAdditiveIndex = 1;
                    }

                    for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {
                        this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;
                        this._nonCasterLightPasses[i].setBlendMode(away.base.BlendMode.ADD);
                        this._nonCasterLightPasses[i].depthCompareMode = away.stagegl.ContextGLCompareMode.LESS_EQUAL;
                    }
                }

                if (this._casterLightPass || this._nonCasterLightPasses) {
                    // there are light passes, so this should be blended in
                    if (this._pEffectsPass) {
                        this._pEffectsPass.iIgnoreLights = true;
                        this._pEffectsPass.depthCompareMode = away.stagegl.ContextGLCompareMode.LESS_EQUAL;
                        this._pEffectsPass.setBlendMode(away.base.BlendMode.LAYER);
                        this._pEffectsPass.forceSeparateMVP = forceSeparateMVP;
                    }
                } else if (this._pEffectsPass) {
                    // effects pass is the only pass, so it should just blend normally
                    this._pEffectsPass.iIgnoreLights = false;
                    this._pEffectsPass.depthCompareMode = this._pDepthCompareMode;

                    this.depthCompareMode;

                    this._pEffectsPass.setBlendMode(away.base.BlendMode.NORMAL);
                    this._pEffectsPass.forceSeparateMVP = false;
                }
            };

            MultiPassMaterialBase.prototype.initCasterLightPass = function () {
                if (this._casterLightPass == null)
                    this._casterLightPass = new materials.ShadowCasterPass(this);

                this._casterLightPass.diffuseMethod = null;
                this._casterLightPass.ambientMethod = null;
                this._casterLightPass.normalMethod = null;
                this._casterLightPass.specularMethod = null;
                this._casterLightPass.shadowMethod = null;
                this._casterLightPass.enableLightFallOff = this._enableLightFallOff;
                this._casterLightPass.lightPicker = new materials.StaticLightPicker([this._shadowMethod.castingLight]);
                this._casterLightPass.shadowMethod = this._shadowMethod;
                this._casterLightPass.diffuseMethod = this._diffuseMethod;
                this._casterLightPass.ambientMethod = this._ambientMethod;
                this._casterLightPass.normalMethod = this._normalMethod;
                this._casterLightPass.specularMethod = this._specularMethod;
                this._casterLightPass.diffuseLightSources = this._diffuseLightSources;
                this._casterLightPass.specularLightSources = this._specularLightSources;
            };

            MultiPassMaterialBase.prototype.removeCasterLightPass = function () {
                if (!this._casterLightPass)
                    return;

                this._casterLightPass.dispose();
                this.pRemovePass(this._casterLightPass);
                this._casterLightPass = null;
            };

            MultiPassMaterialBase.prototype.initNonCasterLightPasses = function () {
                this.removeNonCasterLightPasses();
                var pass;
                var numDirLights = this._pLightPicker.numDirectionalLights;
                var numPointLights = this._pLightPicker.numPointLights;
                var numLightProbes = this._pLightPicker.numLightProbes;
                var dirLightOffset = 0;
                var pointLightOffset = 0;
                var probeOffset = 0;

                if (!this._casterLightPass) {
                    numDirLights += this._pLightPicker.numCastingDirectionalLights;
                    numPointLights += this._pLightPicker.numCastingPointLights;
                }

                this._nonCasterLightPasses = new Array();

                while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {
                    pass = new materials.LightingPass(this);
                    pass.enableLightFallOff = this._enableLightFallOff;
                    pass.includeCasters = this._shadowMethod == null;
                    pass.directionalLightsOffset = dirLightOffset;
                    pass.pointLightsOffset = pointLightOffset;
                    pass.lightProbesOffset = probeOffset;
                    pass.diffuseMethod = null;
                    pass.ambientMethod = null;
                    pass.normalMethod = null;
                    pass.specularMethod = null;
                    pass.lightPicker = this._pLightPicker;
                    pass.diffuseMethod = this._diffuseMethod;
                    pass.ambientMethod = this._ambientMethod;
                    pass.normalMethod = this._normalMethod;
                    pass.specularMethod = this._specularMethod;
                    pass.diffuseLightSources = this._diffuseLightSources;
                    pass.specularLightSources = this._specularLightSources;
                    this._nonCasterLightPasses.push(pass);

                    dirLightOffset += pass.iNumDirectionalLights;
                    pointLightOffset += pass.iNumPointLights;
                    probeOffset += pass.iNumLightProbes;
                }
            };

            MultiPassMaterialBase.prototype.removeNonCasterLightPasses = function () {
                if (!this._nonCasterLightPasses)
                    return;

                for (var i = 0; i < this._nonCasterLightPasses.length; ++i) {
                    this.pRemovePass(this._nonCasterLightPasses[i]);
                    this._nonCasterLightPasses[i].dispose();
                }
                this._nonCasterLightPasses = null;
            };

            MultiPassMaterialBase.prototype.removeEffectsPass = function () {
                if (this._pEffectsPass.diffuseMethod != this._diffuseMethod)
                    this._pEffectsPass.diffuseMethod.dispose();

                this.pRemovePass(this._pEffectsPass);
                this._pEffectsPass.dispose();
                this._pEffectsPass = null;
            };

            MultiPassMaterialBase.prototype.initEffectsPass = function () {
                if (this._pEffectsPass == null)
                    this._pEffectsPass = new materials.SuperShaderPass(this);

                this._pEffectsPass.enableLightFallOff = this._enableLightFallOff;
                if (this.numLights == 0) {
                    this._pEffectsPass.diffuseMethod = null;
                    this._pEffectsPass.diffuseMethod = this._diffuseMethod;
                } else {
                    this._pEffectsPass.diffuseMethod = null;
                    this._pEffectsPass.diffuseMethod = new materials.DiffuseBasicMethod();
                    this._pEffectsPass.diffuseMethod.diffuseColor = 0x000000;
                    this._pEffectsPass.diffuseMethod.diffuseAlpha = 0;
                }

                this._pEffectsPass.preserveAlpha = false;
                this._pEffectsPass.normalMethod = null;
                this._pEffectsPass.normalMethod = this._normalMethod;

                return this._pEffectsPass;
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "numLights", {
                /**
                * The maximum total number of lights provided by the light picker.
                */
                get: function () {
                    return this._pLightPicker ? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights + this._pLightPicker.numCastingDirectionalLights + this._pLightPicker.numCastingPointLights : 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "numNonCasters", {
                /**
                * The amount of lights that don't cast shadows.
                */
                get: function () {
                    return this._pLightPicker ? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights : 0;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Flags that the screen passes have become invalid.
            */
            MultiPassMaterialBase.prototype.pInvalidateScreenPasses = function () {
                this._screenPassesInvalid = true;
            };

            /**
            * Called when the light picker's configuration changed.
            */
            MultiPassMaterialBase.prototype.onLightsChange = function (event) {
                this.pInvalidateScreenPasses();
            };
            return MultiPassMaterialBase;
        })(materials.MaterialBase);
        materials.MultiPassMaterialBase = MultiPassMaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * TextureMultiPassMaterial is a multi-pass material that uses a texture to define the surface's diffuse reflection colour (albedo).
        */
        var TextureMultiPassMaterial = (function (_super) {
            __extends(TextureMultiPassMaterial, _super);
            /**
            * Creates a new TextureMultiPassMaterial.
            * @param texture The texture used for the material's albedo color.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.
            */
            function TextureMultiPassMaterial(texture, smooth, repeat, mipmap) {
                if (typeof texture === "undefined") { texture = null; }
                if (typeof smooth === "undefined") { smooth = true; }
                if (typeof repeat === "undefined") { repeat = false; }
                if (typeof mipmap === "undefined") { mipmap = false; }
                _super.call(this);
                this._animateUVs = false;
                this.texture = texture;
                this.smooth = smooth;
                this.repeat = repeat;
                this.mipmap = mipmap;
            }
            Object.defineProperty(TextureMultiPassMaterial.prototype, "animateUVs", {
                /**
                * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
                */
                get: function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMultiPassMaterial.prototype, "texture", {
                /**
                * The texture object to use for the albedo colour.
                */
                get: function () {
                    return this.diffuseMethod.texture;
                },
                set: function (value) {
                    this.diffuseMethod.texture = value;

                    if (value) {
                        this._pHeight = value.height;
                        this._pWidth = value.width;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMultiPassMaterial.prototype, "ambientTexture", {
                /**
                * The texture object to use for the ambient colour.
                */
                get: function () {
                    return this.ambientMethod.texture;
                },
                set: function (value) {
                    this.ambientMethod.texture = value;
                    this.diffuseMethod.iUseAmbientTexture = (value != null);
                },
                enumerable: true,
                configurable: true
            });


            TextureMultiPassMaterial.prototype.pUpdateScreenPasses = function () {
                _super.prototype.pUpdateScreenPasses.call(this);

                if (this._pEffectsPass)
                    this._pEffectsPass.animateUVs = this._animateUVs;
            };
            return TextureMultiPassMaterial;
        })(materials.MultiPassMaterialBase);
        materials.TextureMultiPassMaterial = TextureMultiPassMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ColorMultiPassMaterial is a multi-pass material that uses a flat color as the surface's diffuse reflection value.
        */
        var ColorMultiPassMaterial = (function (_super) {
            __extends(ColorMultiPassMaterial, _super);
            /**
            * Creates a new ColorMultiPassMaterial object.
            *
            * @param color The material's diffuse surface color.
            */
            function ColorMultiPassMaterial(color) {
                if (typeof color === "undefined") { color = 0xcccccc; }
                _super.call(this);
                this.color = color;
            }
            Object.defineProperty(ColorMultiPassMaterial.prototype, "color", {
                /**
                * The diffuse reflectivity color of the surface.
                */
                get: function () {
                    return this.diffuseMethod.diffuseColor;
                },
                set: function (value) {
                    this.diffuseMethod.diffuseColor = value;
                },
                enumerable: true,
                configurable: true
            });

            return ColorMultiPassMaterial;
        })(materials.MultiPassMaterialBase);
        materials.ColorMultiPassMaterial = ColorMultiPassMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away3d.*;
        //import away3d.textures.*;
        //import flash.display.*;
        //import flash.geom.*;
        //use namespace arcane;
        /**
        * TextureMaterial is a single-pass material that uses a texture to define the surface's diffuse reflection colour (albedo).
        */
        var TextureMaterial = (function (_super) {
            __extends(TextureMaterial, _super);
            /**
            * Creates a new TextureMaterial.
            * @param texture The texture used for the material's albedo color.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.
            */
            function TextureMaterial(texture, smooth, repeat, mipmap) {
                if (typeof texture === "undefined") { texture = null; }
                if (typeof smooth === "undefined") { smooth = true; }
                if (typeof repeat === "undefined") { repeat = false; }
                if (typeof mipmap === "undefined") { mipmap = false; }
                _super.call(this);

                this.texture = texture;

                this.smooth = smooth;
                this.repeat = repeat;
                this.mipmap = mipmap;
            }
            Object.defineProperty(TextureMaterial.prototype, "animateUVs", {
                /**
                * Specifies whether or not the UV coordinates should be animated using IRenderable's uvTransform matrix.
                *
                * @see IRenderable.uvTransform
                */
                get: function () {
                    return this._pScreenPass.animateUVs;
                },
                set: function (value) {
                    this._pScreenPass.animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "alpha", {
                /**
                * The alpha of the surface.
                */
                get: function () {
                    return this._pScreenPass.colorTransform ? this._pScreenPass.colorTransform.alphaMultiplier : 1;
                },
                set: function (value) {
                    if (value > 1)
                        value = 1;
                    else if (value < 0)
                        value = 0;

                    if (this.colorTransform == null) {
                        //colorTransform ||= new ColorTransform();
                        this.colorTransform = new away.geom.ColorTransform();
                    }

                    this.colorTransform.alphaMultiplier = value;

                    this._pScreenPass.preserveAlpha = this.getRequiresBlending();

                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.base.BlendMode.NORMAL && this.getRequiresBlending() ? away.base.BlendMode.LAYER : this.getBlendMode());
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "texture", {
                /**
                * The texture object to use for the albedo colour.
                */
                get: function () {
                    return this._pScreenPass.diffuseMethod.texture;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.texture = value;

                    if (value) {
                        this._pHeight = value.height;
                        this._pWidth = value.width;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "ambientTexture", {
                /**
                * The texture object to use for the ambient colour.
                */
                get: function () {
                    return this._pScreenPass.ambientMethod.texture;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.texture = value;
                    this._pScreenPass.diffuseMethod.iUseAmbientTexture = !(value == null); // Boolean( value ) //<-------- TODO: Check this works as expected
                },
                enumerable: true,
                configurable: true
            });

            return TextureMaterial;
        })(materials.SinglePassMaterialBase);
        materials.TextureMaterial = TextureMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * ColorMaterial is a single-pass material that uses a flat color as the surface's diffuse reflection value.
        */
        var ColorMaterial = (function (_super) {
            __extends(ColorMaterial, _super);
            /**
            * Creates a new ColorMaterial object.
            * @param color The material's diffuse surface color.
            * @param alpha The material's surface alpha.
            */
            function ColorMaterial(color, alpha) {
                if (typeof color === "undefined") { color = 0xcccccc; }
                if (typeof alpha === "undefined") { alpha = 1; }
                _super.call(this);
                this._diffuseAlpha = 1;

                this.color = color;
                this.alpha = alpha;
            }
            Object.defineProperty(ColorMaterial.prototype, "alpha", {
                /**
                * The alpha of the surface.
                */
                get: function () {
                    return this._pScreenPass.diffuseMethod.diffuseAlpha;
                },
                set: function (value) {
                    if (value > 1) {
                        value = 1;
                    } else if (value < 0) {
                        value = 0;
                    }

                    this._pScreenPass.diffuseMethod.diffuseAlpha = this._diffuseAlpha = value;
                    this._pScreenPass.preserveAlpha = this.requiresBlending;
                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.base.BlendMode.NORMAL && this.requiresBlending ? away.base.BlendMode.LAYER : this.getBlendMode());
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ColorMaterial.prototype, "color", {
                /**
                * The diffuse reflectivity color of the surface.
                */
                get: function () {
                    return this._pScreenPass.diffuseMethod.diffuseColor;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.diffuseColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ColorMaterial.prototype, "requiresBlending", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return this.getRequiresBlending() || this._diffuseAlpha < 1;
                },
                enumerable: true,
                configurable: true
            });
            return ColorMaterial;
        })(materials.SinglePassMaterialBase);
        materials.ColorMaterial = ColorMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        //import away3d.arcane;
        /**
        * LightingShaderCompiler is a ShaderCompiler that generates code for passes performing shading only (no effect passes)
        */
        var LightingShaderCompiler = (function (_super) {
            __extends(LightingShaderCompiler, _super);
            //use namespace arcane;
            /**
            * Create a new LightingShaderCompiler object.
            * @param profile The compatibility profile of the renderer.
            */
            function LightingShaderCompiler(profile) {
                _super.call(this, profile);
            }
            Object.defineProperty(LightingShaderCompiler.prototype, "lightVertexConstantIndex", {
                /**
                * The starting index if the vertex constant to which light data needs to be uploaded.
                */
                get: function () {
                    return this._lightVertexConstantIndex;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pInitRegisterIndices = function () {
                _super.prototype.pInitRegisterIndices.call(this);
                this._lightVertexConstantIndex = -1;
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCreateNormalRegisters = function () {
                // need to be created FIRST and in this order
                if (this.tangentSpace) {
                    this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);
                    this._pSharedRegisters.bitangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.bitangent, 1);

                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;

                    this._pAnimatableAttributes.push(this._pSharedRegisters.tangentInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedTangent.toString());
                }

                this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
                this._pNormalBufferIndex = this._pSharedRegisters.normalInput.index;

                this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);

                this._pAnimatableAttributes.push(this._pSharedRegisters.normalInput.toString());
                this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedNormal.toString());
            };

            Object.defineProperty(LightingShaderCompiler.prototype, "tangentSpace", {
                /**
                * Indicates whether or not lighting happens in tangent space. This is only the case if no world-space
                * dependencies exist.
                */
                get: function () {
                    return this._pNumLightProbes == 0 && this._pMethodSetup._iNormalMethod.iHasOutput && this._pMethodSetup._iNormalMethod.iTangentSpace;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pInitLightData = function () {
                _super.prototype.pInitLightData.call(this);

                this._pointLightVertexConstants = new Array(this._pNumPointLights);
                this._pointLightFragmentConstants = new Array(this._pNumPointLights * 2);

                if (this.tangentSpace) {
                    this._dirLightVertexConstants = new Array(this._pNumDirectionalLights);
                    this._dirLightFragmentConstants = new Array(this._pNumDirectionalLights * 2);
                } else {
                    this._dirLightFragmentConstants = new Array(this._pNumDirectionalLights * 3);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCalculateDependencies = function () {
                _super.prototype.pCalculateDependencies.call(this);

                if (!this.tangentSpace) {
                    this._pDependencyCounter.addWorldSpaceDependencies(false);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileNormalCode = function () {
                this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pDependencyCounter.normalDependencies);

                if (this._pMethodSetup._iNormalMethod.iHasOutput && !this._pMethodSetup._iNormalMethod.iTangentSpace) {
                    this._pVertexCode += this._pMethodSetup._iNormalMethod.iGetVertexCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                    return;
                }

                if (this.tangentSpace) {
                    this.compileTangentSpaceNormalMapCode();
                } else {
                    var normalMatrix = new Array(3);
                    normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
                    normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
                    normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();

                    this._pRegisterCache.getFreeVertexConstant();

                    this._pSceneNormalMatrixIndex = normalMatrix[0].index * 4;
                    this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();

                    // no output, world space is enough
                    this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.animatedNormal + ".w	\n";

                    this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalVarying + "\n" + "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w		\n";
                }

                if (this._pDependencyCounter.tangentDependencies > 0) {
                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;
                    this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
                }
            };

            /**
            * Generates code to retrieve the tangent space normal from the normal map
            */
            LightingShaderCompiler.prototype.compileTangentSpaceNormalMapCode = function () {
                // normalize normal + tangent vector and generate (approximated) bitangent
                this._pVertexCode += "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + this._pSharedRegisters.animatedNormal + "\n" + "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + this._pSharedRegisters.animatedTangent + "\n";
                this._pVertexCode += "crs " + this._pSharedRegisters.bitangent + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n";

                this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                if (this._pMethodSetup._iNormalMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iNormalMethodVO.needsGlobalFragmentPos || this._pMethodSetup._iNormalMethodVO.needsGlobalVertexPos) {
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileViewDirCode = function () {
                var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();
                this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pDependencyCounter.viewDirDependencies);

                this._pCameraPositionIndex = cameraPositionReg.index * 4;

                if (this.tangentSpace) {
                    var temp = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pVertexCode += "sub " + temp + ", " + cameraPositionReg + ", " + this._pSharedRegisters.localPosition + "\n" + "m33 " + this._pSharedRegisters.viewDirVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + this._pSharedRegisters.viewDirVarying + ".w, " + this._pSharedRegisters.localPosition + ".w\n";
                } else {
                    this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }

                this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment + ".xyz, " + this._pSharedRegisters.viewDirVarying + "\n" + "mov " + this._pSharedRegisters.viewDirFragment + ".w,   " + this._pSharedRegisters.viewDirVarying + ".w 		\n";
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileLightingCode = function () {
                if (this._pMethodSetup._iShadowMethod)
                    this.compileShadowCode();

                this._pMethodSetup._iDiffuseMethod.iShadowRegister = this._shadowRegister;

                this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);

                this._pVertexCode += this._pMethodSetup._iDiffuseMethod.iGetVertexCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);

                if (this._usingSpecularMethod) {
                    this._pVertexCode += this._pMethodSetup._iSpecularMethod.iGetVertexCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                }

                if (this.pUsesLights()) {
                    this.initLightRegisters();
                    this.compileDirectionalLightCode();
                    this.compilePointLightCode();
                }

                if (this.pUsesProbes())
                    this.compileLightProbeCode();

                // only need to create and reserve _shadedTargetReg here, no earlier?
                this._pVertexCode += this._pMethodSetup._iAmbientMethod.iGetVertexCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iAmbientMethod.iGetFragmentCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pMethodSetup._iAmbientMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iAmbientMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pAlphaPremultiplied) {
                    this._pFragmentCode += "add " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "div " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ".w\n" + "sub " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "sat " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + "\n";
                }

                // resolve other dependencies as well?
                if (this._pMethodSetup._iDiffuseMethodVO.needsNormals)
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                if (this._pMethodSetup._iDiffuseMethodVO.needsView)
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);

                if (this._usingSpecularMethod) {
                    this._pMethodSetup._iSpecularMethod.iShadowRegister = this._shadowRegister;
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);
                    if (this._pMethodSetup._iSpecularMethodVO.needsNormals)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                    if (this._pMethodSetup._iSpecularMethodVO.needsView)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iShadowMethod) {
                    this._pRegisterCache.removeFragmentTempUsage(this._shadowRegister);
                }
            };

            /**
            * Provides the code to provide shadow mapping.
            */
            LightingShaderCompiler.prototype.compileShadowCode = function () {
                if (this._pSharedRegisters.normalFragment)
                    this._shadowRegister = this._pSharedRegisters.normalFragment;
                else
                    this._shadowRegister = this._pRegisterCache.getFreeFragmentVectorTemp();

                this._pRegisterCache.addFragmentTempUsages(this._shadowRegister, 1);

                this._pVertexCode += this._pMethodSetup._iShadowMethod.iGetVertexCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iShadowMethod.iGetFragmentCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache, this._shadowRegister);
            };

            /**
            * Initializes constant registers to contain light data.
            */
            LightingShaderCompiler.prototype.initLightRegisters = function () {
                // init these first so we're sure they're in sequence
                var i, len;

                if (this._dirLightVertexConstants) {
                    len = this._dirLightVertexConstants.length;

                    for (i = 0; i < len; ++i) {
                        this._dirLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();

                        if (this._lightVertexConstantIndex == -1) {
                            this._lightVertexConstantIndex = this._dirLightVertexConstants[i].index * 4;
                        }
                    }
                }

                len = this._pointLightVertexConstants.length;
                for (i = 0; i < len; ++i) {
                    this._pointLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();

                    if (this._lightVertexConstantIndex == -1) {
                        this._lightVertexConstantIndex = this._pointLightVertexConstants[i].index * 4;
                    }
                }

                len = this._dirLightFragmentConstants.length;
                for (i = 0; i < len; ++i) {
                    this._dirLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._dirLightFragmentConstants[i].index * 4;
                    }
                }

                len = this._pointLightFragmentConstants.length;

                for (i = 0; i < len; ++i) {
                    this._pointLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._pointLightFragmentConstants[i].index * 4;
                    }
                }
            };

            /**
            * Compiles the shading code for directional lights.
            */
            LightingShaderCompiler.prototype.compileDirectionalLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightDirReg;
                var vertexRegIndex = 0;
                var fragmentRegIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff))
                    return;

                for (var i = 0; i < this._pNumDirectionalLights; ++i) {
                    if (this.tangentSpace) {
                        lightDirReg = this._dirLightVertexConstants[vertexRegIndex++];

                        var lightVarying = this._pRegisterCache.getFreeVarying();

                        this._pVertexCode += "m33 " + lightVarying + ".xyz, " + lightDirReg + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + lightVarying + ".w, " + lightDirReg + ".w\n";

                        lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                        this._pRegisterCache.addVertexTempUsages(lightDirReg, 1);
                        this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
                        this._pFragmentCode += "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
                    } else {
                        lightDirReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    }

                    diffuseColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    specularColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    if (this.tangentSpace)
                        this._pRegisterCache.removeVertexTempUsage(lightDirReg);
                }
            };

            /**
            * Compiles the shading code for point lights.
            */
            LightingShaderCompiler.prototype.compilePointLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightPosReg;
                var lightDirReg;
                var vertexRegIndex = 0;
                var fragmentRegIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumPointLights; ++i) {
                    lightPosReg = this._pointLightVertexConstants[vertexRegIndex++];
                    diffuseColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
                    specularColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
                    lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();

                    this._pRegisterCache.addFragmentTempUsages(lightDirReg, 1);

                    var lightVarying = this._pRegisterCache.getFreeVarying();
                    if (this.tangentSpace) {
                        var temp = this._pRegisterCache.getFreeVertexVectorTemp();
                        this._pVertexCode += "sub " + temp + ", " + lightPosReg + ", " + this._pSharedRegisters.localPosition + "\n" + "m33 " + lightVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + lightVarying + ".w, " + this._pSharedRegisters.localPosition + ".w\n";
                    } else {
                        this._pVertexCode += "sub " + lightVarying + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                    }

                    if (this._pEnableLightFallOff && this._pProfile != "baselineConstrained") {
                        // calculate attenuation
                        this._pFragmentCode += "dp3 " + lightDirReg + ".w, " + lightVarying + ", " + lightVarying + "\n" + "sub " + lightDirReg + ".w, " + lightDirReg + ".w, " + diffuseColorReg + ".w\n" + "mul " + lightDirReg + ".w, " + lightDirReg + ".w, " + specularColorReg + ".w\n" + "sat " + lightDirReg + ".w, " + lightDirReg + ".w\n" + "sub " + lightDirReg + ".w, " + this._pSharedRegisters.commons + ".w, " + lightDirReg + ".w\n" + "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
                    } else {
                        this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" + "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
                    }

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = lightPosReg.index * 4;
                    }

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    this._pRegisterCache.removeFragmentTempUsage(lightDirReg);
                }
            };

            /**
            * Compiles shading code for light probes.
            */
            LightingShaderCompiler.prototype.compileLightProbeCode = function () {
                var weightReg;
                var weightComponents = [".x", ".y", ".z", ".w"];
                var weightRegisters = new Array();
                var i;
                var texReg;
                var addSpec = this._usingSpecularMethod && this.pUsesProbesForSpecular();
                var addDiff = this.pUsesProbesForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                if (addDiff) {
                    this._pLightProbeDiffuseIndices = new Array();
                }
                if (addSpec) {
                    this._pLightProbeSpecularIndices = new Array();
                }

                for (i = 0; i < this._pNumProbeRegisters; ++i) {
                    weightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (i == 0) {
                        this._pProbeWeightsIndex = weightRegisters[i].index * 4;
                    }
                }

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];

                    if (addDiff) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeDiffuseIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iDiffuseMethodVO, texReg, weightReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeSpecularIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iSpecularMethodVO, texReg, weightReg, this._pRegisterCache);
                    }
                }
            };
            return LightingShaderCompiler;
        })(materials.ShaderCompiler);
        materials.LightingShaderCompiler = LightingShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * SegmentMaterial is a material exclusively used to render wireframe objects
        *
        * @see away3d.entities.Lines
        */
        var SegmentMaterial = (function (_super) {
            __extends(SegmentMaterial, _super);
            /**
            * Creates a new SegmentMaterial object.
            *
            * @param thickness The thickness of the wireframe lines.
            */
            function SegmentMaterial(thickness) {
                if (typeof thickness === "undefined") { thickness = 1.25; }
                _super.call(this);

                this.bothSides = true;
                this.pAddPass(this._screenPass = new materials.SegmentPass(thickness));
                this._screenPass.material = this;
            }
            return SegmentMaterial;
        })(materials.MaterialBase);
        materials.SegmentMaterial = SegmentMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (materials) {
        /**
        * SkyboxMaterial is a material exclusively used to render skyboxes
        *
        * @see away3d.primitives.Skybox
        */
        var SkyboxMaterial = (function (_super) {
            __extends(SkyboxMaterial, _super);
            /**
            * Creates a new SkyboxMaterial object.
            * @param cubeMap The CubeMap to use as the skybox.
            */
            function SkyboxMaterial(cubeMap, smooth, repeat, mipmap) {
                if (typeof smooth === "undefined") { smooth = true; }
                if (typeof repeat === "undefined") { repeat = false; }
                if (typeof mipmap === "undefined") { mipmap = false; }
                _super.call(this);

                this._cubeMap = cubeMap;
                this.pAddPass(this._skyboxPass = new materials.SkyboxPass());
                this._skyboxPass.cubeTexture = this._cubeMap;
            }
            Object.defineProperty(SkyboxMaterial.prototype, "cubeMap", {
                /**
                * The cube texture to use as the skybox.
                */
                get: function () {
                    return this._cubeMap;
                },
                set: function (value) {
                    if (value && this._cubeMap && (value.hasMipmaps != this._cubeMap.hasMipmaps || value.format != this._cubeMap.format))
                        this.iInvalidatePasses(null);

                    this._cubeMap = value;
                    this._skyboxPass.cubeTexture = this._cubeMap;
                },
                enumerable: true,
                configurable: true
            });

            return SkyboxMaterial;
        })(materials.MaterialBase);
        materials.SkyboxMaterial = SkyboxMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (utils) {
        var PerspectiveMatrix3D = (function (_super) {
            __extends(PerspectiveMatrix3D, _super);
            function PerspectiveMatrix3D(v) {
                if (typeof v === "undefined") { v = null; }
                _super.call(this, v);
            }
            PerspectiveMatrix3D.prototype.perspectiveFieldOfViewLH = function (fieldOfViewY, aspectRatio, zNear, zFar) {
                var yScale = 1 / Math.tan(fieldOfViewY / 2);
                var xScale = yScale / aspectRatio;
                this.copyRawDataFrom([xScale, 0.0, 0.0, 0.0, 0.0, yScale, 0.0, 0.0, 0.0, 0.0, zFar / (zFar - zNear), 1.0, 0.0, 0.0, (zNear * zFar) / (zNear - zFar), 0.0]);
            };
            return PerspectiveMatrix3D;
        })(away.geom.Matrix3D);
        utils.PerspectiveMatrix3D = PerspectiveMatrix3D;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * ...
        */
        var AnimationRegisterCache = (function (_super) {
            __extends(AnimationRegisterCache, _super);
            function AnimationRegisterCache(profile) {
                _super.call(this, profile);
                this.indexDictionary = new Object();
                this.vertexConstantData = new Array();
                this.fragmentConstantData = new Array();
            }
            AnimationRegisterCache.prototype.reset = function () {
                _super.prototype.reset.call(this);

                this.rotationRegisters = new Array();
                this.positionAttribute = this.getRegisterFromString(this.sourceRegisters[0]);
                this.scaleAndRotateTarget = this.getRegisterFromString(this.targetRegisters[0]);
                this.addVertexTempUsages(this.scaleAndRotateTarget, 1);

                for (var i = 1; i < this.targetRegisters.length; i++) {
                    this.rotationRegisters.push(this.getRegisterFromString(this.targetRegisters[i]));
                    this.addVertexTempUsages(this.rotationRegisters[i - 1], 1);
                }

                this.scaleAndRotateTarget = new ShaderRegisterElement(this.scaleAndRotateTarget.regName, this.scaleAndRotateTarget.index); //only use xyz, w is used as vertexLife

                //allot const register
                this.vertexZeroConst = this.getFreeVertexConstant();
                this.vertexZeroConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 0);
                this.vertexOneConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 1);
                this.vertexTwoConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 2);

                //allot temp register
                this.positionTarget = this.getFreeVertexVectorTemp();
                this.addVertexTempUsages(this.positionTarget, 1);
                this.positionTarget = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index);

                if (this.needVelocity) {
                    this.velocityTarget = this.getFreeVertexVectorTemp();
                    this.addVertexTempUsages(this.velocityTarget, 1);
                    this.velocityTarget = new ShaderRegisterElement(this.velocityTarget.regName, this.velocityTarget.index);
                    this.vertexTime = new ShaderRegisterElement(this.velocityTarget.regName, this.velocityTarget.index, 3);
                    this.vertexLife = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index, 3);
                } else {
                    var tempTime = this.getFreeVertexVectorTemp();
                    this.addVertexTempUsages(tempTime, 1);
                    this.vertexTime = new ShaderRegisterElement(tempTime.regName, tempTime.index, 0);
                    this.vertexLife = new ShaderRegisterElement(tempTime.regName, tempTime.index, 1);
                }
            };

            AnimationRegisterCache.prototype.setUVSourceAndTarget = function (UVAttribute, UVVaring) {
                this.uvVar = this.getRegisterFromString(UVVaring);
                this.uvAttribute = this.getRegisterFromString(UVAttribute);

                //uv action is processed after normal actions,so use offsetTarget as uvTarget
                this.uvTarget = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index);
            };

            AnimationRegisterCache.prototype.setRegisterIndex = function (node, parameterIndex /*int*/ , registerIndex /*int*/ ) {
                //8 should be enough for any node.
                var t = this.indexDictionary[node.id];

                if (t == null)
                    t = this.indexDictionary[node.id] = new Array(8);

                t[parameterIndex] = registerIndex;
            };

            AnimationRegisterCache.prototype.getRegisterIndex = function (node, parameterIndex /*int*/ ) {
                return this.indexDictionary[node.id][parameterIndex];
            };

            AnimationRegisterCache.prototype.getInitCode = function () {
                var len = this.sourceRegisters.length;
                var code = "";
                for (var i = 0; i < len; i++)
                    code += "mov " + this.targetRegisters[i] + "," + this.sourceRegisters[i] + "\n";

                code += "mov " + this.positionTarget + ".xyz," + this.vertexZeroConst.toString() + "\n";

                if (this.needVelocity)
                    code += "mov " + this.velocityTarget + ".xyz," + this.vertexZeroConst.toString() + "\n";

                return code;
            };

            AnimationRegisterCache.prototype.getCombinationCode = function () {
                return "add " + this.scaleAndRotateTarget + ".xyz," + this.scaleAndRotateTarget + ".xyz," + this.positionTarget + ".xyz\n";
            };

            AnimationRegisterCache.prototype.initColorRegisters = function () {
                var code = "";
                if (this.hasColorMulNode) {
                    this.colorMulTarget = this.getFreeVertexVectorTemp();
                    this.addVertexTempUsages(this.colorMulTarget, 1);
                    this.colorMulVary = this.getFreeVarying();
                    code += "mov " + this.colorMulTarget + "," + this.vertexOneConst + "\n";
                }
                if (this.hasColorAddNode) {
                    this.colorAddTarget = this.getFreeVertexVectorTemp();
                    this.addVertexTempUsages(this.colorAddTarget, 1);
                    this.colorAddVary = this.getFreeVarying();
                    code += "mov " + this.colorAddTarget + "," + this.vertexZeroConst + "\n";
                }
                return code;
            };

            AnimationRegisterCache.prototype.getColorPassCode = function () {
                var code = "";
                if (this.needFragmentAnimation && (this.hasColorAddNode || this.hasColorMulNode)) {
                    if (this.hasColorMulNode)
                        code += "mov " + this.colorMulVary + "," + this.colorMulTarget + "\n";
                    if (this.hasColorAddNode)
                        code += "mov " + this.colorAddVary + "," + this.colorAddTarget + "\n";
                }
                return code;
            };

            AnimationRegisterCache.prototype.getColorCombinationCode = function (shadedTarget) {
                var code = "";
                if (this.needFragmentAnimation && (this.hasColorAddNode || this.hasColorMulNode)) {
                    var colorTarget = this.getRegisterFromString(shadedTarget);
                    this.addFragmentTempUsages(colorTarget, 1);
                    if (this.hasColorMulNode)
                        code += "mul " + colorTarget + "," + colorTarget + "," + this.colorMulVary + "\n";
                    if (this.hasColorAddNode)
                        code += "add " + colorTarget + "," + colorTarget + "," + this.colorAddVary + "\n";
                }
                return code;
            };

            AnimationRegisterCache.prototype.getRegisterFromString = function (code) {
                var temp = code.split(/(\d+)/);
                return new ShaderRegisterElement(temp[0], parseInt(temp[1]));
            };

            Object.defineProperty(AnimationRegisterCache.prototype, "numVertexConstant", {
                get: function () {
                    return this._numVertexConstant;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationRegisterCache.prototype, "numFragmentConstant", {
                get: function () {
                    return this._numFragmentConstant;
                },
                enumerable: true,
                configurable: true
            });

            AnimationRegisterCache.prototype.setDataLength = function () {
                this._numVertexConstant = this.numUsedVertexConstants - this.vertexConstantOffset;
                this._numFragmentConstant = this.numUsedFragmentConstants - this.fragmentConstantOffset;
                this.vertexConstantData.length = this._numVertexConstant * 4;
                this.fragmentConstantData.length = this._numFragmentConstant * 4;
            };

            AnimationRegisterCache.prototype.setVertexConst = function (index /*int*/ , x, y, z, w) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof z === "undefined") { z = 0; }
                if (typeof w === "undefined") { w = 0; }
                var _index = (index - this.vertexConstantOffset) * 4;
                this.vertexConstantData[_index++] = x;
                this.vertexConstantData[_index++] = y;
                this.vertexConstantData[_index++] = z;
                this.vertexConstantData[_index] = w;
            };

            AnimationRegisterCache.prototype.setVertexConstFromArray = function (index /*int*/ , data) {
                var _index = (index - this.vertexConstantOffset) * 4;
                for (var i = 0; i < data.length; i++)
                    this.vertexConstantData[_index++] = data[i];
            };

            AnimationRegisterCache.prototype.setVertexConstFromMatrix = function (index /*int*/ , matrix) {
                var rawData = matrix.rawData;
                var _index = (index - this.vertexConstantOffset) * 4;
                this.vertexConstantData[_index++] = rawData[0];
                this.vertexConstantData[_index++] = rawData[4];
                this.vertexConstantData[_index++] = rawData[8];
                this.vertexConstantData[_index++] = rawData[12];
                this.vertexConstantData[_index++] = rawData[1];
                this.vertexConstantData[_index++] = rawData[5];
                this.vertexConstantData[_index++] = rawData[9];
                this.vertexConstantData[_index++] = rawData[13];
                this.vertexConstantData[_index++] = rawData[2];
                this.vertexConstantData[_index++] = rawData[6];
                this.vertexConstantData[_index++] = rawData[10];
                this.vertexConstantData[_index++] = rawData[14];
                this.vertexConstantData[_index++] = rawData[3];
                this.vertexConstantData[_index++] = rawData[7];
                this.vertexConstantData[_index++] = rawData[11];
                this.vertexConstantData[_index] = rawData[15];
            };

            AnimationRegisterCache.prototype.setFragmentConst = function (index /*int*/ , x, y, z, w) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof z === "undefined") { z = 0; }
                if (typeof w === "undefined") { w = 0; }
                var _index = (index - this.fragmentConstantOffset) * 4;
                this.fragmentConstantData[_index++] = x;
                this.fragmentConstantData[_index++] = y;
                this.fragmentConstantData[_index++] = z;
                this.fragmentConstantData[_index] = w;
            };
            return AnimationRegisterCache;
        })(away.materials.ShaderRegisterCache);
        animators.AnimationRegisterCache = AnimationRegisterCache;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * ...
        */
        var AnimationSubGeometry = (function () {
            function AnimationSubGeometry() {
                this._pVertexBuffer = new Array(8);
                this._pBufferContext = new Array(8);
                this._pBufferDirty = new Array(8);
                this.numProcessedVertices = 0;
                this.previousTime = Number.NEGATIVE_INFINITY;
                this.animationParticles = new Array();
                for (var i = 0; i < 8; i++)
                    this._pBufferDirty[i] = true;

                this._iUniqueId = AnimationSubGeometry.SUBGEOM_ID_COUNT++;
            }
            AnimationSubGeometry.prototype.createVertexData = function (numVertices /*uint*/ , totalLenOfOneVertex /*uint*/ ) {
                this._numVertices = numVertices;
                this._totalLenOfOneVertex = totalLenOfOneVertex;
                this._pVertexData = new Array(numVertices * totalLenOfOneVertex);
            };

            //TODO Why does Typescript complain when stageGL type away.base.StageGL is changed to StageGL?
            AnimationSubGeometry.prototype.activateVertexBuffer = function (index /*int*/ , bufferOffset /*int*/ , stageGL, format) {
                var contextIndex = stageGL.stageGLIndex;
                var context = stageGL.contextGL;

                var buffer = this._pVertexBuffer[contextIndex];
                if (!buffer || this._pBufferContext[contextIndex] != context) {
                    buffer = this._pVertexBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, this._totalLenOfOneVertex);
                    this._pBufferContext[contextIndex] = context;
                    this._pBufferDirty[contextIndex] = true;
                }
                if (this._pBufferDirty[contextIndex]) {
                    buffer.uploadFromArray(this._pVertexData, 0, this._numVertices);
                    this._pBufferDirty[contextIndex] = false;
                }
                context.setVertexBufferAt(index, buffer, bufferOffset, format);
            };

            AnimationSubGeometry.prototype.dispose = function () {
                while (this._pVertexBuffer.length) {
                    var vertexBuffer = this._pVertexBuffer.pop();

                    if (vertexBuffer)
                        vertexBuffer.dispose();
                }
            };

            AnimationSubGeometry.prototype.invalidateBuffer = function () {
                for (var i = 0; i < 8; i++)
                    this._pBufferDirty[i] = true;
            };

            Object.defineProperty(AnimationSubGeometry.prototype, "vertexData", {
                get: function () {
                    return this._pVertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSubGeometry.prototype, "numVertices", {
                get: function () {
                    return this._numVertices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSubGeometry.prototype, "totalLenOfOneVertex", {
                get: function () {
                    return this._totalLenOfOneVertex;
                },
                enumerable: true,
                configurable: true
            });
            AnimationSubGeometry.SUBGEOM_ID_COUNT = 0;
            return AnimationSubGeometry;
        })();
        animators.AnimationSubGeometry = AnimationSubGeometry;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ColorSegmentPoint = (function () {
            function ColorSegmentPoint(life, color) {
                //0<life<1
                if (life <= 0 || life >= 1)
                    throw (new Error("life exceeds range (0,1)"));
                this._life = life;
                this._color = color;
            }
            Object.defineProperty(ColorSegmentPoint.prototype, "color", {
                get: function () {
                    return this._color;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ColorSegmentPoint.prototype, "life", {
                get: function () {
                    return this._life;
                },
                enumerable: true,
                configurable: true
            });
            return ColorSegmentPoint;
        })();
        animators.ColorSegmentPoint = ColorSegmentPoint;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;
        var Matrix3D = away.geom.Matrix3D;
        var Quaternion = away.geom.Quaternion;

        /**
        * Contains transformation data for a skeleton joint, used for skeleton animation.
        *
        * @see away.animation.Skeleton
        * @see away.animation.SkeletonJoint
        *
        * todo: support (uniform) scale
        */
        var JointPose = (function () {
            function JointPose() {
                /**
                * The rotation of the pose stored as a quaternion
                */
                this.orientation = new Quaternion();
                /**
                * The translation of the pose
                */
                this.translation = new Vector3D();
            }
            /**
            * Converts the transformation to a Matrix3D representation.
            *
            * @param target An optional target matrix to store the transformation. If not provided, it will create a new instance.
            * @return The transformation matrix of the pose.
            */
            JointPose.prototype.toMatrix3D = function (target) {
                if (typeof target === "undefined") { target = null; }
                if (target == null)
                    target = new Matrix3D();

                this.orientation.toMatrix3D(target);
                target.appendTranslation(this.translation.x, this.translation.y, this.translation.z);
                return target;
            };

            /**
            * Copies the transformation data from a source pose object into the existing pose object.
            *
            * @param pose The source pose to copy from.
            */
            JointPose.prototype.copyFrom = function (pose) {
                var or = pose.orientation;
                var tr = pose.translation;
                this.orientation.x = or.x;
                this.orientation.y = or.y;
                this.orientation.z = or.z;
                this.orientation.w = or.w;
                this.translation.x = tr.x;
                this.translation.y = tr.y;
                this.translation.z = tr.z;
            };
            return JointPose;
        })();
        animators.JointPose = JointPose;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * ...
        */
        var ParticleAnimationData = (function () {
            function ParticleAnimationData(index /*uint*/ , startTime, duration, delay, particle) {
                this.index = index;
                this.startTime = startTime;
                this.totalTime = duration + delay;
                this.duration = duration;
                this.delay = delay;
                this.startVertexIndex = particle.startVertexIndex;
                this.numVertices = particle.numVertices;
            }
            return ParticleAnimationData;
        })();
        animators.ParticleAnimationData = ParticleAnimationData;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ParticleData = (function () {
            function ParticleData() {
            }
            return ParticleData;
        })();
        animators.ParticleData = ParticleData;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * Dynamic class for holding the local properties of a particle, used for processing the static properties
        * of particles in the particle animation set before beginning upload to the GPU.
        */
        var ParticleProperties = (function () {
            function ParticleProperties() {
            }
            return ParticleProperties;
        })();
        animators.ParticleProperties = ParticleProperties;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * Options for setting the properties mode of a particle animation node.
        */
        var ParticlePropertiesMode = (function () {
            function ParticlePropertiesMode() {
            }
            ParticlePropertiesMode.GLOBAL = 0;

            ParticlePropertiesMode.LOCAL_STATIC = 1;

            ParticlePropertiesMode.LOCAL_DYNAMIC = 2;
            return ParticlePropertiesMode;
        })();
        animators.ParticlePropertiesMode = ParticlePropertiesMode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var AssetType = away.library.AssetType;

        /**
        * A Skeleton object is a hierarchical grouping of joint objects that can be used for skeletal animation.
        *
        * @see away.animators.SkeletonJoint
        */
        var Skeleton = (function (_super) {
            __extends(Skeleton, _super);
            /**
            * Creates a new <code>Skeleton</code> object
            */
            function Skeleton() {
                _super.call(this);

                // in the long run, it might be a better idea to not store Joint objects, but keep all data in Vectors, that we can upload easily?
                this.joints = new Array();
            }
            Object.defineProperty(Skeleton.prototype, "numJoints", {
                /**
                * The total number of joints in the skeleton.
                */
                get: function () {
                    return this.joints.length;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the joint object in the skeleton with the given name, otherwise returns a null object.
            *
            * @param jointName The name of the joint object to be found.
            * @return The joint object with the given name.
            *
            * @see #joints
            */
            Skeleton.prototype.jointFromName = function (jointName) {
                var jointIndex = this.jointIndexFromName(jointName);
                if (jointIndex != -1)
                    return this.joints[jointIndex];
                else
                    return null;
            };

            /**
            * Returns the joint index, given the joint name. -1 is returned if the joint name is not found.
            *
            * @param jointName The name of the joint object to be found.
            * @return The index of the joint object in the joints Array
            *
            * @see #joints
            */
            Skeleton.prototype.jointIndexFromName = function (jointName) {
                // this is implemented as a linear search, rather than a possibly
                // more optimal method (Dictionary lookup, for example) because:
                // a) it is assumed that it will be called once for each joint
                // b) it is assumed that it will be called only during load, and not during main loop
                // c) maintaining a dictionary (for safety) would dictate an interface to access SkeletonJoints,
                //    rather than direct array access.  this would be sub-optimal.
                var jointIndex;
                var joint;
                for (var i; i < this.joints.length; i++) {
                    joint = this.joints[i];
                    if (joint.name == jointName)
                        return jointIndex;
                    jointIndex++;
                }

                return -1;
            };

            /**
            * @inheritDoc
            */
            Skeleton.prototype.dispose = function () {
                this.joints.length = 0;
            };

            Object.defineProperty(Skeleton.prototype, "assetType", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return AssetType.SKELETON;
                },
                enumerable: true,
                configurable: true
            });
            return Skeleton;
        })(away.library.NamedAssetBase);
        animators.Skeleton = Skeleton;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * Options for setting the animation mode of a vertex animator object.
        *
        * @see away.animators.VertexAnimator
        */
        var VertexAnimationMode = (function () {
            function VertexAnimationMode() {
            }
            VertexAnimationMode.ADDITIVE = "additive";

            VertexAnimationMode.ABSOLUTE = "absolute";
            return VertexAnimationMode;
        })();
        animators.VertexAnimationMode = VertexAnimationMode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A value obect representing a single joint in a skeleton object.
        *
        * @see away.animators.Skeleton
        */
        var SkeletonJoint = (function () {
            /**
            * Creates a new <code>SkeletonJoint</code> object
            */
            function SkeletonJoint() {
                /**
                * The index of the parent joint in the skeleton's joints vector.
                *
                * @see away.animators.Skeleton#joints
                */
                this.parentIndex = -1;
            }
            return SkeletonJoint;
        })();
        animators.SkeletonJoint = SkeletonJoint;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var AssetType = away.library.AssetType;

        /**
        * A collection of pose objects, determining the pose for an entire skeleton.
        * The <code>jointPoses</code> vector object corresponds to a skeleton's <code>joints</code> vector object, however, there is no
        * reference to a skeleton's instance, since several skeletons can be influenced by the same pose (eg: animation
        * clips are added to any animator with a valid skeleton)
        *
        * @see away.animators.Skeleton
        * @see away.animators.JointPose
        */
        var SkeletonPose = (function (_super) {
            __extends(SkeletonPose, _super);
            /**
            * Creates a new <code>SkeletonPose</code> object.
            */
            function SkeletonPose() {
                _super.call(this);

                this.jointPoses = new Array();
            }
            Object.defineProperty(SkeletonPose.prototype, "numJointPoses", {
                /**
                * The total number of joint poses in the skeleton pose.
                */
                get: function () {
                    return this.jointPoses.length;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonPose.prototype, "assetType", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return AssetType.SKELETON_POSE;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the joint pose object with the given joint name, otherwise returns a null object.
            *
            * @param jointName The name of the joint object whose pose is to be found.
            * @return The pose object with the given joint name.
            */
            SkeletonPose.prototype.jointPoseFromName = function (jointName) {
                var jointPoseIndex = this.jointPoseIndexFromName(jointName);
                if (jointPoseIndex != -1)
                    return this.jointPoses[jointPoseIndex];
                else
                    return null;
            };

            /**
            * Returns the pose index, given the joint name. -1 is returned if the joint name is not found in the pose.
            *
            * @param The name of the joint object whose pose is to be found.
            * @return The index of the pose object in the jointPoses Array
            *
            * @see #jointPoses
            */
            SkeletonPose.prototype.jointPoseIndexFromName = function (jointName) {
                // this is implemented as a linear search, rather than a possibly
                // more optimal method (Dictionary lookup, for example) because:
                // a) it is assumed that it will be called once for each joint
                // b) it is assumed that it will be called only during load, and not during main loop
                // c) maintaining a dictionary (for safety) would dictate an interface to access JointPoses,
                //    rather than direct array access.  this would be sub-optimal.
                var jointPoseIndex;
                var jointPose;
                for (var i; i < this.jointPoses.length; i++) {
                    jointPose = this.jointPoses[i];
                    if (jointPose.name == jointName)
                        return jointPoseIndex;
                    jointPoseIndex++;
                }

                return -1;
            };

            /**
            * Creates a copy of the <code>SkeletonPose</code> object, with a dulpicate of its component joint poses.
            *
            * @return SkeletonPose
            */
            SkeletonPose.prototype.clone = function () {
                var clone = new SkeletonPose();
                var numJointPoses = this.jointPoses.length;
                for (var i = 0; i < numJointPoses; i++) {
                    var cloneJointPose = new animators.JointPose();
                    var thisJointPose = this.jointPoses[i];
                    cloneJointPose.name = thisJointPose.name;
                    cloneJointPose.copyFrom(thisJointPose);
                    clone.jointPoses[i] = cloneJointPose;
                }
                return clone;
            };

            /**
            * @inheritDoc
            */
            SkeletonPose.prototype.dispose = function () {
                this.jointPoses.length = 0;
            };
            return SkeletonPose;
        })(away.library.NamedAssetBase);
        animators.SkeletonPose = SkeletonPose;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * Provides an abstract base class for nodes with time-based animation data in an animation blend tree.
        */
        var AnimationClipNodeBase = (function (_super) {
            __extends(AnimationClipNodeBase, _super);
            /**
            * Creates a new <code>AnimationClipNodeBase</code> object.
            */
            function AnimationClipNodeBase() {
                _super.call(this);
                this._pLooping = true;
                this._pTotalDuration = 0;
                this._pStitchDirty = true;
                this._pStitchFinalFrame = false;
                this._pNumFrames = 0;
                this._pDurations = new Array();
                /*uint*/
                this._pTotalDelta = new away.geom.Vector3D();
                this.fixedFrameRate = true;
            }
            Object.defineProperty(AnimationClipNodeBase.prototype, "looping", {
                /**
                * Determines whether the contents of the animation node have looping characteristics enabled.
                */
                get: function () {
                    return this._pLooping;
                },
                set: function (value) {
                    if (this._pLooping == value)
                        return;

                    this._pLooping = value;

                    this._pStitchDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimationClipNodeBase.prototype, "stitchFinalFrame", {
                /**
                * Defines if looping content blends the final frame of animation data with the first (true) or works on the
                * assumption that both first and last frames are identical (false). Defaults to false.
                */
                get: function () {
                    return this._pStitchFinalFrame;
                },
                set: function (value) {
                    if (this._pStitchFinalFrame == value)
                        return;

                    this._pStitchFinalFrame = value;

                    this._pStitchDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimationClipNodeBase.prototype, "totalDuration", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pTotalDuration;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "totalDelta", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pTotalDelta;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "lastFrame", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pLastFrame;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "durations", {
                /**
                * Returns a vector of time values representing the duration (in milliseconds) of each animation frame in the clip.
                */
                get: function () {
                    return this._pDurations;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the node's final frame stitch state.
            *
            * @see #stitchFinalFrame
            */
            AnimationClipNodeBase.prototype._pUpdateStitch = function () {
                this._pStitchDirty = false;

                this._pLastFrame = (this._pStitchFinalFrame) ? this._pNumFrames : this._pNumFrames - 1;

                this._pTotalDuration = 0;
                this._pTotalDelta.x = 0;
                this._pTotalDelta.y = 0;
                this._pTotalDelta.z = 0;
            };
            return AnimationClipNodeBase;
        })(animators.AnimationNodeBase);
        animators.AnimationClipNodeBase = AnimationClipNodeBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * Provides an abstract base class for particle animation nodes.
        */
        var ParticleNodeBase = (function (_super) {
            __extends(ParticleNodeBase, _super);
            /**
            * Creates a new <code>ParticleNodeBase</code> object.
            *
            * @param               name            Defines the generic name of the particle animation node.
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param               dataLength      Defines the length of the data used by the node when in <code>LOCAL_STATIC</code> mode.
            * @param    [optional] priority        the priority of the particle animation node, used to order the agal generated in a particle animation set. Defaults to 1.
            */
            function ParticleNodeBase(name, mode /*uint*/ , dataLength /*uint*/ , priority) {
                if (typeof priority === "undefined") { priority = 1; }
                _super.call(this);
                this._pDataLength = 3;

                name = name + ParticleNodeBase.MODES[mode];

                this.name = name;
                this._pMode = mode;
                this._priority = priority;
                this._pDataLength = dataLength;

                this._pOneData = new Array(this._pDataLength);
            }
            Object.defineProperty(ParticleNodeBase.prototype, "mode", {
                /**
                * Returns the property mode of the particle animation node. Typically set in the node constructor
                *
                * @see away.animators.ParticlePropertiesMode
                */
                get: function () {
                    return this._pMode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleNodeBase.prototype, "priority", {
                /**
                * Returns the priority of the particle animation node, used to order the agal generated in a particle animation set. Set automatically on instantiation.
                *
                * @see away.animators.ParticleAnimationSet
                * @see #getAGALVertexCode
                */
                get: function () {
                    return this._priority;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleNodeBase.prototype, "dataLength", {
                /**
                * Returns the length of the data used by the node when in <code>LOCAL_STATIC</code> mode. Used to generate the local static data of the particle animation set.
                *
                * @see away.animators.ParticleAnimationSet
                * @see #getAGALVertexCode
                */
                get: function () {
                    return this._pDataLength;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleNodeBase.prototype, "oneData", {
                /**
                * Returns the generated data vector of the node after one particle pass during the generation of all local static data of the particle animation set.
                *
                * @see away.animators.ParticleAnimationSet
                * @see #generatePropertyOfOneParticle
                */
                get: function () {
                    return this._pOneData;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the AGAL code of the particle animation node for use in the vertex shader.
            */
            ParticleNodeBase.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                return "";
            };

            /**
            * Returns the AGAL code of the particle animation node for use in the fragment shader.
            */
            ParticleNodeBase.prototype.getAGALFragmentCode = function (pass, animationRegisterCache) {
                return "";
            };

            /**
            * Returns the AGAL code of the particle animation node for use in the fragment shader when UV coordinates are required.
            */
            ParticleNodeBase.prototype.getAGALUVCode = function (pass, animationRegisterCache) {
                return "";
            };

            /**
            * Called internally by the particle animation set when assigning the set of static properties originally defined by the initParticleFunc of the set.
            *
            * @see away.animators.ParticleAnimationSet#initParticleFunc
            */
            ParticleNodeBase.prototype._iGeneratePropertyOfOneParticle = function (param) {
            };

            /**
            * Called internally by the particle animation set when determining the requirements of the particle animation node AGAL.
            */
            ParticleNodeBase.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
            };
            ParticleNodeBase.GLOBAL = 'Global';
            ParticleNodeBase.LOCAL_STATIC = 'LocalStatic';
            ParticleNodeBase.LOCAL_DYNAMIC = 'LocalDynamic';

            ParticleNodeBase.MODES = {
                0: ParticleNodeBase.GLOBAL,
                1: ParticleNodeBase.LOCAL_STATIC,
                2: ParticleNodeBase.LOCAL_DYNAMIC
            };
            return ParticleNodeBase;
        })(animators.AnimationNodeBase);
        animators.ParticleNodeBase = ParticleNodeBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        /**
        * A particle animation node used to apply a constant acceleration vector to the motion of a particle.
        */
        var ParticleAccelerationNode = (function (_super) {
            __extends(ParticleAccelerationNode, _super);
            /**
            * Creates a new <code>ParticleAccelerationNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] acceleration    Defines the default acceleration vector of the node, used when in global mode.
            */
            function ParticleAccelerationNode(mode /*uint*/ , acceleration) {
                if (typeof acceleration === "undefined") { acceleration = null; }
                _super.call(this, "ParticleAcceleration", mode, 3);

                this._pStateClass = animators.ParticleAccelerationState;

                this._acceleration = acceleration || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleAccelerationNode.prototype.pGetAGALVertexCode = function (pass, animationRegisterCache) {
                var accelerationValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleAccelerationNode.ACCELERATION_INDEX, accelerationValue.index);

                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(temp, 1);

                var code = "mul " + temp + "," + animationRegisterCache.vertexTime + "," + accelerationValue + "\n";

                if (animationRegisterCache.needVelocity) {
                    var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                    code += "mul " + temp2 + "," + temp + "," + animationRegisterCache.vertexTwoConst + "\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + temp2 + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                }
                animationRegisterCache.removeVertexTempUsage(temp);

                code += "mul " + temp + "," + temp + "," + animationRegisterCache.vertexTime + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + temp + "," + animationRegisterCache.positionTarget + ".xyz\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleAccelerationNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleAccelerationNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var tempAcceleration = param[ParticleAccelerationNode.ACCELERATION_VECTOR3D];
                if (!tempAcceleration)
                    throw new Error("there is no " + ParticleAccelerationNode.ACCELERATION_VECTOR3D + " in param!");

                this._pOneData[0] = tempAcceleration.x / 2;
                this._pOneData[1] = tempAcceleration.y / 2;
                this._pOneData[2] = tempAcceleration.z / 2;
            };
            ParticleAccelerationNode.ACCELERATION_INDEX = 0;

            ParticleAccelerationNode.ACCELERATION_VECTOR3D = "AccelerationVector3D";
            return ParticleAccelerationNode;
        })(animators.ParticleNodeBase);
        animators.ParticleAccelerationNode = ParticleAccelerationNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the position of a particle over time along a bezier curve.
        */
        var ParticleBezierCurveNode = (function (_super) {
            __extends(ParticleBezierCurveNode, _super);
            /**
            * Creates a new <code>ParticleBezierCurveNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] controlPoint    Defines the default control point of the node, used when in global mode.
            * @param    [optional] endPoint        Defines the default end point of the node, used when in global mode.
            */
            function ParticleBezierCurveNode(mode /*uint*/ , controlPoint, endPoint) {
                if (typeof controlPoint === "undefined") { controlPoint = null; }
                if (typeof endPoint === "undefined") { endPoint = null; }
                _super.call(this, "ParticleBezierCurve", mode, 6);

                this._pStateClass = animators.ParticleBezierCurveState;

                this._iControlPoint = controlPoint || new Vector3D();
                this._iEndPoint = endPoint || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleBezierCurveNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                pass = pass;
                var controlValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleBezierCurveNode.BEZIER_CONTROL_INDEX, controlValue.index);

                var endValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleBezierCurveNode.BEZIER_END_INDEX, endValue.index);

                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                var rev_time = new ShaderRegisterElement(temp.regName, temp.index, 0);
                var time_2 = new ShaderRegisterElement(temp.regName, temp.index, 1);
                var time_temp = new ShaderRegisterElement(temp.regName, temp.index, 2);
                animationRegisterCache.addVertexTempUsages(temp, 1);
                var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                var distance = new ShaderRegisterElement(temp2.regName, temp2.index);
                animationRegisterCache.removeVertexTempUsage(temp);

                var code = "";
                code += "sub " + rev_time + "," + animationRegisterCache.vertexOneConst + "," + animationRegisterCache.vertexLife + "\n";
                code += "mul " + time_2 + "," + animationRegisterCache.vertexLife + "," + animationRegisterCache.vertexLife + "\n";

                code += "mul " + time_temp + "," + animationRegisterCache.vertexLife + "," + rev_time + "\n";
                code += "mul " + time_temp + "," + time_temp + "," + animationRegisterCache.vertexTwoConst + "\n";
                code += "mul " + distance + ".xyz," + time_temp + "," + controlValue + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                code += "mul " + distance + ".xyz," + time_2 + "," + endValue + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";

                if (animationRegisterCache.needVelocity) {
                    code += "mul " + time_2 + "," + animationRegisterCache.vertexLife + "," + animationRegisterCache.vertexTwoConst + "\n";
                    code += "sub " + time_temp + "," + animationRegisterCache.vertexOneConst + "," + time_2 + "\n";
                    code += "mul " + time_temp + "," + animationRegisterCache.vertexTwoConst + "," + time_temp + "\n";
                    code += "mul " + distance + ".xyz," + controlValue + "," + time_temp + "\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                    code += "mul " + distance + ".xyz," + endValue + "," + time_2 + "\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleBezierCurveNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleBezierCurveNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var bezierControl = param[ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D];
                if (!bezierControl)
                    throw new Error("there is no " + ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D + " in param!");

                var bezierEnd = param[ParticleBezierCurveNode.BEZIER_END_VECTOR3D];
                if (!bezierEnd)
                    throw new Error("there is no " + ParticleBezierCurveNode.BEZIER_END_VECTOR3D + " in param!");

                this._pOneData[0] = bezierControl.x;
                this._pOneData[1] = bezierControl.y;
                this._pOneData[2] = bezierControl.z;
                this._pOneData[3] = bezierEnd.x;
                this._pOneData[4] = bezierEnd.y;
                this._pOneData[5] = bezierEnd.z;
            };
            ParticleBezierCurveNode.BEZIER_CONTROL_INDEX = 0;

            ParticleBezierCurveNode.BEZIER_END_INDEX = 1;

            ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D = "BezierControlVector3D";

            ParticleBezierCurveNode.BEZIER_END_VECTOR3D = "BezierEndVector3D";
            return ParticleBezierCurveNode;
        })(animators.ParticleNodeBase);
        animators.ParticleBezierCurveNode = ParticleBezierCurveNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A particle animation node that controls the rotation of a particle to always face the camera.
        */
        var ParticleBillboardNode = (function (_super) {
            __extends(ParticleBillboardNode, _super);
            /**
            * Creates a new <code>ParticleBillboardNode</code>
            */
            function ParticleBillboardNode(billboardAxis) {
                if (typeof billboardAxis === "undefined") { billboardAxis = null; }
                _super.call(this, "ParticleBillboard", animators.ParticlePropertiesMode.GLOBAL, 0, 4);

                this._pStateClass = animators.ParticleBillboardState;

                this._iBillboardAxis = billboardAxis;
            }
            /**
            * @inheritDoc
            */
            ParticleBillboardNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var rotationMatrixRegister = animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.setRegisterIndex(this, ParticleBillboardNode.MATRIX_INDEX, rotationMatrixRegister.index);
                animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.getFreeVertexConstant();

                var temp = animationRegisterCache.getFreeVertexVectorTemp();

                var code = "m33 " + temp + ".xyz," + animationRegisterCache.scaleAndRotateTarget + "," + rotationMatrixRegister + "\n" + "mov " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp + "\n";

                var shaderRegisterElement;
                for (var i = 0; i < animationRegisterCache.rotationRegisters.length; i++) {
                    shaderRegisterElement = animationRegisterCache.rotationRegisters[i];
                    code += "m33 " + temp + ".xyz," + shaderRegisterElement + "," + rotationMatrixRegister + "\n" + "mov " + shaderRegisterElement + ".xyz," + shaderRegisterElement + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleBillboardNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleBillboardNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                particleAnimationSet.hasBillboard = true;
            };
            ParticleBillboardNode.MATRIX_INDEX = 0;
            return ParticleBillboardNode;
        })(animators.ParticleNodeBase);
        animators.ParticleBillboardNode = ParticleBillboardNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ColorTransform = away.geom.ColorTransform;

        /**
        * A particle animation node used to control the color variation of a particle over time.
        */
        var ParticleColorNode = (function (_super) {
            __extends(ParticleColorNode, _super);
            /**
            * Creates a new <code>ParticleColorNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] usesMultiplier  Defines whether the node uses multiplier data in the shader for its color transformations. Defaults to true.
            * @param    [optional] usesOffset      Defines whether the node uses offset data in the shader for its color transformations. Defaults to true.
            * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of the animation independent of particle duration. Defaults to false.
            * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the cycle rotation of the particle. Defaults to false.
            * @param    [optional] startColor      Defines the default start color transform of the node, when in global mode.
            * @param    [optional] endColor        Defines the default end color transform of the node, when in global mode.
            * @param    [optional] cycleDuration   Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
            * @param    [optional] cyclePhase      Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
            */
            function ParticleColorNode(mode /*uint*/ , usesMultiplier, usesOffset, usesCycle, usesPhase, startColor, endColor, cycleDuration, cyclePhase) {
                if (typeof usesMultiplier === "undefined") { usesMultiplier = true; }
                if (typeof usesOffset === "undefined") { usesOffset = true; }
                if (typeof usesCycle === "undefined") { usesCycle = false; }
                if (typeof usesPhase === "undefined") { usesPhase = false; }
                if (typeof startColor === "undefined") { startColor = null; }
                if (typeof endColor === "undefined") { endColor = null; }
                if (typeof cycleDuration === "undefined") { cycleDuration = 1; }
                if (typeof cyclePhase === "undefined") { cyclePhase = 0; }
                _super.call(this, "ParticleColor", mode, (usesMultiplier && usesOffset) ? 16 : 8, animators.ParticleAnimationSet.COLOR_PRIORITY);

                this._pStateClass = animators.ParticleColorState;

                this._iUsesMultiplier = usesMultiplier;
                this._iUsesOffset = usesOffset;
                this._iUsesCycle = usesCycle;
                this._iUsesPhase = usesPhase;

                this._iStartColor = startColor || new ColorTransform();
                this._iEndColor = endColor || new ColorTransform();
                this._iCycleDuration = cycleDuration;
                this._iCyclePhase = cyclePhase;
            }
            /**
            * @inheritDoc
            */
            ParticleColorNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                if (animationRegisterCache.needFragmentAnimation) {
                    var temp = animationRegisterCache.getFreeVertexVectorTemp();

                    if (this._iUsesCycle) {
                        var cycleConst = animationRegisterCache.getFreeVertexConstant();
                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.CYCLE_INDEX, cycleConst.index);

                        animationRegisterCache.addVertexTempUsages(temp, 1);
                        var sin = animationRegisterCache.getFreeVertexSingleTemp();
                        animationRegisterCache.removeVertexTempUsage(temp);

                        code += "mul " + sin + "," + animationRegisterCache.vertexTime + "," + cycleConst + ".x\n";

                        if (this._iUsesPhase)
                            code += "add " + sin + "," + sin + "," + cycleConst + ".y\n";

                        code += "sin " + sin + "," + sin + "\n";
                    }

                    if (this._iUsesMultiplier) {
                        var startMultiplierValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                        var deltaMultiplierValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();

                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.START_MULTIPLIER_INDEX, startMultiplierValue.index);
                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.DELTA_MULTIPLIER_INDEX, deltaMultiplierValue.index);

                        code += "mul " + temp + "," + deltaMultiplierValue + "," + (this._iUsesCycle ? sin : animationRegisterCache.vertexLife) + "\n";
                        code += "add " + temp + "," + temp + "," + startMultiplierValue + "\n";
                        code += "mul " + animationRegisterCache.colorMulTarget + "," + temp + "," + animationRegisterCache.colorMulTarget + "\n";
                    }

                    if (this._iUsesOffset) {
                        var startOffsetValue = (this._pMode == animators.ParticlePropertiesMode.LOCAL_STATIC) ? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();
                        var deltaOffsetValue = (this._pMode == animators.ParticlePropertiesMode.LOCAL_STATIC) ? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();

                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.START_OFFSET_INDEX, startOffsetValue.index);
                        animationRegisterCache.setRegisterIndex(this, ParticleColorNode.DELTA_OFFSET_INDEX, deltaOffsetValue.index);

                        code += "mul " + temp + "," + deltaOffsetValue + "," + (this._iUsesCycle ? sin : animationRegisterCache.vertexLife) + "\n";
                        code += "add " + temp + "," + temp + "," + startOffsetValue + "\n";
                        code += "add " + animationRegisterCache.colorAddTarget + "," + temp + "," + animationRegisterCache.colorAddTarget + "\n";
                    }
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleColorNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                if (this._iUsesMultiplier)
                    particleAnimationSet.hasColorMulNode = true;
                if (this._iUsesOffset)
                    particleAnimationSet.hasColorAddNode = true;
            };

            /**
            * @inheritDoc
            */
            ParticleColorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var startColor = param[ParticleColorNode.COLOR_START_COLORTRANSFORM];
                if (!startColor)
                    throw (new Error("there is no " + ParticleColorNode.COLOR_START_COLORTRANSFORM + " in param!"));

                var endColor = param[ParticleColorNode.COLOR_END_COLORTRANSFORM];
                if (!endColor)
                    throw (new Error("there is no " + ParticleColorNode.COLOR_END_COLORTRANSFORM + " in param!"));

                var i = 0;

                if (!this._iUsesCycle) {
                    //multiplier
                    if (this._iUsesMultiplier) {
                        this._pOneData[i++] = startColor.redMultiplier;
                        this._pOneData[i++] = startColor.greenMultiplier;
                        this._pOneData[i++] = startColor.blueMultiplier;
                        this._pOneData[i++] = startColor.alphaMultiplier;
                        this._pOneData[i++] = endColor.redMultiplier - startColor.redMultiplier;
                        this._pOneData[i++] = endColor.greenMultiplier - startColor.greenMultiplier;
                        this._pOneData[i++] = endColor.blueMultiplier - startColor.blueMultiplier;
                        this._pOneData[i++] = endColor.alphaMultiplier - startColor.alphaMultiplier;
                    }

                    //offset
                    if (this._iUsesOffset) {
                        this._pOneData[i++] = startColor.redOffset / 255;
                        this._pOneData[i++] = startColor.greenOffset / 255;
                        this._pOneData[i++] = startColor.blueOffset / 255;
                        this._pOneData[i++] = startColor.alphaOffset / 255;
                        this._pOneData[i++] = (endColor.redOffset - startColor.redOffset) / 255;
                        this._pOneData[i++] = (endColor.greenOffset - startColor.greenOffset) / 255;
                        this._pOneData[i++] = (endColor.blueOffset - startColor.blueOffset) / 255;
                        this._pOneData[i++] = (endColor.alphaOffset - startColor.alphaOffset) / 255;
                    }
                } else {
                    //multiplier
                    if (this._iUsesMultiplier) {
                        this._pOneData[i++] = (startColor.redMultiplier + endColor.redMultiplier) / 2;
                        this._pOneData[i++] = (startColor.greenMultiplier + endColor.greenMultiplier) / 2;
                        this._pOneData[i++] = (startColor.blueMultiplier + endColor.blueMultiplier) / 2;
                        this._pOneData[i++] = (startColor.alphaMultiplier + endColor.alphaMultiplier) / 2;
                        this._pOneData[i++] = (startColor.redMultiplier - endColor.redMultiplier) / 2;
                        this._pOneData[i++] = (startColor.greenMultiplier - endColor.greenMultiplier) / 2;
                        this._pOneData[i++] = (startColor.blueMultiplier - endColor.blueMultiplier) / 2;
                        this._pOneData[i++] = (startColor.alphaMultiplier - endColor.alphaMultiplier) / 2;
                    }

                    //offset
                    if (this._iUsesOffset) {
                        this._pOneData[i++] = (startColor.redOffset + endColor.redOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.greenOffset + endColor.greenOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.blueOffset + endColor.blueOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.alphaOffset + endColor.alphaOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.redOffset - endColor.redOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.greenOffset - endColor.greenOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.blueOffset - endColor.blueOffset) / (255 * 2);
                        this._pOneData[i++] = (startColor.alphaOffset - endColor.alphaOffset) / (255 * 2);
                    }
                }
            };
            ParticleColorNode.START_MULTIPLIER_INDEX = 0;

            ParticleColorNode.DELTA_MULTIPLIER_INDEX = 1;

            ParticleColorNode.START_OFFSET_INDEX = 2;

            ParticleColorNode.DELTA_OFFSET_INDEX = 3;

            ParticleColorNode.CYCLE_INDEX = 4;

            ParticleColorNode.COLOR_START_COLORTRANSFORM = "ColorStartColorTransform";

            ParticleColorNode.COLOR_END_COLORTRANSFORM = "ColorEndColorTransform";
            return ParticleColorNode;
        })(animators.ParticleNodeBase);
        animators.ParticleColorNode = ParticleColorNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A particle animation node used to create a follow behaviour on a particle system.
        */
        var ParticleFollowNode = (function (_super) {
            __extends(ParticleFollowNode, _super);
            /**
            * Creates a new <code>ParticleFollowNode</code>
            *
            * @param    [optional] usesPosition     Defines wehether the individual particle reacts to the position of the target.
            * @param    [optional] usesRotation     Defines wehether the individual particle reacts to the rotation of the target.
            * @param    [optional] smooth     Defines wehether the state calculate the interpolated value.
            */
            function ParticleFollowNode(usesPosition, usesRotation, smooth) {
                if (typeof usesPosition === "undefined") { usesPosition = true; }
                if (typeof usesRotation === "undefined") { usesRotation = true; }
                if (typeof smooth === "undefined") { smooth = false; }
                _super.call(this, "ParticleFollow", animators.ParticlePropertiesMode.LOCAL_DYNAMIC, (usesPosition && usesRotation) ? 6 : 3, animators.ParticleAnimationSet.POST_PRIORITY);

                this._pStateClass = animators.ParticleFollowState;

                this._iUsesPosition = usesPosition;
                this._iUsesRotation = usesRotation;
                this._iSmooth = smooth;
            }
            /**
            * @inheritDoc
            */
            ParticleFollowNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                //TODO: use Quaternion to implement this function
                var code = "";
                if (this._iUsesRotation) {
                    var rotationAttribute = animationRegisterCache.getFreeVertexAttribute();
                    animationRegisterCache.setRegisterIndex(this, ParticleFollowNode.FOLLOW_ROTATION_INDEX, rotationAttribute.index);

                    var temp1 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp1, 1);
                    var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp2, 1);
                    var temp3 = animationRegisterCache.getFreeVertexVectorTemp();

                    var temp4;
                    if (animationRegisterCache.hasBillboard) {
                        animationRegisterCache.addVertexTempUsages(temp3, 1);
                        temp4 = animationRegisterCache.getFreeVertexVectorTemp();
                    }

                    animationRegisterCache.removeVertexTempUsage(temp1);
                    animationRegisterCache.removeVertexTempUsage(temp2);
                    if (animationRegisterCache.hasBillboard)
                        animationRegisterCache.removeVertexTempUsage(temp3);

                    var len = animationRegisterCache.rotationRegisters.length;
                    var i;

                    //x axis
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp1 + ".x," + animationRegisterCache.vertexOneConst + "\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "sin " + temp3 + ".y," + rotationAttribute + ".x\n";
                    code += "cos " + temp3 + ".z," + rotationAttribute + ".x\n";
                    code += "mov " + temp2 + ".x," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp2 + ".y," + temp3 + ".z\n";
                    code += "neg " + temp2 + ".z," + temp3 + ".y\n";

                    if (animationRegisterCache.hasBillboard)
                        code += "m33 " + temp4 + ".xyz," + animationRegisterCache.positionTarget + ".xyz," + temp1 + "\n";
                    else {
                        code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                        for (i = 0; i < len; i++)
                            code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                    }

                    //y axis
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "cos " + temp1 + ".x," + rotationAttribute + ".y\n";
                    code += "sin " + temp1 + ".z," + rotationAttribute + ".y\n";
                    code += "mov " + temp2 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp2 + ".y," + animationRegisterCache.vertexOneConst + "\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "neg " + temp3 + ".x," + temp1 + ".z\n";
                    code += "mov " + temp3 + ".z," + temp1 + ".x\n";

                    if (animationRegisterCache.hasBillboard)
                        code += "m33 " + temp4 + ".xyz," + temp4 + ".xyz," + temp1 + "\n";
                    else {
                        code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                        for (i = 0; i < len; i++)
                            code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                    }

                    //z axis
                    code += "mov " + temp2 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "sin " + temp2 + ".x," + rotationAttribute + ".z\n";
                    code += "cos " + temp2 + ".y," + rotationAttribute + ".z\n";
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp1 + ".x," + temp2 + ".y\n";
                    code += "neg " + temp1 + ".y," + temp2 + ".x\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".z," + animationRegisterCache.vertexOneConst + "\n";

                    if (animationRegisterCache.hasBillboard) {
                        code += "m33 " + temp4 + ".xyz," + temp4 + ".xyz," + temp1 + "\n";
                        code += "sub " + temp4 + ".xyz," + temp4 + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                        code += "add " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp4 + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                    } else {
                        code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                        for (i = 0; i < len; i++)
                            code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                    }
                }

                if (this._iUsesPosition) {
                    var positionAttribute = animationRegisterCache.getFreeVertexAttribute();
                    animationRegisterCache.setRegisterIndex(this, ParticleFollowNode.FOLLOW_POSITION_INDEX, positionAttribute.index);
                    code += "add " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + positionAttribute + "," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleFollowNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            ParticleFollowNode.FOLLOW_POSITION_INDEX = 0;

            ParticleFollowNode.FOLLOW_ROTATION_INDEX = 1;
            return ParticleFollowNode;
        })(animators.ParticleNodeBase);
        animators.ParticleFollowNode = ParticleFollowNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ColorTransform = away.geom.ColorTransform;

        var ParticleInitialColorNode = (function (_super) {
            __extends(ParticleInitialColorNode, _super);
            function ParticleInitialColorNode(mode /*uint*/ , usesMultiplier, usesOffset, initialColor) {
                if (typeof usesMultiplier === "undefined") { usesMultiplier = true; }
                if (typeof usesOffset === "undefined") { usesOffset = false; }
                if (typeof initialColor === "undefined") { initialColor = null; }
                _super.call(this, "ParticleInitialColor", mode, (usesMultiplier && usesOffset) ? 8 : 4, animators.ParticleAnimationSet.COLOR_PRIORITY);

                this._pStateClass = animators.ParticleInitialColorState;

                this._iUsesMultiplier = usesMultiplier;
                this._iUsesOffset = usesOffset;
                this._iInitialColor = initialColor || new ColorTransform();
            }
            /**
            * @inheritDoc
            */
            ParticleInitialColorNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                if (animationRegisterCache.needFragmentAnimation) {
                    if (this._iUsesMultiplier) {
                        var multiplierValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                        animationRegisterCache.setRegisterIndex(this, ParticleInitialColorNode.MULTIPLIER_INDEX, multiplierValue.index);

                        code += "mul " + animationRegisterCache.colorMulTarget + "," + multiplierValue + "," + animationRegisterCache.colorMulTarget + "\n";
                    }

                    if (this._iUsesOffset) {
                        var offsetValue = (this._pMode == animators.ParticlePropertiesMode.LOCAL_STATIC) ? animationRegisterCache.getFreeVertexAttribute() : animationRegisterCache.getFreeVertexConstant();
                        animationRegisterCache.setRegisterIndex(this, ParticleInitialColorNode.OFFSET_INDEX, offsetValue.index);

                        code += "add " + animationRegisterCache.colorAddTarget + "," + offsetValue + "," + animationRegisterCache.colorAddTarget + "\n";
                    }
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleInitialColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                if (this._iUsesMultiplier)
                    particleAnimationSet.hasColorMulNode = true;
                if (this._iUsesOffset)
                    particleAnimationSet.hasColorAddNode = true;
            };

            /**
            * @inheritDoc
            */
            ParticleInitialColorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var initialColor = param[ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM];
                if (!initialColor)
                    throw (new Error("there is no " + ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM + " in param!"));

                var i = 0;

                //multiplier
                if (this._iUsesMultiplier) {
                    this._pOneData[i++] = initialColor.redMultiplier;
                    this._pOneData[i++] = initialColor.greenMultiplier;
                    this._pOneData[i++] = initialColor.blueMultiplier;
                    this._pOneData[i++] = initialColor.alphaMultiplier;
                }

                //offset
                if (this._iUsesOffset) {
                    this._pOneData[i++] = initialColor.redOffset / 255;
                    this._pOneData[i++] = initialColor.greenOffset / 255;
                    this._pOneData[i++] = initialColor.blueOffset / 255;
                    this._pOneData[i++] = initialColor.alphaOffset / 255;
                }
            };
            ParticleInitialColorNode.MULTIPLIER_INDEX = 0;

            ParticleInitialColorNode.OFFSET_INDEX = 1;

            ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM = "ColorInitialColorTransform";
            return ParticleInitialColorNode;
        })(animators.ParticleNodeBase);
        animators.ParticleInitialColorNode = ParticleInitialColorNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the position of a particle over time around a circular orbit.
        */
        var ParticleOrbitNode = (function (_super) {
            __extends(ParticleOrbitNode, _super);
            /**
            * Creates a new <code>ParticleOrbitNode</code> object.
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] usesEulers      Defines whether the node uses the <code>eulers</code> property in the shader to calculate a rotation on the orbit. Defaults to true.
            * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of the orbit independent of particle duration. Defaults to false.
            * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the cycle rotation of the particle. Defaults to false.
            * @param    [optional] radius          Defines the radius of the orbit when in global mode. Defaults to 100.
            * @param    [optional] cycleDuration   Defines the duration of the orbit in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
            * @param    [optional] cyclePhase      Defines the phase of the orbit in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
            * @param    [optional] eulers          Defines the euler rotation in degrees, applied to the orientation of the orbit when in global mode.
            */
            function ParticleOrbitNode(mode /*uint*/ , usesEulers, usesCycle, usesPhase, radius, cycleDuration, cyclePhase, eulers) {
                if (typeof usesEulers === "undefined") { usesEulers = true; }
                if (typeof usesCycle === "undefined") { usesCycle = false; }
                if (typeof usesPhase === "undefined") { usesPhase = false; }
                if (typeof radius === "undefined") { radius = 100; }
                if (typeof cycleDuration === "undefined") { cycleDuration = 1; }
                if (typeof cyclePhase === "undefined") { cyclePhase = 0; }
                if (typeof eulers === "undefined") { eulers = null; }
                var len = 3;
                if (usesPhase)
                    len++;
                _super.call(this, "ParticleOrbit", mode, len);

                this._pStateClass = animators.ParticleOrbitState;

                this._iUsesEulers = usesEulers;
                this._iUsesCycle = usesCycle;
                this._iUsesPhase = usesPhase;

                this._iRadius = radius;
                this._iCycleDuration = cycleDuration;
                this._iCyclePhase = cyclePhase;
                this._iEulers = eulers || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleOrbitNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var orbitRegister = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleOrbitNode.ORBIT_INDEX, orbitRegister.index);

                var eulersMatrixRegister = animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.setRegisterIndex(this, ParticleOrbitNode.EULERS_INDEX, eulersMatrixRegister.index);
                animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.getFreeVertexConstant();

                var temp1 = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(temp1, 1);
                var distance = new ShaderRegisterElement(temp1.regName, temp1.index);

                var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                var cos = new ShaderRegisterElement(temp2.regName, temp2.index, 0);
                var sin = new ShaderRegisterElement(temp2.regName, temp2.index, 1);
                var degree = new ShaderRegisterElement(temp2.regName, temp2.index, 2);
                animationRegisterCache.removeVertexTempUsage(temp1);

                var code = "";

                if (this._iUsesCycle) {
                    code += "mul " + degree + "," + animationRegisterCache.vertexTime + "," + orbitRegister + ".y\n";

                    if (this._iUsesPhase)
                        code += "add " + degree + "," + degree + "," + orbitRegister + ".w\n";
                } else
                    code += "mul " + degree + "," + animationRegisterCache.vertexLife + "," + orbitRegister + ".y\n";

                code += "cos " + cos + "," + degree + "\n";
                code += "sin " + sin + "," + degree + "\n";
                code += "mul " + distance + ".x," + cos + "," + orbitRegister + ".x\n";
                code += "mul " + distance + ".y," + sin + "," + orbitRegister + ".x\n";
                code += "mov " + distance + ".wz" + animationRegisterCache.vertexZeroConst + "\n";
                if (this._iUsesEulers)
                    code += "m44 " + distance + "," + distance + "," + eulersMatrixRegister + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";

                if (animationRegisterCache.needVelocity) {
                    code += "neg " + distance + ".x," + sin + "\n";
                    code += "mov " + distance + ".y," + cos + "\n";
                    code += "mov " + distance + ".zw," + animationRegisterCache.vertexZeroConst + "\n";
                    if (this._iUsesEulers)
                        code += "m44 " + distance + "," + distance + "," + eulersMatrixRegister + "\n";
                    code += "mul " + distance + "," + distance + "," + orbitRegister + ".z\n";
                    code += "div " + distance + "," + distance + "," + orbitRegister + ".y\n";
                    if (!this._iUsesCycle)
                        code += "div " + distance + "," + distance + "," + animationRegisterCache.vertexLife + "\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + animationRegisterCache.velocityTarget + ".xyz," + distance + ".xyz\n";
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleOrbitNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleOrbitNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                //Vector3D.x is radius, Vector3D.y is cycle duration, Vector3D.z is phase
                var orbit = param[ParticleOrbitNode.ORBIT_VECTOR3D];
                if (!orbit)
                    throw new Error("there is no " + ParticleOrbitNode.ORBIT_VECTOR3D + " in param!");

                this._pOneData[0] = orbit.x;
                if (this._iUsesCycle && orbit.y <= 0)
                    throw (new Error("the cycle duration must be greater than zero"));
                this._pOneData[1] = Math.PI * 2 / (!this._iUsesCycle ? 1 : orbit.y);
                this._pOneData[2] = orbit.x * Math.PI * 2;
                if (this._iUsesPhase)
                    this._pOneData[3] = orbit.z * Math.PI / 180;
            };
            ParticleOrbitNode.ORBIT_INDEX = 0;

            ParticleOrbitNode.EULERS_INDEX = 1;

            ParticleOrbitNode.ORBIT_VECTOR3D = "OrbitVector3D";
            return ParticleOrbitNode;
        })(animators.ParticleNodeBase);
        animators.ParticleOrbitNode = ParticleOrbitNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the position of a particle over time using simple harmonic motion.
        */
        var ParticleOscillatorNode = (function (_super) {
            __extends(ParticleOscillatorNode, _super);
            /**
            * Creates a new <code>ParticleOscillatorNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] oscillator      Defines the default oscillator axis (x, y, z) and cycleDuration (w) of the node, used when in global mode.
            */
            function ParticleOscillatorNode(mode /*uint*/ , oscillator) {
                if (typeof oscillator === "undefined") { oscillator = null; }
                _super.call(this, "ParticleOscillator", mode, 4);

                this._pStateClass = animators.ParticleOscillatorState;

                this._iOscillator = oscillator || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleOscillatorNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                pass = pass;
                var oscillatorRegister = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleOscillatorNode.OSCILLATOR_INDEX, oscillatorRegister.index);
                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                var dgree = new ShaderRegisterElement(temp.regName, temp.index, 0);
                var sin = new ShaderRegisterElement(temp.regName, temp.index, 1);
                var cos = new ShaderRegisterElement(temp.regName, temp.index, 2);
                animationRegisterCache.addVertexTempUsages(temp, 1);
                var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                var distance = new ShaderRegisterElement(temp2.regName, temp2.index);
                animationRegisterCache.removeVertexTempUsage(temp);

                var code = "";
                code += "mul " + dgree + "," + animationRegisterCache.vertexTime + "," + oscillatorRegister + ".w\n";
                code += "sin " + sin + "," + dgree + "\n";
                code += "mul " + distance + ".xyz," + sin + "," + oscillatorRegister + ".xyz\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";

                if (animationRegisterCache.needVelocity) {
                    code += "cos " + cos + "," + dgree + "\n";
                    code += "mul " + distance + ".xyz," + cos + "," + oscillatorRegister + ".xyz\n";
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleOscillatorNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleOscillatorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                //(Vector3D.x,Vector3D.y,Vector3D.z) is oscillator axis, Vector3D.w is oscillator cycle duration
                var drift = param[ParticleOscillatorNode.OSCILLATOR_VECTOR3D];
                if (!drift)
                    throw (new Error("there is no " + ParticleOscillatorNode.OSCILLATOR_VECTOR3D + " in param!"));

                this._pOneData[0] = drift.x;
                this._pOneData[1] = drift.y;
                this._pOneData[2] = drift.z;
                if (drift.w <= 0)
                    throw (new Error("the cycle duration must greater than zero"));
                this._pOneData[3] = Math.PI * 2 / drift.w;
            };
            ParticleOscillatorNode.OSCILLATOR_INDEX = 0;

            ParticleOscillatorNode.OSCILLATOR_VECTOR3D = "OscillatorVector3D";
            return ParticleOscillatorNode;
        })(animators.ParticleNodeBase);
        animators.ParticleOscillatorNode = ParticleOscillatorNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        /**
        * A particle animation node used to set the starting position of a particle.
        */
        var ParticlePositionNode = (function (_super) {
            __extends(ParticlePositionNode, _super);
            /**
            * Creates a new <code>ParticlePositionNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] position        Defines the default position of the particle when in global mode. Defaults to 0,0,0.
            */
            function ParticlePositionNode(mode /*uint*/ , position) {
                if (typeof position === "undefined") { position = null; }
                _super.call(this, "ParticlePosition", mode, 3);

                this._pStateClass = animators.ParticlePositionState;

                this._iPosition = position || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticlePositionNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                pass = pass;
                var positionAttribute = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticlePositionNode.POSITION_INDEX, positionAttribute.index);

                return "add " + animationRegisterCache.positionTarget + ".xyz," + positionAttribute + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
            };

            /**
            * @inheritDoc
            */
            ParticlePositionNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticlePositionNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var offset = param[ParticlePositionNode.POSITION_VECTOR3D];
                if (!offset)
                    throw (new Error("there is no " + ParticlePositionNode.POSITION_VECTOR3D + " in param!"));

                this._pOneData[0] = offset.x;
                this._pOneData[1] = offset.y;
                this._pOneData[2] = offset.z;
            };
            ParticlePositionNode.POSITION_INDEX = 0;

            ParticlePositionNode.POSITION_VECTOR3D = "PositionVector3D";
            return ParticlePositionNode;
        })(animators.ParticleNodeBase);
        animators.ParticlePositionNode = ParticlePositionNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the rotation of a particle to match its heading vector.
        */
        var ParticleRotateToHeadingNode = (function (_super) {
            __extends(ParticleRotateToHeadingNode, _super);
            /**
            * Creates a new <code>ParticleBillboardNode</code>
            */
            function ParticleRotateToHeadingNode() {
                _super.call(this, "ParticleRotateToHeading", animators.ParticlePropertiesMode.GLOBAL, 0, 3);

                this._pStateClass = animators.ParticleRotateToHeadingState;
            }
            /**
            * @inheritDoc
            */
            ParticleRotateToHeadingNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                var len = animationRegisterCache.rotationRegisters.length;
                var i;
                if (animationRegisterCache.hasBillboard) {
                    var temp1 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp1, 1);
                    var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp2, 1);
                    var temp3 = animationRegisterCache.getFreeVertexVectorTemp();

                    var rotationMatrixRegister = animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.setRegisterIndex(this, ParticleRotateToHeadingNode.MATRIX_INDEX, rotationMatrixRegister.index);
                    animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.getFreeVertexConstant();

                    animationRegisterCache.removeVertexTempUsage(temp1);
                    animationRegisterCache.removeVertexTempUsage(temp2);

                    //process the velocity
                    code += "m33 " + temp1 + ".xyz," + animationRegisterCache.velocityTarget + ".xyz," + rotationMatrixRegister + "\n";

                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".xy," + temp1 + ".xy\n";
                    code += "nrm " + temp3 + ".xyz," + temp3 + ".xyz\n";

                    //temp3.x=cos,temp3.y=sin
                    //only process z axis
                    code += "mov " + temp2 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp2 + ".x," + temp3 + ".y\n";
                    code += "mov " + temp2 + ".y," + temp3 + ".x\n";
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp1 + ".x," + temp3 + ".x\n";
                    code += "neg " + temp1 + ".y," + temp3 + ".y\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".z," + animationRegisterCache.vertexOneConst + "\n";
                    code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                    for (i = 0; i < len; i++)
                        code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                } else {
                    var nrmVel = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(nrmVel, 1);

                    var xAxis = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(xAxis, 1);

                    var R = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(R, 1);
                    var R_rev = animationRegisterCache.getFreeVertexVectorTemp();
                    var cos = new ShaderRegisterElement(R.regName, R.index, 3);
                    var sin = new ShaderRegisterElement(R_rev.regName, R_rev.index, 3);
                    var cos2 = new ShaderRegisterElement(nrmVel.regName, nrmVel.index, 3);
                    var tempSingle = sin;

                    animationRegisterCache.removeVertexTempUsage(nrmVel);
                    animationRegisterCache.removeVertexTempUsage(xAxis);
                    animationRegisterCache.removeVertexTempUsage(R);

                    code += "mov " + xAxis + ".x," + animationRegisterCache.vertexOneConst + "\n";
                    code += "mov " + xAxis + ".yz," + animationRegisterCache.vertexZeroConst + "\n";

                    code += "nrm " + nrmVel + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                    code += "dp3 " + cos2 + "," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                    code += "crs " + nrmVel + ".xyz," + xAxis + ".xyz," + nrmVel + ".xyz\n";
                    code += "nrm " + nrmVel + ".xyz," + nrmVel + ".xyz\n";

                    //use R as temp to judge if nrm is (0,0,0).
                    //if nrm is (0,0,0) ,change it to (0,0,1).
                    code += "dp3 " + R + ".x," + nrmVel + ".xyz," + nrmVel + ".xyz\n";
                    code += "sge " + R + ".x," + animationRegisterCache.vertexZeroConst + "," + R + ".x\n";
                    code += "add " + nrmVel + ".z," + R + ".x," + nrmVel + ".z\n";

                    code += "add " + tempSingle + "," + cos2 + "," + animationRegisterCache.vertexOneConst + "\n";
                    code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterCache.vertexTwoConst + "\n";
                    code += "sqt " + cos + "," + tempSingle + "\n";

                    code += "sub " + tempSingle + "," + animationRegisterCache.vertexOneConst + "," + cos2 + "\n";
                    code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterCache.vertexTwoConst + "\n";
                    code += "sqt " + sin + "," + tempSingle + "\n";

                    code += "mul " + R + ".xyz," + sin + "," + nrmVel + ".xyz\n";

                    //use cos as R.w
                    code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                    code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";

                    //use cos as R_rev.w
                    //nrmVel and xAxis are used as temp register
                    code += "crs " + nrmVel + ".xyz," + R + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";

                    //use cos as R.w
                    code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                    code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                    code += "dp3 " + xAxis + ".w," + R + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                    code += "neg " + nrmVel + ".w," + xAxis + ".w\n";

                    code += "crs " + R + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";

                    //code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," +R_rev + ".w\n";
                    code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                    code += "add " + R + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
                    code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";

                    code += "add " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";

                    for (i = 0; i < len; i++) {
                        //just repeat the calculate above
                        //because of the limited registers, no need to optimise
                        code += "mov " + xAxis + ".x," + animationRegisterCache.vertexOneConst + "\n";
                        code += "mov " + xAxis + ".yz," + animationRegisterCache.vertexZeroConst + "\n";
                        code += "nrm " + nrmVel + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
                        code += "dp3 " + cos2 + "," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                        code += "crs " + nrmVel + ".xyz," + xAxis + ".xyz," + nrmVel + ".xyz\n";
                        code += "nrm " + nrmVel + ".xyz," + nrmVel + ".xyz\n";
                        code += "dp3 " + R + ".x," + nrmVel + ".xyz," + nrmVel + ".xyz\n";
                        code += "sge " + R + ".x," + animationRegisterCache.vertexZeroConst + "," + R + ".x\n";
                        code += "add " + nrmVel + ".z," + R + ".x," + nrmVel + ".z\n";
                        code += "add " + tempSingle + "," + cos2 + "," + animationRegisterCache.vertexOneConst + "\n";
                        code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterCache.vertexTwoConst + "\n";
                        code += "sqt " + cos + "," + tempSingle + "\n";
                        code += "sub " + tempSingle + "," + animationRegisterCache.vertexOneConst + "," + cos2 + "\n";
                        code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterCache.vertexTwoConst + "\n";
                        code += "sqt " + sin + "," + tempSingle + "\n";
                        code += "mul " + R + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                        code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                        code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
                        code += "crs " + nrmVel + ".xyz," + R + ".xyz," + animationRegisterCache.rotationRegisters[i] + ".xyz\n";
                        code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".xyz\n";
                        code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                        code += "dp3 " + xAxis + ".w," + R + ".xyz," + animationRegisterCache.rotationRegisters[i] + ".xyz\n";
                        code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
                        code += "crs " + R + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
                        code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                        code += "add " + R + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
                        code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
                        code += "add " + animationRegisterCache.rotationRegisters[i] + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
                    }
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleRotateToHeadingNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleRotateToHeadingNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                particleAnimationSet.needVelocity = true;
            };
            ParticleRotateToHeadingNode.MATRIX_INDEX = 0;
            return ParticleRotateToHeadingNode;
        })(animators.ParticleNodeBase);
        animators.ParticleRotateToHeadingNode = ParticleRotateToHeadingNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the rotation of a particle to face to a position
        */
        var ParticleRotateToPositionNode = (function (_super) {
            __extends(ParticleRotateToPositionNode, _super);
            /**
            * Creates a new <code>ParticleRotateToPositionNode</code>
            */
            function ParticleRotateToPositionNode(mode /*uint*/ , position) {
                if (typeof position === "undefined") { position = null; }
                _super.call(this, "ParticleRotateToPosition", mode, 3, 3);

                this._pStateClass = animators.ParticleRotateToPositionState;

                this._iPosition = position || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleRotateToPositionNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var positionAttribute = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleRotateToPositionNode.POSITION_INDEX, positionAttribute.index);

                var code = "";
                var len = animationRegisterCache.rotationRegisters.length;
                var i;
                if (animationRegisterCache.hasBillboard) {
                    var temp1 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp1, 1);
                    var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp2, 1);
                    var temp3 = animationRegisterCache.getFreeVertexVectorTemp();

                    var rotationMatrixRegister = animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.setRegisterIndex(this, ParticleRotateToPositionNode.MATRIX_INDEX, rotationMatrixRegister.index);
                    animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.getFreeVertexConstant();

                    animationRegisterCache.removeVertexTempUsage(temp1);
                    animationRegisterCache.removeVertexTempUsage(temp2);

                    //process the position
                    code += "sub " + temp1 + ".xyz," + positionAttribute + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                    code += "m33 " + temp1 + ".xyz," + temp1 + ".xyz," + rotationMatrixRegister + "\n";

                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".xy," + temp1 + ".xy\n";
                    code += "nrm " + temp3 + ".xyz," + temp3 + ".xyz\n";

                    //temp3.x=cos,temp3.y=sin
                    //only process z axis
                    code += "mov " + temp2 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp2 + ".x," + temp3 + ".y\n";
                    code += "mov " + temp2 + ".y," + temp3 + ".x\n";
                    code += "mov " + temp1 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp1 + ".x," + temp3 + ".x\n";
                    code += "neg " + temp1 + ".y," + temp3 + ".y\n";
                    code += "mov " + temp3 + "," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mov " + temp3 + ".z," + animationRegisterCache.vertexOneConst + "\n";
                    code += "m33 " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                    for (i = 0; i < len; i++)
                        code += "m33 " + animationRegisterCache.rotationRegisters[i] + ".xyz," + animationRegisterCache.rotationRegisters[i] + "," + temp1 + "\n";
                } else {
                    var nrmDirection = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(nrmDirection, 1);

                    var temp = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(temp, 1);
                    var cos = new ShaderRegisterElement(temp.regName, temp.index, 0);
                    var sin = new ShaderRegisterElement(temp.regName, temp.index, 1);
                    var o_temp = new ShaderRegisterElement(temp.regName, temp.index, 2);
                    var tempSingle = new ShaderRegisterElement(temp.regName, temp.index, 3);

                    var R = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(R, 1);

                    animationRegisterCache.removeVertexTempUsage(nrmDirection);
                    animationRegisterCache.removeVertexTempUsage(temp);
                    animationRegisterCache.removeVertexTempUsage(R);

                    code += "sub " + nrmDirection + ".xyz," + positionAttribute + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                    code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";

                    code += "mov " + sin + "," + nrmDirection + ".y\n";
                    code += "mul " + cos + "," + sin + "," + sin + "\n";
                    code += "sub " + cos + "," + animationRegisterCache.vertexOneConst + "," + cos + "\n";
                    code += "sqt " + cos + "," + cos + "\n";

                    code += "mul " + R + ".x," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".y\n";
                    code += "mul " + R + ".y," + sin + "," + animationRegisterCache.scaleAndRotateTarget + ".z\n";
                    code += "mul " + R + ".z," + sin + "," + animationRegisterCache.scaleAndRotateTarget + ".y\n";
                    code += "mul " + R + ".w," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".z\n";

                    code += "sub " + animationRegisterCache.scaleAndRotateTarget + ".y," + R + ".x," + R + ".y\n";
                    code += "add " + animationRegisterCache.scaleAndRotateTarget + ".z," + R + ".z," + R + ".w\n";

                    code += "abs " + R + ".y," + nrmDirection + ".y\n";
                    code += "sge " + R + ".z," + R + ".y," + animationRegisterCache.vertexOneConst + "\n";
                    code += "mul " + R + ".x," + R + ".y," + nrmDirection + ".y\n";

                    //judgu if nrmDirection=(0,1,0);
                    code += "mov " + nrmDirection + ".y," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "dp3 " + sin + "," + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                    code += "sge " + tempSingle + "," + animationRegisterCache.vertexZeroConst + "," + sin + "\n";

                    code += "mov " + nrmDirection + ".y," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";

                    code += "sub " + sin + "," + animationRegisterCache.vertexOneConst + "," + tempSingle + "\n";
                    code += "mul " + sin + "," + sin + "," + nrmDirection + ".x\n";

                    code += "mov " + cos + "," + nrmDirection + ".z\n";
                    code += "neg " + cos + "," + cos + "\n";
                    code += "sub " + o_temp + "," + animationRegisterCache.vertexOneConst + "," + cos + "\n";
                    code += "mul " + o_temp + "," + R + ".x," + tempSingle + "\n";
                    code += "add " + cos + "," + cos + "," + o_temp + "\n";

                    code += "mul " + R + ".x," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".x\n";
                    code += "mul " + R + ".y," + sin + "," + animationRegisterCache.scaleAndRotateTarget + ".z\n";
                    code += "mul " + R + ".z," + sin + "," + animationRegisterCache.scaleAndRotateTarget + ".x\n";
                    code += "mul " + R + ".w," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".z\n";

                    code += "sub " + animationRegisterCache.scaleAndRotateTarget + ".x," + R + ".x," + R + ".y\n";
                    code += "add " + animationRegisterCache.scaleAndRotateTarget + ".z," + R + ".z," + R + ".w\n";

                    for (i = 0; i < len; i++) {
                        //just repeat the calculate above
                        //because of the limited registers, no need to optimise
                        code += "sub " + nrmDirection + ".xyz," + positionAttribute + ".xyz," + animationRegisterCache.positionTarget + ".xyz\n";
                        code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                        code += "mov " + sin + "," + nrmDirection + ".y\n";
                        code += "mul " + cos + "," + sin + "," + sin + "\n";
                        code += "sub " + cos + "," + animationRegisterCache.vertexOneConst + "," + cos + "\n";
                        code += "sqt " + cos + "," + cos + "\n";
                        code += "mul " + R + ".x," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".y\n";
                        code += "mul " + R + ".y," + sin + "," + animationRegisterCache.rotationRegisters[i] + ".z\n";
                        code += "mul " + R + ".z," + sin + "," + animationRegisterCache.rotationRegisters[i] + ".y\n";
                        code += "mul " + R + ".w," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".z\n";
                        code += "sub " + animationRegisterCache.rotationRegisters[i] + ".y," + R + ".x," + R + ".y\n";
                        code += "add " + animationRegisterCache.rotationRegisters[i] + ".z," + R + ".z," + R + ".w\n";
                        code += "abs " + R + ".y," + nrmDirection + ".y\n";
                        code += "sge " + R + ".z," + R + ".y," + animationRegisterCache.vertexOneConst + "\n";
                        code += "mul " + R + ".x," + R + ".y," + nrmDirection + ".y\n";
                        code += "mov " + nrmDirection + ".y," + animationRegisterCache.vertexZeroConst + "\n";
                        code += "dp3 " + sin + "," + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                        code += "sge " + tempSingle + "," + animationRegisterCache.vertexZeroConst + "," + sin + "\n";
                        code += "mov " + nrmDirection + ".y," + animationRegisterCache.vertexZeroConst + "\n";
                        code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                        code += "sub " + sin + "," + animationRegisterCache.vertexOneConst + "," + tempSingle + "\n";
                        code += "mul " + sin + "," + sin + "," + nrmDirection + ".x\n";
                        code += "mov " + cos + "," + nrmDirection + ".z\n";
                        code += "neg " + cos + "," + cos + "\n";
                        code += "sub " + o_temp + "," + animationRegisterCache.vertexOneConst + "," + cos + "\n";
                        code += "mul " + o_temp + "," + R + ".x," + tempSingle + "\n";
                        code += "add " + cos + "," + cos + "," + o_temp + "\n";
                        code += "mul " + R + ".x," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".x\n";
                        code += "mul " + R + ".y," + sin + "," + animationRegisterCache.rotationRegisters[i] + ".z\n";
                        code += "mul " + R + ".z," + sin + "," + animationRegisterCache.rotationRegisters[i] + ".x\n";
                        code += "mul " + R + ".w," + cos + "," + animationRegisterCache.rotationRegisters[i] + ".z\n";
                        code += "sub " + animationRegisterCache.rotationRegisters[i] + ".x," + R + ".x," + R + ".y\n";
                        code += "add " + animationRegisterCache.rotationRegisters[i] + ".z," + R + ".z," + R + ".w\n";
                    }
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleRotateToPositionNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleRotateToPositionNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var offset = param[ParticleRotateToPositionNode.POSITION_VECTOR3D];
                if (!offset)
                    throw (new Error("there is no " + ParticleRotateToPositionNode.POSITION_VECTOR3D + " in param!"));

                this._pOneData[0] = offset.x;
                this._pOneData[1] = offset.y;
                this._pOneData[2] = offset.z;
            };
            ParticleRotateToPositionNode.MATRIX_INDEX = 0;

            ParticleRotateToPositionNode.POSITION_INDEX = 1;

            ParticleRotateToPositionNode.POSITION_VECTOR3D = "RotateToPositionVector3D";
            return ParticleRotateToPositionNode;
        })(animators.ParticleNodeBase);
        animators.ParticleRotateToPositionNode = ParticleRotateToPositionNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to set the starting rotational velocity of a particle.
        */
        var ParticleRotationalVelocityNode = (function (_super) {
            __extends(ParticleRotationalVelocityNode, _super);
            /**
            * Creates a new <code>ParticleRotationalVelocityNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            */
            function ParticleRotationalVelocityNode(mode /*uint*/ , rotationalVelocity) {
                if (typeof rotationalVelocity === "undefined") { rotationalVelocity = null; }
                _super.call(this, "ParticleRotationalVelocity", mode, 4);

                this._pStateClass = animators.ParticleRotationalVelocityState;

                this._iRotationalVelocity = rotationalVelocity || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleRotationalVelocityNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var rotationRegister = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleRotationalVelocityNode.ROTATIONALVELOCITY_INDEX, rotationRegister.index);

                var nrmVel = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(nrmVel, 1);

                var xAxis = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(xAxis, 1);

                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                animationRegisterCache.addVertexTempUsages(temp, 1);
                var Rtemp = new ShaderRegisterElement(temp.regName, temp.index);
                var R_rev = animationRegisterCache.getFreeVertexVectorTemp();
                R_rev = new ShaderRegisterElement(R_rev.regName, R_rev.index);

                var cos = new ShaderRegisterElement(Rtemp.regName, Rtemp.index, 3);
                var sin = new ShaderRegisterElement(R_rev.regName, R_rev.index, 3);

                animationRegisterCache.removeVertexTempUsage(nrmVel);
                animationRegisterCache.removeVertexTempUsage(xAxis);
                animationRegisterCache.removeVertexTempUsage(temp);

                var code = "";
                code += "mov " + nrmVel + ".xyz," + rotationRegister + ".xyz\n";
                code += "mov " + nrmVel + ".w," + animationRegisterCache.vertexZeroConst + "\n";

                code += "mul " + cos + "," + animationRegisterCache.vertexTime + "," + rotationRegister + ".w\n";

                code += "sin " + sin + "," + cos + "\n";
                code += "cos " + cos + "," + cos + "\n";

                code += "mul " + Rtemp + ".xyz," + sin + "," + nrmVel + ".xyz\n";

                code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";

                //nrmVel and xAxis are used as temp register
                code += "crs " + nrmVel + ".xyz," + Rtemp + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";

                code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                code += "dp3 " + xAxis + ".w," + Rtemp + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz\n";
                code += "neg " + nrmVel + ".w," + xAxis + ".w\n";

                code += "crs " + Rtemp + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";

                //use cos as R_rev.w
                code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                code += "add " + Rtemp + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
                code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";

                code += "add " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";

                var len = animationRegisterCache.rotationRegisters.length;
                for (var i = 0; i < len; i++) {
                    code += "mov " + nrmVel + ".xyz," + rotationRegister + ".xyz\n";
                    code += "mov " + nrmVel + ".w," + animationRegisterCache.vertexZeroConst + "\n";
                    code += "mul " + cos + "," + animationRegisterCache.vertexTime + "," + rotationRegister + ".w\n";
                    code += "sin " + sin + "," + cos + "\n";
                    code += "cos " + cos + "," + cos + "\n";
                    code += "mul " + Rtemp + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                    code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                    code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
                    code += "crs " + nrmVel + ".xyz," + Rtemp + ".xyz," + animationRegisterCache.rotationRegisters[i] + ".xyz\n";
                    code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterCache.rotationRegisters[i] + "\n";
                    code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                    code += "dp3 " + xAxis + ".w," + Rtemp + ".xyz," + animationRegisterCache.rotationRegisters[i] + "\n";
                    code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
                    code += "crs " + Rtemp + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
                    code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                    code += "add " + Rtemp + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
                    code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
                    code += "add " + animationRegisterCache.rotationRegisters[i] + "," + Rtemp + ".xyz," + xAxis + ".xyz\n";
                }
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleRotationalVelocityNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleRotationalVelocityNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                //(Vector3d.x,Vector3d.y,Vector3d.z) is rotation axis,Vector3d.w is cycle duration
                var rotate = param[ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D];
                if (!rotate)
                    throw (new Error("there is no " + ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D + " in param!"));

                if (rotate.length <= 0)
                    rotate.z = 1; //set the default direction
                else
                    rotate.normalize();

                this._pOneData[0] = rotate.x;
                this._pOneData[1] = rotate.y;
                this._pOneData[2] = rotate.z;
                if (rotate.w <= 0)
                    throw (new Error("the cycle duration must greater than zero"));

                // it's used as angle/2 in agal
                this._pOneData[3] = Math.PI / rotate.w;
            };
            ParticleRotationalVelocityNode.ROTATIONALVELOCITY_INDEX = 0;

            ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D = "RotationalVelocityVector3D";
            return ParticleRotationalVelocityNode;
        })(animators.ParticleNodeBase);
        animators.ParticleRotationalVelocityNode = ParticleRotationalVelocityNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A particle animation node used to control the scale variation of a particle over time.
        */
        var ParticleScaleNode = (function (_super) {
            __extends(ParticleScaleNode, _super);
            /**
            * Creates a new <code>ParticleScaleNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of animation independent of particle duration. Defaults to false.
            * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the animation cycle. Defaults to false.
            * @param    [optional] minScale        Defines the default min scale transform of the node, when in global mode. Defaults to 1.
            * @param    [optional] maxScale        Defines the default max color transform of the node, when in global mode. Defaults to 1.
            * @param    [optional] cycleDuration   Defines the default duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
            * @param    [optional] cyclePhase      Defines the default phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
            */
            function ParticleScaleNode(mode /*uint*/ , usesCycle, usesPhase, minScale, maxScale, cycleDuration, cyclePhase) {
                if (typeof minScale === "undefined") { minScale = 1; }
                if (typeof maxScale === "undefined") { maxScale = 1; }
                if (typeof cycleDuration === "undefined") { cycleDuration = 1; }
                if (typeof cyclePhase === "undefined") { cyclePhase = 0; }
                _super.call(this, "ParticleScale", mode, (usesCycle && usesPhase) ? 4 : ((usesCycle || usesPhase) ? 3 : 2), 3);

                this._pStateClass = animators.ParticleScaleState;

                this._iUsesCycle = usesCycle;
                this._iUsesPhase = usesPhase;

                this._iMinScale = minScale;
                this._iMaxScale = maxScale;
                this._iCycleDuration = cycleDuration;
                this._iCyclePhase = cyclePhase;
            }
            /**
            * @inheritDoc
            */
            ParticleScaleNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                var temp = animationRegisterCache.getFreeVertexSingleTemp();

                var scaleRegister = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleScaleNode.SCALE_INDEX, scaleRegister.index);

                if (this._iUsesCycle) {
                    code += "mul " + temp + "," + animationRegisterCache.vertexTime + "," + scaleRegister + ".z\n";

                    if (this._iUsesPhase)
                        code += "add " + temp + "," + temp + "," + scaleRegister + ".w\n";

                    code += "sin " + temp + "," + temp + "\n";
                }

                code += "mul " + temp + "," + scaleRegister + ".y," + ((this._iUsesCycle) ? temp : animationRegisterCache.vertexLife) + "\n";
                code += "add " + temp + "," + scaleRegister + ".x," + temp + "\n";
                code += "mul " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp + "\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleScaleNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleScaleNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var scale = param[ParticleScaleNode.SCALE_VECTOR3D];
                if (!scale)
                    throw (new Error("there is no " + ParticleScaleNode.SCALE_VECTOR3D + " in param!"));

                if (this._iUsesCycle) {
                    this._pOneData[0] = (scale.x + scale.y) / 2;
                    this._pOneData[1] = Math.abs(scale.x - scale.y) / 2;
                    if (scale.z <= 0)
                        throw (new Error("the cycle duration must be greater than zero"));
                    this._pOneData[2] = Math.PI * 2 / scale.z;
                    if (this._iUsesPhase)
                        this._pOneData[3] = scale.w * Math.PI / 180;
                } else {
                    this._pOneData[0] = scale.x;
                    this._pOneData[1] = scale.y - scale.x;
                }
            };
            ParticleScaleNode.SCALE_INDEX = 0;

            ParticleScaleNode.SCALE_VECTOR3D = "ScaleVector3D";
            return ParticleScaleNode;
        })(animators.ParticleNodeBase);
        animators.ParticleScaleNode = ParticleScaleNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        var ParticleSegmentedColorNode = (function (_super) {
            __extends(ParticleSegmentedColorNode, _super);
            function ParticleSegmentedColorNode(usesMultiplier, usesOffset, numSegmentPoint /*int*/ , startColor, endColor, segmentPoints) {
                //because of the stage3d register limitation, it only support the global mode
                _super.call(this, "ParticleSegmentedColor", animators.ParticlePropertiesMode.GLOBAL, 0, animators.ParticleAnimationSet.COLOR_PRIORITY);

                this._pStateClass = animators.ParticleSegmentedColorState;

                if (numSegmentPoint > 4)
                    throw (new Error("the numSegmentPoint must be less or equal 4"));
                this._iUsesMultiplier = usesMultiplier;
                this._iUsesOffset = usesOffset;
                this._iNumSegmentPoint = numSegmentPoint;
                this._iStartColor = startColor;
                this._iEndColor = endColor;
                this._iSegmentPoints = segmentPoints;
            }
            /**
            * @inheritDoc
            */
            ParticleSegmentedColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                if (this._iUsesMultiplier)
                    particleAnimationSet.hasColorMulNode = true;
                if (this._iUsesOffset)
                    particleAnimationSet.hasColorAddNode = true;
            };

            /**
            * @inheritDoc
            */
            ParticleSegmentedColorNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var code = "";
                if (animationRegisterCache.needFragmentAnimation) {
                    var accMultiplierColor;

                    //var accOffsetColor:ShaderRegisterElement;
                    if (this._iUsesMultiplier) {
                        accMultiplierColor = animationRegisterCache.getFreeVertexVectorTemp();
                        animationRegisterCache.addVertexTempUsages(accMultiplierColor, 1);
                    }

                    var tempColor = animationRegisterCache.getFreeVertexVectorTemp();
                    animationRegisterCache.addVertexTempUsages(tempColor, 1);

                    var temp = animationRegisterCache.getFreeVertexVectorTemp();
                    var accTime = new ShaderRegisterElement(temp.regName, temp.index, 0);
                    var tempTime = new ShaderRegisterElement(temp.regName, temp.index, 1);

                    if (this._iUsesMultiplier)
                        animationRegisterCache.removeVertexTempUsage(accMultiplierColor);

                    animationRegisterCache.removeVertexTempUsage(tempColor);

                    //for saving all the life values (at most 4)
                    var lifeTimeRegister = animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.setRegisterIndex(this, ParticleSegmentedColorNode.TIME_DATA_INDEX, lifeTimeRegister.index);

                    var i;

                    var startMulValue;
                    var deltaMulValues;
                    if (this._iUsesMultiplier) {
                        startMulValue = animationRegisterCache.getFreeVertexConstant();
                        animationRegisterCache.setRegisterIndex(this, ParticleSegmentedColorNode.START_MULTIPLIER_INDEX, startMulValue.index);
                        deltaMulValues = new Array();
                        for (i = 0; i < this._iNumSegmentPoint + 1; i++)
                            deltaMulValues.push(animationRegisterCache.getFreeVertexConstant());
                    }

                    var startOffsetValue;
                    var deltaOffsetValues;
                    if (this._iUsesOffset) {
                        startOffsetValue = animationRegisterCache.getFreeVertexConstant();
                        animationRegisterCache.setRegisterIndex(this, ParticleSegmentedColorNode.START_OFFSET_INDEX, startOffsetValue.index);
                        deltaOffsetValues = new Array();
                        for (i = 0; i < this._iNumSegmentPoint + 1; i++)
                            deltaOffsetValues.push(animationRegisterCache.getFreeVertexConstant());
                    }

                    if (this._iUsesMultiplier)
                        code += "mov " + accMultiplierColor + "," + startMulValue + "\n";
                    if (this._iUsesOffset)
                        code += "add " + animationRegisterCache.colorAddTarget + "," + animationRegisterCache.colorAddTarget + "," + startOffsetValue + "\n";

                    for (i = 0; i < this._iNumSegmentPoint; i++) {
                        switch (i) {
                            case 0:
                                code += "min " + tempTime + "," + animationRegisterCache.vertexLife + "," + lifeTimeRegister + ".x\n";
                                break;
                            case 1:
                                code += "sub " + accTime + "," + animationRegisterCache.vertexLife + "," + lifeTimeRegister + ".x\n";
                                code += "max " + tempTime + "," + accTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                                code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".y\n";
                                break;
                            case 2:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".y\n";
                                code += "max " + tempTime + "," + accTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                                code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".z\n";
                                break;
                            case 3:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".z\n";
                                code += "max " + tempTime + "," + accTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                                code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".w\n";
                                break;
                        }
                        if (this._iUsesMultiplier) {
                            code += "mul " + tempColor + "," + tempTime + "," + deltaMulValues[i] + "\n";
                            code += "add " + accMultiplierColor + "," + accMultiplierColor + "," + tempColor + "\n";
                        }
                        if (this._iUsesOffset) {
                            code += "mul " + tempColor + "," + tempTime + "," + deltaOffsetValues[i] + "\n";
                            code += "add " + animationRegisterCache.colorAddTarget + "," + animationRegisterCache.colorAddTarget + "," + tempColor + "\n";
                        }
                    }

                    //for the last segment:
                    if (this._iNumSegmentPoint == 0)
                        tempTime = animationRegisterCache.vertexLife;
                    else {
                        switch (this._iNumSegmentPoint) {
                            case 1:
                                code += "sub " + accTime + "," + animationRegisterCache.vertexLife + "," + lifeTimeRegister + ".x\n";
                                break;
                            case 2:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".y\n";
                                break;
                            case 3:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".z\n";
                                break;
                            case 4:
                                code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".w\n";
                                break;
                        }
                        code += "max " + tempTime + "," + accTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                    }
                    if (this._iUsesMultiplier) {
                        code += "mul " + tempColor + "," + tempTime + "," + deltaMulValues[this._iNumSegmentPoint] + "\n";
                        code += "add " + accMultiplierColor + "," + accMultiplierColor + "," + tempColor + "\n";
                        code += "mul " + animationRegisterCache.colorMulTarget + "," + animationRegisterCache.colorMulTarget + "," + accMultiplierColor + "\n";
                    }
                    if (this._iUsesOffset) {
                        code += "mul " + tempColor + "," + tempTime + "," + deltaOffsetValues[this._iNumSegmentPoint] + "\n";
                        code += "add " + animationRegisterCache.colorAddTarget + "," + animationRegisterCache.colorAddTarget + "," + tempColor + "\n";
                    }
                }
                return code;
            };
            ParticleSegmentedColorNode.START_MULTIPLIER_INDEX = 0;

            ParticleSegmentedColorNode.START_OFFSET_INDEX = 1;

            ParticleSegmentedColorNode.TIME_DATA_INDEX = 2;
            return ParticleSegmentedColorNode;
        })(animators.ParticleNodeBase);
        animators.ParticleSegmentedColorNode = ParticleSegmentedColorNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used when a spritesheet texture is required to animate the particle.
        * NB: to enable use of this node, the <code>repeat</code> property on the material has to be set to true.
        */
        var ParticleSpriteSheetNode = (function (_super) {
            __extends(ParticleSpriteSheetNode, _super);
            /**
            * Creates a new <code>ParticleSpriteSheetNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] numColumns      Defines the number of columns in the spritesheet, when in global mode. Defaults to 1.
            * @param    [optional] numRows         Defines the number of rows in the spritesheet, when in global mode. Defaults to 1.
            * @param    [optional] cycleDuration   Defines the default cycle duration in seconds, when in global mode. Defaults to 1.
            * @param    [optional] cyclePhase      Defines the default cycle phase, when in global mode. Defaults to 0.
            * @param    [optional] totalFrames     Defines the total number of frames used by the spritesheet, when in global mode. Defaults to the number defined by numColumns and numRows.
            * @param    [optional] looping         Defines whether the spritesheet animation is set to loop indefinitely. Defaults to true.
            */
            function ParticleSpriteSheetNode(mode /*uint*/ , usesCycle, usesPhase, numColumns, numRows, cycleDuration, cyclePhase, totalFrames) {
                if (typeof numColumns === "undefined") { numColumns = 1; }
                if (typeof numRows === "undefined") { numRows = 1; }
                if (typeof cycleDuration === "undefined") { cycleDuration = 1; }
                if (typeof cyclePhase === "undefined") { cyclePhase = 0; }
                if (typeof totalFrames === "undefined") { totalFrames = Number.MAX_VALUE; }
                _super.call(this, "ParticleSpriteSheet", mode, usesCycle ? (usesPhase ? 3 : 2) : 1, animators.ParticleAnimationSet.POST_PRIORITY + 1);

                this._pStateClass = animators.ParticleSpriteSheetState;

                this._iUsesCycle = usesCycle;
                this._iUsesPhase = usesPhase;

                this._iNumColumns = numColumns;
                this._iNumRows = numRows;
                this._iCyclePhase = cyclePhase;
                this._iCycleDuration = cycleDuration;
                this._iTotalFrames = Math.min(totalFrames, numColumns * numRows);
            }
            Object.defineProperty(ParticleSpriteSheetNode.prototype, "numColumns", {
                /**
                * Defines the number of columns in the spritesheet, when in global mode. Defaults to 1. Read only.
                */
                get: function () {
                    return this._iNumColumns;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleSpriteSheetNode.prototype, "numRows", {
                /**
                * Defines the number of rows in the spritesheet, when in global mode. Defaults to 1. Read only.
                */
                get: function () {
                    return this._iNumRows;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleSpriteSheetNode.prototype, "totalFrames", {
                /**
                * Defines the total number of frames used by the spritesheet, when in global mode. Defaults to the number defined by numColumns and numRows. Read only.
                */
                get: function () {
                    return this._iTotalFrames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            ParticleSpriteSheetNode.prototype.getAGALUVCode = function (pass, animationRegisterCache) {
                //get 2 vc
                var uvParamConst1 = animationRegisterCache.getFreeVertexConstant();
                var uvParamConst2 = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleSpriteSheetNode.UV_INDEX_0, uvParamConst1.index);
                animationRegisterCache.setRegisterIndex(this, ParticleSpriteSheetNode.UV_INDEX_1, uvParamConst2.index);

                var uTotal = new ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 0);
                var uStep = new ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 1);
                var vStep = new ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 2);

                var uSpeed = new ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 0);
                var cycle = new ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 1);
                var phaseTime = new ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 2);

                var temp = animationRegisterCache.getFreeVertexVectorTemp();
                var time = new ShaderRegisterElement(temp.regName, temp.index, 0);
                var vOffset = new ShaderRegisterElement(temp.regName, temp.index, 1);
                temp = new ShaderRegisterElement(temp.regName, temp.index, 2);
                var temp2 = new ShaderRegisterElement(temp.regName, temp.index, 3);

                var u = new ShaderRegisterElement(animationRegisterCache.uvTarget.regName, animationRegisterCache.uvTarget.index, 0);
                var v = new ShaderRegisterElement(animationRegisterCache.uvTarget.regName, animationRegisterCache.uvTarget.index, 1);

                var code = "";

                //scale uv
                code += "mul " + u + "," + u + "," + uStep + "\n";
                if (this._iNumRows > 1)
                    code += "mul " + v + "," + v + "," + vStep + "\n";

                if (this._iUsesCycle) {
                    if (this._iUsesPhase)
                        code += "add " + time + "," + animationRegisterCache.vertexTime + "," + phaseTime + "\n";
                    else
                        code += "mov " + time + "," + animationRegisterCache.vertexTime + "\n";
                    code += "div " + time + "," + time + "," + cycle + "\n";
                    code += "frc " + time + "," + time + "\n";
                    code += "mul " + time + "," + time + "," + cycle + "\n";
                    code += "mul " + temp + "," + time + "," + uSpeed + "\n";
                } else
                    code += "mul " + temp.toString() + "," + animationRegisterCache.vertexLife + "," + uTotal + "\n";

                if (this._iNumRows > 1) {
                    code += "frc " + temp2 + "," + temp + "\n";
                    code += "sub " + vOffset + "," + temp + "," + temp2 + "\n";
                    code += "mul " + vOffset + "," + vOffset + "," + vStep + "\n";
                    code += "add " + v + "," + v + "," + vOffset + "\n";
                }

                code += "div " + temp2 + "," + temp + "," + uStep + "\n";
                code += "frc " + temp + "," + temp2 + "\n";
                code += "sub " + temp2 + "," + temp2 + "," + temp + "\n";
                code += "mul " + temp + "," + temp2 + "," + uStep + "\n";

                if (this._iNumRows > 1)
                    code += "frc " + temp + "," + temp + "\n";
                code += "add " + u + "," + u + "," + temp + "\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleSpriteSheetNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleSpriteSheetNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                particleAnimationSet.hasUVNode = true;
            };

            /**
            * @inheritDoc
            */
            ParticleSpriteSheetNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                if (this._iUsesCycle) {
                    var uvCycle = param[ParticleSpriteSheetNode.UV_VECTOR3D];
                    if (!uvCycle)
                        throw (new Error("there is no " + ParticleSpriteSheetNode.UV_VECTOR3D + " in param!"));
                    if (uvCycle.x <= 0)
                        throw (new Error("the cycle duration must be greater than zero"));
                    var uTotal = this._iTotalFrames / this._iNumColumns;
                    this._pOneData[0] = uTotal / uvCycle.x;
                    this._pOneData[1] = uvCycle.x;
                    if (this._iUsesPhase)
                        this._pOneData[2] = uvCycle.y;
                }
            };
            ParticleSpriteSheetNode.UV_INDEX_0 = 0;

            ParticleSpriteSheetNode.UV_INDEX_1 = 1;

            ParticleSpriteSheetNode.UV_VECTOR3D = "UVVector3D";
            return ParticleSpriteSheetNode;
        })(animators.ParticleNodeBase);
        animators.ParticleSpriteSheetNode = ParticleSpriteSheetNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A particle animation node used as the base node for timekeeping inside a particle. Automatically added to a particle animation set on instatiation.
        */
        var ParticleTimeNode = (function (_super) {
            __extends(ParticleTimeNode, _super);
            /**
            * Creates a new <code>ParticleTimeNode</code>
            *
            * @param    [optional] usesDuration    Defines whether the node uses the <code>duration</code> data in the static properties to determine how long a particle is visible for. Defaults to false.
            * @param    [optional] usesDelay       Defines whether the node uses the <code>delay</code> data in the static properties to determine how long a particle is hidden for. Defaults to false. Requires <code>usesDuration</code> to be true.
            * @param    [optional] usesLooping     Defines whether the node creates a looping timeframe for each particle determined by the <code>startTime</code>, <code>duration</code> and <code>delay</code> data in the static properties function. Defaults to false. Requires <code>usesLooping</code> to be true.
            */
            function ParticleTimeNode(usesDuration, usesLooping, usesDelay) {
                if (typeof usesDuration === "undefined") { usesDuration = false; }
                if (typeof usesLooping === "undefined") { usesLooping = false; }
                if (typeof usesDelay === "undefined") { usesDelay = false; }
                this._pStateClass = animators.ParticleTimeState;

                this._iUsesDuration = usesDuration;
                this._iUsesLooping = usesLooping;
                this._iUsesDelay = usesDelay;

                _super.call(this, "ParticleTime", animators.ParticlePropertiesMode.LOCAL_STATIC, 4, 0);
            }
            /**
            * @inheritDoc
            */
            ParticleTimeNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var timeStreamRegister = animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleTimeNode.TIME_STREAM_INDEX, timeStreamRegister.index);
                var timeConst = animationRegisterCache.getFreeVertexConstant();
                animationRegisterCache.setRegisterIndex(this, ParticleTimeNode.TIME_CONSTANT_INDEX, timeConst.index);

                var code = "";
                code += "sub " + animationRegisterCache.vertexTime + "," + timeConst + "," + timeStreamRegister + ".x\n";

                //if time=0,set the position to zero.
                var temp = animationRegisterCache.getFreeVertexSingleTemp();
                code += "sge " + temp + "," + animationRegisterCache.vertexTime + "," + animationRegisterCache.vertexZeroConst + "\n";
                code += "mul " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + temp + "\n";
                if (this._iUsesDuration) {
                    if (this._iUsesLooping) {
                        var div = animationRegisterCache.getFreeVertexSingleTemp();
                        if (this._iUsesDelay) {
                            code += "div " + div + "," + animationRegisterCache.vertexTime + "," + timeStreamRegister + ".z\n";
                            code += "frc " + div + "," + div + "\n";
                            code += "mul " + animationRegisterCache.vertexTime + "," + div + "," + timeStreamRegister + ".z\n";
                            code += "slt " + div + "," + animationRegisterCache.vertexTime + "," + timeStreamRegister + ".y\n";
                            code += "mul " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + div + "\n";
                        } else {
                            code += "mul " + div + "," + animationRegisterCache.vertexTime + "," + timeStreamRegister + ".w\n";
                            code += "frc " + div + "," + div + "\n";
                            code += "mul " + animationRegisterCache.vertexTime + "," + div + "," + timeStreamRegister + ".y\n";
                        }
                    } else {
                        var sge = animationRegisterCache.getFreeVertexSingleTemp();
                        code += "sge " + sge + "," + timeStreamRegister + ".y," + animationRegisterCache.vertexTime + "\n";
                        code += "mul " + animationRegisterCache.scaleAndRotateTarget + ".xyz," + animationRegisterCache.scaleAndRotateTarget + ".xyz," + sge + "\n";
                    }
                }
                code += "mul " + animationRegisterCache.vertexLife + "," + animationRegisterCache.vertexTime + "," + timeStreamRegister + ".w\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleTimeNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleTimeNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                this._pOneData[0] = param.startTime;
                this._pOneData[1] = param.duration;
                this._pOneData[2] = param.delay + param.duration;
                this._pOneData[3] = 1 / param.duration;
            };
            ParticleTimeNode.TIME_STREAM_INDEX = 0;

            ParticleTimeNode.TIME_CONSTANT_INDEX = 1;
            return ParticleTimeNode;
        })(animators.ParticleNodeBase);
        animators.ParticleTimeNode = ParticleTimeNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        var ShaderRegisterElement = away.materials.ShaderRegisterElement;

        /**
        * A particle animation node used to control the UV offset and scale of a particle over time.
        */
        var ParticleUVNode = (function (_super) {
            __extends(ParticleUVNode, _super);
            /**
            * Creates a new <code>ParticleTimeNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] cycle           Defines whether the time track is in loop mode. Defaults to false.
            * @param    [optional] scale           Defines whether the time track is in loop mode. Defaults to false.
            * @param    [optional] axis            Defines whether the time track is in loop mode. Defaults to false.
            */
            function ParticleUVNode(mode /*uint*/ , cycle, scale, axis) {
                if (typeof cycle === "undefined") { cycle = 1; }
                if (typeof scale === "undefined") { scale = 1; }
                if (typeof axis === "undefined") { axis = "x"; }
                //because of the stage3d register limitation, it only support the global mode
                _super.call(this, "ParticleUV", animators.ParticlePropertiesMode.GLOBAL, 4, animators.ParticleAnimationSet.POST_PRIORITY + 1);

                this._pStateClass = animators.ParticleUVState;

                this._cycle = cycle;
                this._scale = scale;
                this._axis = axis;

                this.updateUVData();
            }
            Object.defineProperty(ParticleUVNode.prototype, "cycle", {
                /**
                *
                */
                get: function () {
                    return this._cycle;
                },
                set: function (value) {
                    this._cycle = value;

                    this.updateUVData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleUVNode.prototype, "scale", {
                /**
                *
                */
                get: function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale = value;

                    this.updateUVData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleUVNode.prototype, "axis", {
                /**
                *
                */
                get: function () {
                    return this._axis;
                },
                set: function (value) {
                    this._axis = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleUVNode.prototype.getAGALUVCode = function (pass, animationRegisterCache) {
                var code = "";

                if (animationRegisterCache.needUVAnimation) {
                    var uvConst = animationRegisterCache.getFreeVertexConstant();
                    animationRegisterCache.setRegisterIndex(this, ParticleUVNode.UV_INDEX, uvConst.index);

                    var axisIndex = this._axis == "x" ? 0 : this._axis == "y" ? 1 : 2;
                    var target = new ShaderRegisterElement(animationRegisterCache.uvTarget.regName, animationRegisterCache.uvTarget.index, axisIndex);

                    var sin = animationRegisterCache.getFreeVertexSingleTemp();

                    if (this._scale != 1)
                        code += "mul " + target + "," + target + "," + uvConst + ".y\n";

                    code += "mul " + sin + "," + animationRegisterCache.vertexTime + "," + uvConst + ".x\n";
                    code += "sin " + sin + "," + sin + "\n";
                    code += "add " + target + "," + target + "," + sin + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleUVNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            ParticleUVNode.prototype.updateUVData = function () {
                this._iUvData = new Vector3D(Math.PI * 2 / this._cycle, this._scale, 0, 0);
            };

            /**
            * @inheritDoc
            */
            ParticleUVNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
                particleAnimationSet.hasUVNode = true;
            };
            ParticleUVNode.UV_INDEX = 0;

            ParticleUVNode.U_AXIS = "x";

            ParticleUVNode.V_AXIS = "y";
            return ParticleUVNode;
        })(animators.ParticleNodeBase);
        animators.ParticleUVNode = ParticleUVNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        /**
        * A particle animation node used to set the starting velocity of a particle.
        */
        var ParticleVelocityNode = (function (_super) {
            __extends(ParticleVelocityNode, _super);
            /**
            * Creates a new <code>ParticleVelocityNode</code>
            *
            * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
            * @param    [optional] velocity        Defines the default velocity vector of the node, used when in global mode.
            */
            function ParticleVelocityNode(mode /*uint*/ , velocity) {
                if (typeof velocity === "undefined") { velocity = null; }
                _super.call(this, "ParticleVelocity", mode, 3);

                this._pStateClass = animators.ParticleVelocityState;

                this._iVelocity = velocity || new Vector3D();
            }
            /**
            * @inheritDoc
            */
            ParticleVelocityNode.prototype.getAGALVertexCode = function (pass, animationRegisterCache) {
                var velocityValue = (this._pMode == animators.ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
                animationRegisterCache.setRegisterIndex(this, ParticleVelocityNode.VELOCITY_INDEX, velocityValue.index);

                var distance = animationRegisterCache.getFreeVertexVectorTemp();
                var code = "";
                code += "mul " + distance + "," + animationRegisterCache.vertexTime + "," + velocityValue + "\n";
                code += "add " + animationRegisterCache.positionTarget + ".xyz," + distance + "," + animationRegisterCache.positionTarget + ".xyz\n";

                if (animationRegisterCache.needVelocity)
                    code += "add " + animationRegisterCache.velocityTarget + ".xyz," + velocityValue + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleVelocityNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            ParticleVelocityNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
                var _tempVelocity = param[ParticleVelocityNode.VELOCITY_VECTOR3D];
                if (!_tempVelocity)
                    throw new Error("there is no " + ParticleVelocityNode.VELOCITY_VECTOR3D + " in param!");

                this._pOneData[0] = _tempVelocity.x;
                this._pOneData[1] = _tempVelocity.y;
                this._pOneData[2] = _tempVelocity.z;
            };
            ParticleVelocityNode.VELOCITY_INDEX = 0;

            ParticleVelocityNode.VELOCITY_VECTOR3D = "VelocityVector3D";
            return ParticleVelocityNode;
        })(animators.ParticleNodeBase);
        animators.ParticleVelocityNode = ParticleVelocityNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A skeleton animation node that uses two animation node inputs to blend a lineraly interpolated output of a skeleton pose.
        */
        var SkeletonBinaryLERPNode = (function (_super) {
            __extends(SkeletonBinaryLERPNode, _super);
            /**
            * Creates a new <code>SkeletonBinaryLERPNode</code> object.
            */
            function SkeletonBinaryLERPNode() {
                _super.call(this);

                this._pStateClass = animators.SkeletonBinaryLERPState;
            }
            /**
            * @inheritDoc
            */
            SkeletonBinaryLERPNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            return SkeletonBinaryLERPNode;
        })(animators.AnimationNodeBase);
        animators.SkeletonBinaryLERPNode = SkeletonBinaryLERPNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A skeleton animation node containing time-based animation data as individual skeleton poses.
        */
        var SkeletonClipNode = (function (_super) {
            __extends(SkeletonClipNode, _super);
            /**
            * Creates a new <code>SkeletonClipNode</code> object.
            */
            function SkeletonClipNode() {
                _super.call(this);
                this._frames = new Array();
                /**
                * Determines whether to use SLERP equations (true) or LERP equations (false) in the calculation
                * of the output skeleton pose. Defaults to false.
                */
                this.highQuality = false;

                this._pStateClass = animators.SkeletonClipState;
            }
            Object.defineProperty(SkeletonClipNode.prototype, "frames", {
                /**
                * Returns a vector of skeleton poses representing the pose of each animation frame in the clip.
                */
                get: function () {
                    return this._frames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds a skeleton pose frame to the internal timeline of the animation node.
            *
            * @param skeletonPose The skeleton pose object to add to the timeline of the node.
            * @param duration The specified duration of the frame in milliseconds.
            */
            SkeletonClipNode.prototype.addFrame = function (skeletonPose, duration /*number /*uint*/ ) {
                this._frames.push(skeletonPose);
                this._pDurations.push(duration);

                this._pNumFrames = this._pDurations.length;

                this._pStitchDirty = true;
            };

            /**
            * @inheritDoc
            */
            SkeletonClipNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };

            /**
            * @inheritDoc
            */
            SkeletonClipNode.prototype._pUpdateStitch = function () {
                _super.prototype._pUpdateStitch.call(this);

                var i = this._pNumFrames - 1;
                var p1, p2, delta;
                while (i--) {
                    this._pTotalDuration += this._pDurations[i];
                    p1 = this._frames[i].jointPoses[0].translation;
                    p2 = this._frames[i + 1].jointPoses[0].translation;
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }

                if (this._pStitchFinalFrame || !this._pLooping) {
                    this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
                    p1 = this._frames[0].jointPoses[0].translation;
                    p2 = this._frames[1].jointPoses[0].translation;
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }
            };
            return SkeletonClipNode;
        })(animators.AnimationClipNodeBase);
        animators.SkeletonClipNode = SkeletonClipNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A skeleton animation node that uses a difference input pose with a base input pose to blend a linearly interpolated output of a skeleton pose.
        */
        var SkeletonDifferenceNode = (function (_super) {
            __extends(SkeletonDifferenceNode, _super);
            /**
            * Creates a new <code>SkeletonAdditiveNode</code> object.
            */
            function SkeletonDifferenceNode() {
                _super.call(this);

                this._pStateClass = animators.SkeletonDifferenceState;
            }
            /**
            * @inheritDoc
            */
            SkeletonDifferenceNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            return SkeletonDifferenceNode;
        })(animators.AnimationNodeBase);
        animators.SkeletonDifferenceNode = SkeletonDifferenceNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A skeleton animation node that uses four directional input poses with an input direction to blend a linearly interpolated output of a skeleton pose.
        */
        var SkeletonDirectionalNode = (function (_super) {
            __extends(SkeletonDirectionalNode, _super);
            function SkeletonDirectionalNode() {
                _super.call(this);

                this._pStateClass = animators.SkeletonDirectionalState;
            }
            /**
            * @inheritDoc
            */
            SkeletonDirectionalNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            return SkeletonDirectionalNode;
        })(animators.AnimationNodeBase);
        animators.SkeletonDirectionalNode = SkeletonDirectionalNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A skeleton animation node that uses an n-dimensional array of animation node inputs to blend a lineraly interpolated output of a skeleton pose.
        */
        var SkeletonNaryLERPNode = (function (_super) {
            __extends(SkeletonNaryLERPNode, _super);
            /**
            * Creates a new <code>SkeletonNaryLERPNode</code> object.
            */
            function SkeletonNaryLERPNode() {
                _super.call(this);
                this._iInputs = new Array();

                this._pStateClass = animators.SkeletonNaryLERPState;
            }
            Object.defineProperty(SkeletonNaryLERPNode.prototype, "numInputs", {
                get: function () {
                    return this._numInputs;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns an integer representing the input index of the given skeleton animation node.
            *
            * @param input The skeleton animation node for with the input index is requested.
            */
            SkeletonNaryLERPNode.prototype.getInputIndex = function (input) {
                return this._iInputs.indexOf(input);
            };

            /**
            * Returns the skeleton animation node object that resides at the given input index.
            *
            * @param index The input index for which the skeleton animation node is requested.
            */
            SkeletonNaryLERPNode.prototype.getInputAt = function (index /*uint*/ ) {
                return this._iInputs[index];
            };

            /**
            * Adds a new skeleton animation node input to the animation node.
            */
            SkeletonNaryLERPNode.prototype.addInput = function (input) {
                this._iInputs[this._numInputs++] = input;
            };

            /**
            * @inheritDoc
            */
            SkeletonNaryLERPNode.prototype.getAnimationState = function (animator) {
                return animator.getAnimationState(this);
            };
            return SkeletonNaryLERPNode;
        })(animators.AnimationNodeBase);
        animators.SkeletonNaryLERPNode = SkeletonNaryLERPNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A vertex animation node containing time-based animation data as individual geometry obejcts.
        */
        var VertexClipNode = (function (_super) {
            __extends(VertexClipNode, _super);
            /**
            * Creates a new <code>VertexClipNode</code> object.
            */
            function VertexClipNode() {
                _super.call(this);
                this._frames = new Array();
                this._translations = new Array();

                this._pStateClass = away.animators.VertexClipState;
            }
            Object.defineProperty(VertexClipNode.prototype, "frames", {
                /**
                * Returns a vector of geometry frames representing the vertex values of each animation frame in the clip.
                */
                get: function () {
                    return this._frames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds a geometry object to the internal timeline of the animation node.
            *
            * @param geometry The geometry object to add to the timeline of the node.
            * @param duration The specified duration of the frame in milliseconds.
            * @param translation The absolute translation of the frame, used in root delta calculations for mesh movement.
            */
            VertexClipNode.prototype.addFrame = function (geometry, duration /*uint*/ , translation) {
                if (typeof translation === "undefined") { translation = null; }
                this._frames.push(geometry);
                this._pDurations.push(duration);
                this._translations.push(translation || new away.geom.Vector3D());

                this._pNumFrames = this._pDurations.length;

                this._pStitchDirty = true;
            };

            /**
            * @inheritDoc
            */
            VertexClipNode.prototype._pUpdateStitch = function () {
                _super.prototype._pUpdateStitch.call(this);

                var i = this._pNumFrames - 1;
                var p1, p2, delta;
                while (i--) {
                    this._pTotalDuration += this._pDurations[i];
                    p1 = this._translations[i];
                    p2 = this._translations[i + 1];
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }

                if (this._pNumFrames > 1 && (this._pStitchFinalFrame || !this._pLooping)) {
                    this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
                    p1 = this._translations[0];
                    p2 = this._translations[1];
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }
            };
            return VertexClipNode;
        })(animators.AnimationClipNodeBase);
        animators.VertexClipNode = VertexClipNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        *
        */
        var AnimationStateBase = (function () {
            function AnimationStateBase(animator, animationNode) {
                this._pRootDelta = new away.geom.Vector3D();
                this._pPositionDeltaDirty = true;
                this._pStartTime = 0;
                this._pAnimator = animator;
                this._pAnimationNode = animationNode;
            }
            Object.defineProperty(AnimationStateBase.prototype, "positionDelta", {
                /**
                * Returns a 3d vector representing the translation delta of the animating entity for the current timestep of animation
                */
                get: function () {
                    if (this._pPositionDeltaDirty) {
                        this._pUpdatePositionDelta();
                    }

                    return this._pRootDelta;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Resets the start time of the node to a  new value.
            *
            * @param startTime The absolute start time (in milliseconds) of the node's starting time.
            */
            AnimationStateBase.prototype.offset = function (startTime) {
                this._pStartTime = startTime;

                this._pPositionDeltaDirty = true;
            };

            /**
            * Updates the configuration of the node to its current state.
            *
            * @param time The absolute time (in milliseconds) of the animator's play head position.
            *
            * @see away.animators.AnimatorBase#update()
            */
            AnimationStateBase.prototype.update = function (time) {
                if (this._pTime == time - this._pStartTime) {
                    return;
                }

                this._pUpdateTime(time);
            };

            /**
            * Sets the animation phase of the node.
            *
            * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
            */
            AnimationStateBase.prototype.phase = function (value) {
            };

            /**
            * Updates the node's internal playhead position.
            *
            * @param time The local time (in milliseconds) of the node's playhead position.
            */
            AnimationStateBase.prototype._pUpdateTime = function (time) {
                this._pTime = time - this._pStartTime;

                this._pPositionDeltaDirty = true;
            };

            /**
            * Updates the node's root delta position
            */
            AnimationStateBase.prototype._pUpdatePositionDelta = function () {
            };
            return AnimationStateBase;
        })();
        animators.AnimationStateBase = AnimationStateBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * ...
        */
        var ParticleStateBase = (function (_super) {
            __extends(ParticleStateBase, _super);
            function ParticleStateBase(animator, particleNode, needUpdateTime) {
                if (typeof needUpdateTime === "undefined") { needUpdateTime = false; }
                _super.call(this, animator, particleNode);
                this._pDynamicProperties = new Array();
                this._pDynamicPropertiesDirty = new Object();

                this._particleNode = particleNode;
                this._pNeedUpdateTime = needUpdateTime;
            }
            Object.defineProperty(ParticleStateBase.prototype, "needUpdateTime", {
                get: function () {
                    return this._pNeedUpdateTime;
                },
                enumerable: true,
                configurable: true
            });

            ParticleStateBase.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
            };

            ParticleStateBase.prototype._pUpdateDynamicProperties = function (animationSubGeometry) {
                this._pDynamicPropertiesDirty[animationSubGeometry._iUniqueId] = true;

                var animationParticles = animationSubGeometry.animationParticles;
                var vertexData = animationSubGeometry.vertexData;
                var totalLenOfOneVertex = animationSubGeometry.totalLenOfOneVertex;
                var dataLength = this._particleNode.dataLength;
                var dataOffset = this._particleNode._iDataOffset;
                var vertexLength;

                //			var particleOffset:number /*uint*/;
                var startingOffset;
                var vertexOffset;
                var data;
                var animationParticle;

                //			var numParticles:number /*uint*/ = _positions.length/dataLength;
                var numParticles = this._pDynamicProperties.length;
                var i = 0;
                var j = 0;
                var k = 0;

                while (i < numParticles) {
                    while (j < numParticles && (animationParticle = animationParticles[j]).index == i) {
                        data = this._pDynamicProperties[i];
                        vertexLength = animationParticle.numVertices * totalLenOfOneVertex;
                        startingOffset = animationParticle.startVertexIndex * totalLenOfOneVertex + dataOffset;

                        for (k = 0; k < vertexLength; k += totalLenOfOneVertex) {
                            vertexOffset = startingOffset + k;

                            for (k = 0; k < vertexLength; k += totalLenOfOneVertex) {
                                vertexOffset = startingOffset + k;
                                vertexData[vertexOffset++] = data.x;
                                vertexData[vertexOffset++] = data.y;
                                vertexData[vertexOffset++] = data.z;

                                if (dataLength == 4)
                                    vertexData[vertexOffset++] = data.w;
                            }
                            //loop through each value in the particle vertex
                            //						switch(dataLength) {
                            //							case 4:
                            //								vertexData[vertexOffset++] = _positions[particleOffset++];
                            //							case 3:
                            //								vertexData[vertexOffset++] = _positions[particleOffset++];
                            //							case 2:
                            //								vertexData[vertexOffset++] = _positions[particleOffset++];
                            //							case 1:
                            //								vertexData[vertexOffset++] = _positions[particleOffset++];
                            //						}
                        }
                        j++;
                    }
                    i++;
                }

                animationSubGeometry.invalidateBuffer();
            };
            return ParticleStateBase;
        })(animators.AnimationStateBase);
        animators.ParticleStateBase = ParticleStateBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;

        /**
        * ...
        */
        var ParticleAccelerationState = (function (_super) {
            __extends(ParticleAccelerationState, _super);
            function ParticleAccelerationState(animator, particleAccelerationNode) {
                _super.call(this, animator, particleAccelerationNode);

                this._particleAccelerationNode = particleAccelerationNode;
                this._acceleration = this._particleAccelerationNode._acceleration;

                this.updateAccelerationData();
            }
            Object.defineProperty(ParticleAccelerationState.prototype, "acceleration", {
                /**
                * Defines the acceleration vector of the state, used when in global mode.
                */
                get: function () {
                    return this._acceleration;
                },
                set: function (value) {
                    this._acceleration.x = value.x;
                    this._acceleration.y = value.y;
                    this._acceleration.z = value.z;

                    this.updateAccelerationData();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleAccelerationState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleAccelerationNode.ACCELERATION_INDEX);

                if (this._particleAccelerationNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC)
                    animationSubGeometry.activateVertexBuffer(index, this._particleAccelerationNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                else
                    animationRegisterCache.setVertexConst(index, this._halfAcceleration.x, this._halfAcceleration.y, this._halfAcceleration.z);
            };

            ParticleAccelerationState.prototype.updateAccelerationData = function () {
                if (this._particleAccelerationNode.mode == animators.ParticlePropertiesMode.GLOBAL)
                    this._halfAcceleration = new Vector3D(this._acceleration.x / 2, this._acceleration.y / 2, this._acceleration.z / 2);
            };
            return ParticleAccelerationState;
        })(animators.ParticleStateBase);
        animators.ParticleAccelerationState = ParticleAccelerationState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;

        /**
        * ...
        */
        var ParticleBezierCurveState = (function (_super) {
            __extends(ParticleBezierCurveState, _super);
            function ParticleBezierCurveState(animator, particleBezierCurveNode) {
                _super.call(this, animator, particleBezierCurveNode);

                this._particleBezierCurveNode = particleBezierCurveNode;
                this._controlPoint = this._particleBezierCurveNode._iControlPoint;
                this._endPoint = this._particleBezierCurveNode._iEndPoint;
            }
            Object.defineProperty(ParticleBezierCurveState.prototype, "controlPoint", {
                /**
                * Defines the default control point of the node, used when in global mode.
                */
                get: function () {
                    return this._controlPoint;
                },
                set: function (value) {
                    this._controlPoint = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleBezierCurveState.prototype, "endPoint", {
                /**
                * Defines the default end point of the node, used when in global mode.
                */
                get: function () {
                    return this._endPoint;
                },
                set: function (value) {
                    this._endPoint = value;
                },
                enumerable: true,
                configurable: true
            });


            ParticleBezierCurveState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var controlIndex = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleBezierCurveNode.BEZIER_CONTROL_INDEX);
                var endIndex = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleBezierCurveNode.BEZIER_END_INDEX);

                if (this._particleBezierCurveNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                    animationSubGeometry.activateVertexBuffer(controlIndex, this._particleBezierCurveNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                    animationSubGeometry.activateVertexBuffer(endIndex, this._particleBezierCurveNode._iDataOffset + 3, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                } else {
                    animationRegisterCache.setVertexConst(controlIndex, this._controlPoint.x, this._controlPoint.y, this._controlPoint.z);
                    animationRegisterCache.setVertexConst(endIndex, this._endPoint.x, this._endPoint.y, this._endPoint.z);
                }
            };
            return ParticleBezierCurveState;
        })(animators.ParticleStateBase);
        animators.ParticleBezierCurveState = ParticleBezierCurveState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Matrix3D = away.geom.Matrix3D;
        var Orientation3D = away.geom.Orientation3D;

        var MathConsts = away.geom.MathConsts;

        /**
        * ...
        */
        var ParticleBillboardState = (function (_super) {
            __extends(ParticleBillboardState, _super);
            /**
            *
            */
            function ParticleBillboardState(animator, particleNode) {
                _super.call(this, animator, particleNode);
                this._matrix = new Matrix3D;

                this._billboardAxis = particleNode._iBillboardAxis;
            }
            ParticleBillboardState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var comps;
                if (this._billboardAxis) {
                    var pos = renderable.sourceEntity.sceneTransform.position;
                    var look = camera.sceneTransform.position.subtract(pos);
                    var right = look.crossProduct(this._billboardAxis);
                    right.normalize();
                    look = this.billboardAxis.crossProduct(right);
                    look.normalize();

                    //create a quick inverse projection matrix
                    this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                    comps = this._matrix.decompose(Orientation3D.AXIS_ANGLE);
                    this._matrix.copyColumnFrom(0, right);
                    this._matrix.copyColumnFrom(1, this.billboardAxis);
                    this._matrix.copyColumnFrom(2, look);
                    this._matrix.copyColumnFrom(3, pos);
                    this._matrix.appendRotation(-comps[1].w * MathConsts.RADIANS_TO_DEGREES, comps[1]);
                } else {
                    //create a quick inverse projection matrix
                    this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                    this._matrix.append(camera.inverseSceneTransform);

                    //decompose using axis angle rotations
                    comps = this._matrix.decompose(Orientation3D.AXIS_ANGLE);

                    //recreate the matrix with just the rotation data
                    this._matrix.identity();
                    this._matrix.appendRotation(-comps[1].w * MathConsts.RADIANS_TO_DEGREES, comps[1]);
                }

                //set a new matrix transform constant
                animationRegisterCache.setVertexConstFromMatrix(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleBillboardNode.MATRIX_INDEX), this._matrix);
            };

            Object.defineProperty(ParticleBillboardState.prototype, "billboardAxis", {
                /**
                * Defines the billboard axis.
                */
                get: function () {
                    return this.billboardAxis;
                },
                set: function (value) {
                    this.billboardAxis = value ? value.clone() : null;
                    if (this.billboardAxis)
                        this.billboardAxis.normalize();
                },
                enumerable: true,
                configurable: true
            });

            return ParticleBillboardState;
        })(animators.ParticleStateBase);
        animators.ParticleBillboardState = ParticleBillboardState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;

        var Vector3D = away.geom.Vector3D;

        /**
        * ...
        * @author ...
        */
        var ParticleColorState = (function (_super) {
            __extends(ParticleColorState, _super);
            function ParticleColorState(animator, particleColorNode) {
                _super.call(this, animator, particleColorNode);

                this._particleColorNode = particleColorNode;
                this._usesMultiplier = this._particleColorNode._iUsesMultiplier;
                this._usesOffset = this._particleColorNode._iUsesOffset;
                this._usesCycle = this._particleColorNode._iUsesCycle;
                this._usesPhase = this._particleColorNode._iUsesPhase;
                this._startColor = this._particleColorNode._iStartColor;
                this._endColor = this._particleColorNode._iEndColor;
                this._cycleDuration = this._particleColorNode._iCycleDuration;
                this._cyclePhase = this._particleColorNode._iCyclePhase;

                this.updateColorData();
            }
            Object.defineProperty(ParticleColorState.prototype, "startColor", {
                /**
                * Defines the start color transform of the state, when in global mode.
                */
                get: function () {
                    return this._startColor;
                },
                set: function (value) {
                    this._startColor = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleColorState.prototype, "endColor", {
                /**
                * Defines the end color transform of the state, when in global mode.
                */
                get: function () {
                    return this._endColor;
                },
                set: function (value) {
                    this._endColor = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleColorState.prototype, "cycleDuration", {
                /**
                * Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
                */
                get: function () {
                    return this._cycleDuration;
                },
                set: function (value) {
                    this._cycleDuration = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleColorState.prototype, "cyclePhase", {
                /**
                * Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
                */
                get: function () {
                    return this._cyclePhase;
                },
                set: function (value) {
                    this._cyclePhase = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            ParticleColorState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.needFragmentAnimation) {
                    var dataOffset = this._particleColorNode._iDataOffset;
                    if (this._usesCycle)
                        animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.CYCLE_INDEX), this._cycleData.x, this._cycleData.y, this._cycleData.z, this._cycleData.w);

                    if (this._usesMultiplier) {
                        if (this._particleColorNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.START_MULTIPLIER_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.DELTA_MULTIPLIER_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                        } else {
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.START_MULTIPLIER_INDEX), this._startMultiplierData.x, this._startMultiplierData.y, this._startMultiplierData.z, this._startMultiplierData.w);
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.DELTA_MULTIPLIER_INDEX), this._deltaMultiplierData.x, this._deltaMultiplierData.y, this._deltaMultiplierData.z, this._deltaMultiplierData.w);
                        }
                    }
                    if (this._usesOffset) {
                        if (this._particleColorNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.START_OFFSET_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.DELTA_OFFSET_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                        } else {
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.START_OFFSET_INDEX), this._startOffsetData.x, this._startOffsetData.y, this._startOffsetData.z, this._startOffsetData.w);
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleColorNode.DELTA_OFFSET_INDEX), this._deltaOffsetData.x, this._deltaOffsetData.y, this._deltaOffsetData.z, this._deltaOffsetData.w);
                        }
                    }
                }
            };

            ParticleColorState.prototype.updateColorData = function () {
                if (this._usesCycle) {
                    if (this._cycleDuration <= 0)
                        throw (new Error("the cycle duration must be greater than zero"));
                    this._cycleData = new Vector3D(Math.PI * 2 / this._cycleDuration, this._cyclePhase * Math.PI / 180, 0, 0);
                }
                if (this._particleColorNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._usesCycle) {
                        if (this._usesMultiplier) {
                            this._startMultiplierData = new Vector3D((this._startColor.redMultiplier + this._endColor.redMultiplier) / 2, (this._startColor.greenMultiplier + this._endColor.greenMultiplier) / 2, (this._startColor.blueMultiplier + this._endColor.blueMultiplier) / 2, (this._startColor.alphaMultiplier + this._endColor.alphaMultiplier) / 2);
                            this._deltaMultiplierData = new Vector3D((this._endColor.redMultiplier - this._startColor.redMultiplier) / 2, (this._endColor.greenMultiplier - this._startColor.greenMultiplier) / 2, (this._endColor.blueMultiplier - this._startColor.blueMultiplier) / 2, (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier) / 2);
                        }

                        if (this._usesOffset) {
                            this._startOffsetData = new Vector3D((this._startColor.redOffset + this._endColor.redOffset) / (255 * 2), (this._startColor.greenOffset + this._endColor.greenOffset) / (255 * 2), (this._startColor.blueOffset + this._endColor.blueOffset) / (255 * 2), (this._startColor.alphaOffset + this._endColor.alphaOffset) / (255 * 2));
                            this._deltaOffsetData = new Vector3D((this._endColor.redOffset - this._startColor.redOffset) / (255 * 2), (this._endColor.greenOffset - this._startColor.greenOffset) / (255 * 2), (this._endColor.blueOffset - this._startColor.blueOffset) / (255 * 2), (this._endColor.alphaOffset - this._startColor.alphaOffset) / (255 * 2));
                        }
                    } else {
                        if (this._usesMultiplier) {
                            this._startMultiplierData = new Vector3D(this._startColor.redMultiplier, this._startColor.greenMultiplier, this._startColor.blueMultiplier, this._startColor.alphaMultiplier);
                            this._deltaMultiplierData = new Vector3D((this._endColor.redMultiplier - this._startColor.redMultiplier), (this._endColor.greenMultiplier - this._startColor.greenMultiplier), (this._endColor.blueMultiplier - this._startColor.blueMultiplier), (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier));
                        }

                        if (this._usesOffset) {
                            this._startOffsetData = new Vector3D(this._startColor.redOffset / 255, this._startColor.greenOffset / 255, this._startColor.blueOffset / 255, this._startColor.alphaOffset / 255);
                            this._deltaOffsetData = new Vector3D((this._endColor.redOffset - this._startColor.redOffset) / 255, (this._endColor.greenOffset - this._startColor.greenOffset) / 255, (this._endColor.blueOffset - this._startColor.blueOffset) / 255, (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255);
                        }
                    }
                }
            };
            return ParticleColorState;
        })(animators.ParticleStateBase);
        animators.ParticleColorState = ParticleColorState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;

        var MathConsts = away.geom.MathConsts;

        /**
        * ...
        */
        var ParticleFollowState = (function (_super) {
            __extends(ParticleFollowState, _super);
            function ParticleFollowState(animator, particleFollowNode) {
                _super.call(this, animator, particleFollowNode, true);
                this._targetPos = new Vector3D();
                this._targetEuler = new Vector3D();
                //temporary vector3D for calculation
                this._temp = new Vector3D();

                this._particleFollowNode = particleFollowNode;
                this._smooth = particleFollowNode._iSmooth;
            }
            Object.defineProperty(ParticleFollowState.prototype, "followTarget", {
                get: function () {
                    return this._followTarget;
                },
                set: function (value) {
                    this._followTarget = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleFollowState.prototype, "smooth", {
                get: function () {
                    return this._smooth;
                },
                set: function (value) {
                    this._smooth = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleFollowState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (this._followTarget) {
                    if (this._particleFollowNode._iUsesPosition) {
                        this._targetPos.x = this._followTarget.transform.position.x / renderable.sourceEntity.scaleX;
                        this._targetPos.y = this._followTarget.transform.position.y / renderable.sourceEntity.scaleY;
                        this._targetPos.z = this._followTarget.transform.position.z / renderable.sourceEntity.scaleZ;
                    }
                    if (this._particleFollowNode._iUsesRotation) {
                        this._targetEuler.x = this._followTarget.rotationX;
                        this._targetEuler.y = this._followTarget.rotationY;
                        this._targetEuler.z = this._followTarget.rotationZ;
                        this._targetEuler.scaleBy(MathConsts.DEGREES_TO_RADIANS);
                    }
                }

                //initialization
                if (!this._prePos)
                    this._prePos = this._targetPos.clone();
                if (!this._preEuler)
                    this._preEuler = this._targetEuler.clone();

                var currentTime = this._pTime / 1000;
                var previousTime = animationSubGeometry.previousTime;
                var deltaTime = currentTime - previousTime;

                var needProcess = previousTime != currentTime;

                if (this._particleFollowNode._iUsesPosition && this._particleFollowNode._iUsesRotation) {
                    if (needProcess)
                        this.processPositionAndRotation(currentTime, deltaTime, animationSubGeometry);

                    animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleFollowNode.FOLLOW_POSITION_INDEX), this._particleFollowNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                    animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleFollowNode.FOLLOW_ROTATION_INDEX), this._particleFollowNode._iDataOffset + 3, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                } else if (this._particleFollowNode._iUsesPosition) {
                    if (needProcess)
                        this.processPosition(currentTime, deltaTime, animationSubGeometry);

                    animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleFollowNode.FOLLOW_POSITION_INDEX), this._particleFollowNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                } else if (this._particleFollowNode._iUsesRotation) {
                    if (needProcess)
                        this.precessRotation(currentTime, deltaTime, animationSubGeometry);

                    animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleFollowNode.FOLLOW_ROTATION_INDEX), this._particleFollowNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                }

                this._prePos.copyFrom(this._targetPos);
                this._targetEuler.copyFrom(this._targetEuler);
                animationSubGeometry.previousTime = currentTime;
            };

            ParticleFollowState.prototype.processPosition = function (currentTime, deltaTime, animationSubGeometry) {
                var data = animationSubGeometry.animationParticles;
                var vertexData = animationSubGeometry.vertexData;

                var changed = false;
                var len = data.length;
                var interpolatedPos;
                var posVelocity;
                if (this._smooth) {
                    posVelocity = this._prePos.subtract(this._targetPos);
                    posVelocity.scaleBy(1 / deltaTime);
                } else
                    interpolatedPos = this._targetPos;
                for (var i = 0; i < len; i++) {
                    var k = (currentTime - data[i].startTime) / data[i].totalTime;
                    var t = (k - Math.floor(k)) * data[i].totalTime;
                    if (t - deltaTime <= 0) {
                        var inc = data[i].startVertexIndex * animationSubGeometry.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;

                        if (this._smooth) {
                            this._temp.copyFrom(posVelocity);
                            this._temp.scaleBy(t);
                            interpolatedPos = this._targetPos.add(this._temp);
                        }

                        if (vertexData[inc] != interpolatedPos.x || vertexData[inc + 1] != interpolatedPos.y || vertexData[inc + 2] != interpolatedPos.z) {
                            changed = true;
                            for (var j = 0; j < data[i].numVertices; j++) {
                                vertexData[inc++] = interpolatedPos.x;
                                vertexData[inc++] = interpolatedPos.y;
                                vertexData[inc++] = interpolatedPos.z;
                            }
                        }
                    }
                }
                if (changed)
                    animationSubGeometry.invalidateBuffer();
            };

            ParticleFollowState.prototype.precessRotation = function (currentTime, deltaTime, animationSubGeometry) {
                var data = animationSubGeometry.animationParticles;
                var vertexData = animationSubGeometry.vertexData;

                var changed = false;
                var len = data.length;

                var interpolatedRotation;
                var rotationVelocity;

                if (this._smooth) {
                    rotationVelocity = this._preEuler.subtract(this._targetEuler);
                    rotationVelocity.scaleBy(1 / deltaTime);
                } else
                    interpolatedRotation = this._targetEuler;

                for (var i = 0; i < len; i++) {
                    var k = (currentTime - data[i].startTime) / data[i].totalTime;
                    var t = (k - Math.floor(k)) * data[i].totalTime;
                    if (t - deltaTime <= 0) {
                        var inc = data[i].startVertexIndex * animationSubGeometry.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;

                        if (this._smooth) {
                            this._temp.copyFrom(rotationVelocity);
                            this._temp.scaleBy(t);
                            interpolatedRotation = this._targetEuler.add(this._temp);
                        }

                        if (vertexData[inc] != interpolatedRotation.x || vertexData[inc + 1] != interpolatedRotation.y || vertexData[inc + 2] != interpolatedRotation.z) {
                            changed = true;
                            for (var j = 0; j < data[i].numVertices; j++) {
                                vertexData[inc++] = interpolatedRotation.x;
                                vertexData[inc++] = interpolatedRotation.y;
                                vertexData[inc++] = interpolatedRotation.z;
                            }
                        }
                    }
                }
                if (changed)
                    animationSubGeometry.invalidateBuffer();
            };

            ParticleFollowState.prototype.processPositionAndRotation = function (currentTime, deltaTime, animationSubGeometry) {
                var data = animationSubGeometry.animationParticles;
                var vertexData = animationSubGeometry.vertexData;

                var changed = false;
                var len = data.length;

                var interpolatedPos;
                var interpolatedRotation;

                var posVelocity;
                var rotationVelocity;
                if (this._smooth) {
                    posVelocity = this._prePos.subtract(this._targetPos);
                    posVelocity.scaleBy(1 / deltaTime);
                    rotationVelocity = this._preEuler.subtract(this._targetEuler);
                    rotationVelocity.scaleBy(1 / deltaTime);
                } else {
                    interpolatedPos = this._targetPos;
                    interpolatedRotation = this._targetEuler;
                }

                for (var i = 0; i < len; i++) {
                    var k = (currentTime - data[i].startTime) / data[i].totalTime;
                    var t = (k - Math.floor(k)) * data[i].totalTime;
                    if (t - deltaTime <= 0) {
                        var inc = data[i].startVertexIndex * animationSubGeometry.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;
                        if (this._smooth) {
                            this._temp.copyFrom(posVelocity);
                            this._temp.scaleBy(t);
                            interpolatedPos = this._targetPos.add(this._temp);

                            this._temp.copyFrom(rotationVelocity);
                            this._temp.scaleBy(t);
                            interpolatedRotation = this._targetEuler.add(this._temp);
                        }

                        if (vertexData[inc] != interpolatedPos.x || vertexData[inc + 1] != interpolatedPos.y || vertexData[inc + 2] != interpolatedPos.z || vertexData[inc + 3] != interpolatedRotation.x || vertexData[inc + 4] != interpolatedRotation.y || vertexData[inc + 5] != interpolatedRotation.z) {
                            changed = true;
                            for (var j = 0; j < data[i].numVertices; j++) {
                                vertexData[inc++] = interpolatedPos.x;
                                vertexData[inc++] = interpolatedPos.y;
                                vertexData[inc++] = interpolatedPos.z;
                                vertexData[inc++] = interpolatedRotation.x;
                                vertexData[inc++] = interpolatedRotation.y;
                                vertexData[inc++] = interpolatedRotation.z;
                            }
                        }
                    }
                }
                if (changed)
                    animationSubGeometry.invalidateBuffer();
            };
            return ParticleFollowState;
        })(animators.ParticleStateBase);
        animators.ParticleFollowState = ParticleFollowState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;

        var Vector3D = away.geom.Vector3D;

        var ParticleInitialColorState = (function (_super) {
            __extends(ParticleInitialColorState, _super);
            function ParticleInitialColorState(animator, particleInitialColorNode) {
                _super.call(this, animator, particleInitialColorNode);

                this._particleInitialColorNode = particleInitialColorNode;
                this._usesMultiplier = particleInitialColorNode._iUsesMultiplier;
                this._usesOffset = particleInitialColorNode._iUsesOffset;
                this._initialColor = particleInitialColorNode._iInitialColor;

                this.updateColorData();
            }
            Object.defineProperty(ParticleInitialColorState.prototype, "initialColor", {
                /**
                * Defines the initial color transform of the state, when in global mode.
                */
                get: function () {
                    return this._initialColor;
                },
                set: function (value) {
                    this._initialColor = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleInitialColorState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                // TODO: not used
                renderable = renderable;
                camera = camera;

                if (animationRegisterCache.needFragmentAnimation) {
                    if (this._particleInitialColorNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                        var dataOffset = this._particleInitialColorNode._iDataOffset;
                        if (this._usesMultiplier) {
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleInitialColorNode.MULTIPLIER_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                            dataOffset += 4;
                        }
                        if (this._usesOffset)
                            animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleInitialColorNode.OFFSET_INDEX), dataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                    } else {
                        if (this._usesMultiplier)
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleInitialColorNode.MULTIPLIER_INDEX), this._multiplierData.x, this._multiplierData.y, this._multiplierData.z, this._multiplierData.w);
                        if (this._usesOffset)
                            animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleInitialColorNode.OFFSET_INDEX), this._offsetData.x, this._offsetData.y, this._offsetData.z, this._offsetData.w);
                    }
                }
            };

            ParticleInitialColorState.prototype.updateColorData = function () {
                if (this._particleInitialColorNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._usesMultiplier)
                        this._multiplierData = new Vector3D(this._initialColor.redMultiplier, this._initialColor.greenMultiplier, this._initialColor.blueMultiplier, this._initialColor.alphaMultiplier);
                    if (this._usesOffset)
                        this._offsetData = new Vector3D(this._initialColor.redOffset / 255, this._initialColor.greenOffset / 255, this._initialColor.blueOffset / 255, this._initialColor.alphaOffset / 255);
                }
            };
            return ParticleInitialColorState;
        })(animators.ParticleStateBase);
        animators.ParticleInitialColorState = ParticleInitialColorState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;
        var Matrix3D = away.geom.Matrix3D;
        var Vector3D = away.geom.Vector3D;

        /**
        * ...
        */
        var ParticleOrbitState = (function (_super) {
            __extends(ParticleOrbitState, _super);
            function ParticleOrbitState(animator, particleOrbitNode) {
                _super.call(this, animator, particleOrbitNode);

                this._particleOrbitNode = particleOrbitNode;
                this._usesEulers = this._particleOrbitNode._iUsesEulers;
                this._usesCycle = this._particleOrbitNode._iUsesCycle;
                this._usesPhase = this._particleOrbitNode._iUsesPhase;
                this._eulers = this._particleOrbitNode._iEulers;
                this._radius = this._particleOrbitNode._iRadius;
                this._cycleDuration = this._particleOrbitNode._iCycleDuration;
                this._cyclePhase = this._particleOrbitNode._iCyclePhase;
                this.updateOrbitData();
            }
            Object.defineProperty(ParticleOrbitState.prototype, "radius", {
                /**
                * Defines the radius of the orbit when in global mode. Defaults to 100.
                */
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;

                    this.updateOrbitData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleOrbitState.prototype, "cycleDuration", {
                /**
                * Defines the duration of the orbit in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
                */
                get: function () {
                    return this._cycleDuration;
                },
                set: function (value) {
                    this._cycleDuration = value;

                    this.updateOrbitData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleOrbitState.prototype, "cyclePhase", {
                /**
                * Defines the phase of the orbit in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
                */
                get: function () {
                    return this._cyclePhase;
                },
                set: function (value) {
                    this._cyclePhase = value;

                    this.updateOrbitData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleOrbitState.prototype, "eulers", {
                /**
                * Defines the euler rotation in degrees, applied to the orientation of the orbit when in global mode.
                */
                get: function () {
                    return this._eulers;
                },
                set: function (value) {
                    this._eulers = value;

                    this.updateOrbitData();
                },
                enumerable: true,
                configurable: true
            });


            ParticleOrbitState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleOrbitNode.ORBIT_INDEX);

                if (this._particleOrbitNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                    if (this._usesPhase)
                        animationSubGeometry.activateVertexBuffer(index, this._particleOrbitNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                    else
                        animationSubGeometry.activateVertexBuffer(index, this._particleOrbitNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                } else
                    animationRegisterCache.setVertexConst(index, this._orbitData.x, this._orbitData.y, this._orbitData.z, this._orbitData.w);

                if (this._usesEulers)
                    animationRegisterCache.setVertexConstFromMatrix(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleOrbitNode.EULERS_INDEX), this._eulersMatrix);
            };

            ParticleOrbitState.prototype.updateOrbitData = function () {
                if (this._usesEulers) {
                    this._eulersMatrix = new Matrix3D();
                    this._eulersMatrix.appendRotation(this._eulers.x, Vector3D.X_AXIS);
                    this._eulersMatrix.appendRotation(this._eulers.y, Vector3D.Y_AXIS);
                    this._eulersMatrix.appendRotation(this._eulers.z, Vector3D.Z_AXIS);
                }
                if (this._particleOrbitNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    this._orbitData = new Vector3D(this._radius, 0, this._radius * Math.PI * 2, this._cyclePhase * Math.PI / 180);
                    if (this._usesCycle) {
                        if (this._cycleDuration <= 0)
                            throw (new Error("the cycle duration must be greater than zero"));
                        this._orbitData.y = Math.PI * 2 / this._cycleDuration;
                    } else
                        this._orbitData.y = Math.PI * 2;
                }
            };
            return ParticleOrbitState;
        })(animators.ParticleStateBase);
        animators.ParticleOrbitState = ParticleOrbitState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;

        /**
        * ...
        */
        var ParticleOscillatorState = (function (_super) {
            __extends(ParticleOscillatorState, _super);
            function ParticleOscillatorState(animator, particleOscillatorNode) {
                _super.call(this, animator, particleOscillatorNode);

                this._particleOscillatorNode = particleOscillatorNode;
                this._oscillator = this._particleOscillatorNode._iOscillator;

                this.updateOscillatorData();
            }
            Object.defineProperty(ParticleOscillatorState.prototype, "oscillator", {
                /**
                * Defines the default oscillator axis (x, y, z) and cycleDuration (w) of the state, used when in global mode.
                */
                get: function () {
                    return this._oscillator;
                },
                set: function (value) {
                    this._oscillator = value;

                    this.updateOscillatorData();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ParticleOscillatorState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleOscillatorNode.OSCILLATOR_INDEX);

                if (this._particleOscillatorNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC)
                    animationSubGeometry.activateVertexBuffer(index, this._particleOscillatorNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                else
                    animationRegisterCache.setVertexConst(index, this._oscillatorData.x, this._oscillatorData.y, this._oscillatorData.z, this._oscillatorData.w);
            };

            ParticleOscillatorState.prototype.updateOscillatorData = function () {
                if (this._particleOscillatorNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._oscillator.w <= 0)
                        throw (new Error("the cycle duration must greater than zero"));

                    if (this._oscillatorData == null)
                        this._oscillatorData = new Vector3D();

                    this._oscillatorData.x = this._oscillator.x;
                    this._oscillatorData.y = this._oscillator.y;
                    this._oscillatorData.z = this._oscillator.z;
                    this._oscillatorData.w = Math.PI * 2 / this._oscillator.w;
                }
            };
            return ParticleOscillatorState;
        })(animators.ParticleStateBase);
        animators.ParticleOscillatorState = ParticleOscillatorState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;

        /**
        * ...
        * @author ...
        */
        var ParticlePositionState = (function (_super) {
            __extends(ParticlePositionState, _super);
            function ParticlePositionState(animator, particlePositionNode) {
                _super.call(this, animator, particlePositionNode);

                this._particlePositionNode = particlePositionNode;
                this._position = this._particlePositionNode._iPosition;
            }
            Object.defineProperty(ParticlePositionState.prototype, "position", {
                /**
                * Defines the position of the particle when in global mode. Defaults to 0,0,0.
                */
                get: function () {
                    return this._position;
                },
                set: function (value) {
                    this._position = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            *
            */
            ParticlePositionState.prototype.getPositions = function () {
                return this._pDynamicProperties;
            };

            ParticlePositionState.prototype.setPositions = function (value) {
                this._pDynamicProperties = value;

                this._pDynamicPropertiesDirty = new Object();
            };

            /**
            * @inheritDoc
            */
            ParticlePositionState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (this._particlePositionNode.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationSubGeometry._iUniqueId])
                    this._pUpdateDynamicProperties(animationSubGeometry);

                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticlePositionNode.POSITION_INDEX);

                if (this._particlePositionNode.mode == animators.ParticlePropertiesMode.GLOBAL)
                    animationRegisterCache.setVertexConst(index, this._position.x, this._position.y, this._position.z);
                else
                    animationSubGeometry.activateVertexBuffer(index, this._particlePositionNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
            };
            return ParticlePositionState;
        })(animators.ParticleStateBase);
        animators.ParticlePositionState = ParticlePositionState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Matrix3D = away.geom.Matrix3D;

        /**
        * ...
        */
        var ParticleRotateToHeadingState = (function (_super) {
            __extends(ParticleRotateToHeadingState, _super);
            function ParticleRotateToHeadingState(animator, particleNode) {
                _super.call(this, animator, particleNode);
                this._matrix = new Matrix3D();
            }
            ParticleRotateToHeadingState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.hasBillboard) {
                    this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                    this._matrix.append(camera.inverseSceneTransform);
                    animationRegisterCache.setVertexConstFromMatrix(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleRotateToHeadingNode.MATRIX_INDEX), this._matrix);
                }
            };
            return ParticleRotateToHeadingState;
        })(animators.ParticleStateBase);
        animators.ParticleRotateToHeadingState = ParticleRotateToHeadingState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;

        var Matrix3D = away.geom.Matrix3D;

        /**
        * ...
        */
        var ParticleRotateToPositionState = (function (_super) {
            __extends(ParticleRotateToPositionState, _super);
            function ParticleRotateToPositionState(animator, particleRotateToPositionNode) {
                _super.call(this, animator, particleRotateToPositionNode);
                this._matrix = new Matrix3D();

                this._particleRotateToPositionNode = particleRotateToPositionNode;
                this._position = this._particleRotateToPositionNode._iPosition;
            }
            Object.defineProperty(ParticleRotateToPositionState.prototype, "position", {
                /**
                * Defines the position of the point the particle will rotate to face when in global mode. Defaults to 0,0,0.
                */
                get: function () {
                    return this._position;
                },
                set: function (value) {
                    this._position = value;
                },
                enumerable: true,
                configurable: true
            });


            ParticleRotateToPositionState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleRotateToPositionNode.POSITION_INDEX);

                if (animationRegisterCache.hasBillboard) {
                    this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
                    this._matrix.append(camera.inverseSceneTransform);
                    animationRegisterCache.setVertexConstFromMatrix(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleRotateToPositionNode.MATRIX_INDEX), this._matrix);
                }

                if (this._particleRotateToPositionNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    this._offset = renderable.sourceEntity.inverseSceneTransform.transformVector(this._position);
                    animationRegisterCache.setVertexConst(index, this._offset.x, this._offset.y, this._offset.z);
                } else
                    animationSubGeometry.activateVertexBuffer(index, this._particleRotateToPositionNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
            };
            return ParticleRotateToPositionState;
        })(animators.ParticleStateBase);
        animators.ParticleRotateToPositionState = ParticleRotateToPositionState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;

        /**
        * ...
        */
        var ParticleRotationalVelocityState = (function (_super) {
            __extends(ParticleRotationalVelocityState, _super);
            function ParticleRotationalVelocityState(animator, particleRotationNode) {
                _super.call(this, animator, particleRotationNode);

                this._particleRotationalVelocityNode = particleRotationNode;
                this._rotationalVelocity = this._particleRotationalVelocityNode._iRotationalVelocity;

                this.updateRotationalVelocityData();
            }
            Object.defineProperty(ParticleRotationalVelocityState.prototype, "rotationalVelocity", {
                /**
                * Defines the default rotationalVelocity of the state, used when in global mode.
                */
                get: function () {
                    return this._rotationalVelocity;
                },
                set: function (value) {
                    this._rotationalVelocity = value;

                    this.updateRotationalVelocityData();
                },
                enumerable: true,
                configurable: true
            });


            /**
            *
            */
            ParticleRotationalVelocityState.prototype.getRotationalVelocities = function () {
                return this._pDynamicProperties;
            };

            ParticleRotationalVelocityState.prototype.setRotationalVelocities = function (value) {
                this._pDynamicProperties = value;

                this._pDynamicPropertiesDirty = new Object();
            };

            /**
            * @inheritDoc
            */
            ParticleRotationalVelocityState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (this._particleRotationalVelocityNode.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationSubGeometry._iUniqueId])
                    this._pUpdateDynamicProperties(animationSubGeometry);

                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleRotationalVelocityNode.ROTATIONALVELOCITY_INDEX);

                if (this._particleRotationalVelocityNode.mode == animators.ParticlePropertiesMode.GLOBAL)
                    animationRegisterCache.setVertexConst(index, this._rotationalVelocityData.x, this._rotationalVelocityData.y, this._rotationalVelocityData.z, this._rotationalVelocityData.w);
                else
                    animationSubGeometry.activateVertexBuffer(index, this._particleRotationalVelocityNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
            };

            ParticleRotationalVelocityState.prototype.updateRotationalVelocityData = function () {
                if (this._particleRotationalVelocityNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._rotationalVelocity.w <= 0)
                        throw (new Error("the cycle duration must greater than zero"));
                    var rotation = this._rotationalVelocity.clone();

                    if (rotation.length <= 0)
                        rotation.z = 1; //set the default direction
                    else
                        rotation.normalize();

                    // w is used as angle/2 in agal
                    this._rotationalVelocityData = new Vector3D(rotation.x, rotation.y, rotation.z, Math.PI / rotation.w);
                }
            };
            return ParticleRotationalVelocityState;
        })(animators.ParticleStateBase);
        animators.ParticleRotationalVelocityState = ParticleRotationalVelocityState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;
        var Vector3D = away.geom.Vector3D;

        /**
        * ...
        */
        var ParticleScaleState = (function (_super) {
            __extends(ParticleScaleState, _super);
            function ParticleScaleState(animator, particleScaleNode) {
                _super.call(this, animator, particleScaleNode);

                this._particleScaleNode = particleScaleNode;
                this._usesCycle = this._particleScaleNode._iUsesCycle;
                this._usesPhase = this._particleScaleNode._iUsesPhase;
                this._minScale = this._particleScaleNode._iMinScale;
                this._maxScale = this._particleScaleNode._iMaxScale;
                this._cycleDuration = this._particleScaleNode._iCycleDuration;
                this._cyclePhase = this._particleScaleNode._iCyclePhase;

                this.updateScaleData();
            }
            Object.defineProperty(ParticleScaleState.prototype, "minScale", {
                /**
                * Defines the end scale of the state, when in global mode. Defaults to 1.
                */
                get: function () {
                    return this._minScale;
                },
                set: function (value) {
                    this._minScale = value;

                    this.updateScaleData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleScaleState.prototype, "maxScale", {
                /**
                * Defines the end scale of the state, when in global mode. Defaults to 1.
                */
                get: function () {
                    return this._maxScale;
                },
                set: function (value) {
                    this._maxScale = value;

                    this.updateScaleData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleScaleState.prototype, "cycleDuration", {
                /**
                * Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
                */
                get: function () {
                    return this._cycleDuration;
                },
                set: function (value) {
                    this._cycleDuration = value;

                    this.updateScaleData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleScaleState.prototype, "cyclePhase", {
                /**
                * Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
                */
                get: function () {
                    return this._cyclePhase;
                },
                set: function (value) {
                    this._cyclePhase = value;

                    this.updateScaleData();
                },
                enumerable: true,
                configurable: true
            });


            ParticleScaleState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleScaleNode.SCALE_INDEX);

                if (this._particleScaleNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                    if (this._usesCycle) {
                        if (this._usesPhase)
                            animationSubGeometry.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);
                        else
                            animationSubGeometry.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                    } else
                        animationSubGeometry.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_2);
                } else
                    animationRegisterCache.setVertexConst(index, this._scaleData.x, this._scaleData.y, this._scaleData.z, this._scaleData.w);
            };

            ParticleScaleState.prototype.updateScaleData = function () {
                if (this._particleScaleNode.mode == animators.ParticlePropertiesMode.GLOBAL) {
                    if (this._usesCycle) {
                        if (this._cycleDuration <= 0)
                            throw (new Error("the cycle duration must be greater than zero"));
                        this._scaleData = new Vector3D((this._minScale + this._maxScale) / 2, Math.abs(this._minScale - this._maxScale) / 2, Math.PI * 2 / this._cycleDuration, this._cyclePhase * Math.PI / 180);
                    } else
                        this._scaleData = new Vector3D(this._minScale, this._maxScale - this._minScale, 0, 0);
                }
            };
            return ParticleScaleState;
        })(animators.ParticleStateBase);
        animators.ParticleScaleState = ParticleScaleState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ParticleSegmentedColorState = (function (_super) {
            __extends(ParticleSegmentedColorState, _super);
            function ParticleSegmentedColorState(animator, particleSegmentedColorNode) {
                _super.call(this, animator, particleSegmentedColorNode);

                this._usesMultiplier = particleSegmentedColorNode._iUsesMultiplier;
                this._usesOffset = particleSegmentedColorNode._iUsesOffset;
                this._startColor = particleSegmentedColorNode._iStartColor;
                this._endColor = particleSegmentedColorNode._iEndColor;
                this._segmentPoints = particleSegmentedColorNode._iSegmentPoints;
                this._numSegmentPoint = particleSegmentedColorNode._iNumSegmentPoint;
                this.updateColorData();
            }
            Object.defineProperty(ParticleSegmentedColorState.prototype, "startColor", {
                /**
                * Defines the start color transform of the state, when in global mode.
                */
                get: function () {
                    return this._startColor;
                },
                set: function (value) {
                    this._startColor = value;

                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleSegmentedColorState.prototype, "endColor", {
                /**
                * Defines the end color transform of the state, when in global mode.
                */
                get: function () {
                    return this._endColor;
                },
                set: function (value) {
                    this._endColor = value;
                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleSegmentedColorState.prototype, "numSegmentPoint", {
                /**
                * Defines the number of segments.
                */
                get: function () {
                    return this._numSegmentPoint;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleSegmentedColorState.prototype, "segmentPoints", {
                /**
                * Defines the key points of color
                */
                get: function () {
                    return this._segmentPoints;
                },
                set: function (value) {
                    this._segmentPoints = value;
                    this.updateColorData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleSegmentedColorState.prototype, "usesMultiplier", {
                get: function () {
                    return this._usesMultiplier;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleSegmentedColorState.prototype, "usesOffset", {
                get: function () {
                    return this._usesOffset;
                },
                enumerable: true,
                configurable: true
            });

            ParticleSegmentedColorState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.needFragmentAnimation) {
                    if (this._numSegmentPoint > 0)
                        animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSegmentedColorNode.TIME_DATA_INDEX), this._timeLifeData[0], this._timeLifeData[1], this._timeLifeData[2], this._timeLifeData[3]);
                    if (this._usesMultiplier)
                        animationRegisterCache.setVertexConstFromArray(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSegmentedColorNode.START_MULTIPLIER_INDEX), this._multiplierData);
                    if (this._usesOffset)
                        animationRegisterCache.setVertexConstFromArray(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSegmentedColorNode.START_OFFSET_INDEX), this._offsetData);
                }
            };

            ParticleSegmentedColorState.prototype.updateColorData = function () {
                this._timeLifeData = new Array();
                this._multiplierData = new Array();
                this._offsetData = new Array();
                var i;
                for (i = 0; i < this._numSegmentPoint; i++) {
                    if (i == 0)
                        this._timeLifeData.push(this._segmentPoints[i].life);
                    else
                        this._timeLifeData.push(this._segmentPoints[i].life - this._segmentPoints[i - 1].life);
                }
                if (this._numSegmentPoint == 0)
                    this._timeLifeData.push(1);
                else
                    this._timeLifeData.push(1 - this._segmentPoints[i - 1].life);

                if (this._usesMultiplier) {
                    this._multiplierData.push(this._startColor.redMultiplier, this._startColor.greenMultiplier, this._startColor.blueMultiplier, this._startColor.alphaMultiplier);
                    for (i = 0; i < this._numSegmentPoint; i++) {
                        if (i == 0)
                            this._multiplierData.push((this._segmentPoints[i].color.redMultiplier - this._startColor.redMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.greenMultiplier - this._startColor.greenMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.blueMultiplier - this._startColor.blueMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.alphaMultiplier - this._startColor.alphaMultiplier) / this._timeLifeData[i]);
                        else
                            this._multiplierData.push((this._segmentPoints[i].color.redMultiplier - this._segmentPoints[i - 1].color.redMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.greenMultiplier - this._segmentPoints[i - 1].color.greenMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.blueMultiplier - this._segmentPoints[i - 1].color.blueMultiplier) / this._timeLifeData[i], (this._segmentPoints[i].color.alphaMultiplier - this._segmentPoints[i - 1].color.alphaMultiplier) / this._timeLifeData[i]);
                    }
                    if (this._numSegmentPoint == 0)
                        this._multiplierData.push(this._endColor.redMultiplier - this._startColor.redMultiplier, this._endColor.greenMultiplier - this._startColor.greenMultiplier, this._endColor.blueMultiplier - this._startColor.blueMultiplier, this._endColor.alphaMultiplier - this._startColor.alphaMultiplier);
                    else
                        this._multiplierData.push((this._endColor.redMultiplier - this._segmentPoints[i - 1].color.redMultiplier) / this._timeLifeData[i], (this._endColor.greenMultiplier - this._segmentPoints[i - 1].color.greenMultiplier) / this._timeLifeData[i], (this._endColor.blueMultiplier - this._segmentPoints[i - 1].color.blueMultiplier) / this._timeLifeData[i], (this._endColor.alphaMultiplier - this._segmentPoints[i - 1].color.alphaMultiplier) / this._timeLifeData[i]);
                }

                if (this._usesOffset) {
                    this._offsetData.push(this._startColor.redOffset / 255, this._startColor.greenOffset / 255, this._startColor.blueOffset / 255, this._startColor.alphaOffset / 255);
                    for (i = 0; i < this._numSegmentPoint; i++) {
                        if (i == 0)
                            this._offsetData.push((this._segmentPoints[i].color.redOffset - this._startColor.redOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.greenOffset - this._startColor.greenOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.blueOffset - this._startColor.blueOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.alphaOffset - this._startColor.alphaOffset) / this._timeLifeData[i] / 255);
                        else
                            this._offsetData.push((this._segmentPoints[i].color.redOffset - this._segmentPoints[i - 1].color.redOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.greenOffset - this._segmentPoints[i - 1].color.greenOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.blueOffset - this._segmentPoints[i - 1].color.blueOffset) / this._timeLifeData[i] / 255, (this._segmentPoints[i].color.alphaOffset - this._segmentPoints[i - 1].color.alphaOffset) / this._timeLifeData[i] / 255);
                    }
                    if (this._numSegmentPoint == 0)
                        this._offsetData.push((this._endColor.redOffset - this._startColor.redOffset) / 255, (this._endColor.greenOffset - this._startColor.greenOffset) / 255, (this._endColor.blueOffset - this._startColor.blueOffset) / 255, (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255);
                    else
                        this._offsetData.push((this._endColor.redOffset - this._segmentPoints[i - 1].color.redOffset) / this._timeLifeData[i] / 255, (this._endColor.greenOffset - this._segmentPoints[i - 1].color.greenOffset) / this._timeLifeData[i] / 255, (this._endColor.blueOffset - this._segmentPoints[i - 1].color.blueOffset) / this._timeLifeData[i] / 255, (this._endColor.alphaOffset - this._segmentPoints[i - 1].color.alphaOffset) / this._timeLifeData[i] / 255);
                }

                //cut off the data
                this._timeLifeData.length = 4;
            };
            return ParticleSegmentedColorState;
        })(animators.ParticleStateBase);
        animators.ParticleSegmentedColorState = ParticleSegmentedColorState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;

        /**
        * ...
        */
        var ParticleSpriteSheetState = (function (_super) {
            __extends(ParticleSpriteSheetState, _super);
            function ParticleSpriteSheetState(animator, particleSpriteSheetNode) {
                _super.call(this, animator, particleSpriteSheetNode);

                this._particleSpriteSheetNode = particleSpriteSheetNode;

                this._usesCycle = this._particleSpriteSheetNode._iUsesCycle;
                this._usesPhase = this._particleSpriteSheetNode._iUsesCycle;
                this._totalFrames = this._particleSpriteSheetNode._iTotalFrames;
                this._numColumns = this._particleSpriteSheetNode._iNumColumns;
                this._numRows = this._particleSpriteSheetNode._iNumRows;
                this._cycleDuration = this._particleSpriteSheetNode._iCycleDuration;
                this._cyclePhase = this._particleSpriteSheetNode._iCyclePhase;

                this.updateSpriteSheetData();
            }
            Object.defineProperty(ParticleSpriteSheetState.prototype, "cyclePhase", {
                /**
                * Defines the cycle phase, when in global mode. Defaults to zero.
                */
                get: function () {
                    return this._cyclePhase;
                },
                set: function (value) {
                    this._cyclePhase = value;

                    this.updateSpriteSheetData();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParticleSpriteSheetState.prototype, "cycleDuration", {
                /**
                * Defines the cycle duration in seconds, when in global mode. Defaults to 1.
                */
                get: function () {
                    return this._cycleDuration;
                },
                set: function (value) {
                    this._cycleDuration = value;

                    this.updateSpriteSheetData();
                },
                enumerable: true,
                configurable: true
            });


            ParticleSpriteSheetState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.needUVAnimation) {
                    animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSpriteSheetNode.UV_INDEX_0), this._spriteSheetData[0], this._spriteSheetData[1], this._spriteSheetData[2], this._spriteSheetData[3]);
                    if (this._usesCycle) {
                        var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleSpriteSheetNode.UV_INDEX_1);
                        if (this._particleSpriteSheetNode.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                            if (this._usesPhase)
                                animationSubGeometry.activateVertexBuffer(index, this._particleSpriteSheetNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
                            else
                                animationSubGeometry.activateVertexBuffer(index, this._particleSpriteSheetNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_2);
                        } else
                            animationRegisterCache.setVertexConst(index, this._spriteSheetData[4], this._spriteSheetData[5]);
                    }
                }
            };

            ParticleSpriteSheetState.prototype.updateSpriteSheetData = function () {
                this._spriteSheetData = new Array(8);

                var uTotal = this._totalFrames / this._numColumns;

                this._spriteSheetData[0] = uTotal;
                this._spriteSheetData[1] = 1 / this._numColumns;
                this._spriteSheetData[2] = 1 / this._numRows;

                if (this._usesCycle) {
                    if (this._cycleDuration <= 0)
                        throw (new Error("the cycle duration must be greater than zero"));
                    this._spriteSheetData[4] = uTotal / this._cycleDuration;
                    this._spriteSheetData[5] = this._cycleDuration;
                    if (this._usesPhase)
                        this._spriteSheetData[6] = this._cyclePhase;
                }
            };
            return ParticleSpriteSheetState;
        })(animators.ParticleStateBase);
        animators.ParticleSpriteSheetState = ParticleSpriteSheetState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;

        /**
        * ...
        */
        var ParticleTimeState = (function (_super) {
            __extends(ParticleTimeState, _super);
            function ParticleTimeState(animator, particleTimeNode) {
                _super.call(this, animator, particleTimeNode, true);

                this._particleTimeNode = particleTimeNode;
            }
            ParticleTimeState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                animationSubGeometry.activateVertexBuffer(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleTimeNode.TIME_STREAM_INDEX), this._particleTimeNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_4);

                var particleTime = this._pTime / 1000;
                animationRegisterCache.setVertexConst(animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleTimeNode.TIME_CONSTANT_INDEX), particleTime, particleTime, particleTime, particleTime);
            };
            return ParticleTimeState;
        })(animators.ParticleStateBase);
        animators.ParticleTimeState = ParticleTimeState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * ...
        */
        var ParticleUVState = (function (_super) {
            __extends(ParticleUVState, _super);
            function ParticleUVState(animator, particleUVNode) {
                _super.call(this, animator, particleUVNode);

                this._particleUVNode = particleUVNode;
            }
            ParticleUVState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (animationRegisterCache.needUVAnimation) {
                    var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleUVNode.UV_INDEX);
                    var data = this._particleUVNode._iUvData;
                    animationRegisterCache.setVertexConst(index, data.x, data.y);
                }
            };
            return ParticleUVState;
        })(animators.ParticleStateBase);
        animators.ParticleUVState = ParticleUVState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLVertexBufferFormat = away.stagegl.ContextGLVertexBufferFormat;

        /**
        * ...
        */
        var ParticleVelocityState = (function (_super) {
            __extends(ParticleVelocityState, _super);
            function ParticleVelocityState(animator, particleVelocityNode) {
                _super.call(this, animator, particleVelocityNode);

                this._particleVelocityNode = particleVelocityNode;
                this._velocity = this._particleVelocityNode._iVelocity;
            }
            Object.defineProperty(ParticleVelocityState.prototype, "velocity", {
                /**
                * Defines the default velocity vector of the state, used when in global mode.
                */
                get: function () {
                    return this._velocity;
                },
                set: function (value) {
                    this._velocity = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            *
            */
            ParticleVelocityState.prototype.getVelocities = function () {
                return this._pDynamicProperties;
            };

            ParticleVelocityState.prototype.setVelocities = function (value) {
                this._pDynamicProperties = value;

                this._pDynamicPropertiesDirty = new Object();
            };

            ParticleVelocityState.prototype.setRenderState = function (stageGL, renderable, animationSubGeometry, animationRegisterCache, camera) {
                if (this._particleVelocityNode.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationSubGeometry._iUniqueId])
                    this._pUpdateDynamicProperties(animationSubGeometry);

                var index = animationRegisterCache.getRegisterIndex(this._pAnimationNode, animators.ParticleVelocityNode.VELOCITY_INDEX);

                if (this._particleVelocityNode.mode == animators.ParticlePropertiesMode.GLOBAL)
                    animationRegisterCache.setVertexConst(index, this._velocity.x, this._velocity.y, this._velocity.z);
                else
                    animationSubGeometry.activateVertexBuffer(index, this._particleVelocityNode._iDataOffset, stageGL, ContextGLVertexBufferFormat.FLOAT_3);
            };
            return ParticleVelocityState;
        })(animators.ParticleStateBase);
        animators.ParticleVelocityState = ParticleVelocityState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        *
        */
        var AnimationClipState = (function (_super) {
            __extends(AnimationClipState, _super);
            function AnimationClipState(animator, animationClipNode) {
                _super.call(this, animator, animationClipNode);
                this._pFramesDirty = true;

                this._animationClipNode = animationClipNode;
            }
            Object.defineProperty(AnimationClipState.prototype, "blendWeight", {
                /**
                * Returns a fractional value between 0 and 1 representing the blending ratio of the current playhead position
                * between the current frame (0) and next frame (1) of the animation.
                *
                * @see #currentFrame
                * @see #nextFrame
                */
                get: function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pBlendWeight;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipState.prototype, "currentFrame", {
                /**
                * Returns the current frame of animation in the clip based on the internal playhead position.
                */
                get: function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pCurrentFrame;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipState.prototype, "nextFrame", {
                /**
                * Returns the next frame of animation in the clip based on the internal playhead position.
                */
                get: function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pNextFrame;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype.update = function (time /*int*/ ) {
                if (!this._animationClipNode.looping) {
                    if (time > this._pStartTime + this._animationClipNode.totalDuration)
                        time = this._pStartTime + this._animationClipNode.totalDuration;
                    else if (time < this._pStartTime)
                        time = this._pStartTime;
                }

                if (this._pTime == time - this._pStartTime)
                    return;

                this._pUpdateTime(time);
            };

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype.phase = function (value) {
                var time = value * this._animationClipNode.totalDuration + this._pStartTime;

                if (this._pTime == time - this._pStartTime)
                    return;

                this._pUpdateTime(time);
            };

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype._pUpdateTime = function (time /*int*/ ) {
                this._pFramesDirty = true;

                this._pTimeDir = (time - this._pStartTime > this._pTime) ? 1 : -1;

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Updates the nodes internal playhead to determine the current and next animation frame, and the blendWeight between the two.
            *
            * @see #currentFrame
            * @see #nextFrame
            * @see #blendWeight
            */
            AnimationClipState.prototype._pUpdateFrames = function () {
                this._pFramesDirty = false;

                var looping = this._animationClipNode.looping;
                var totalDuration = this._animationClipNode.totalDuration;
                var lastFrame = this._animationClipNode.lastFrame;
                var time = this._pTime;

                //trace("time", time, totalDuration)
                if (looping && (time >= totalDuration || time < 0)) {
                    time %= totalDuration;
                    if (time < 0)
                        time += totalDuration;
                }

                if (!looping && time >= totalDuration) {
                    this.notifyPlaybackComplete();
                    this._pCurrentFrame = lastFrame;
                    this._pNextFrame = lastFrame;
                    this._pBlendWeight = 0;
                } else if (!looping && time <= 0) {
                    this._pCurrentFrame = 0;
                    this._pNextFrame = 0;
                    this._pBlendWeight = 0;
                } else if (this._animationClipNode.fixedFrameRate) {
                    var t = time / totalDuration * lastFrame;
                    this._pCurrentFrame = Math.floor(t);
                    this._pBlendWeight = t - this._pCurrentFrame;
                    this._pNextFrame = this._pCurrentFrame + 1;
                } else {
                    this._pCurrentFrame = 0;
                    this._pNextFrame = 0;

                    var dur = 0, frameTime;
                    var durations = this._animationClipNode.durations;

                    do {
                        frameTime = dur;
                        dur += durations[this._pNextFrame];
                        this._pCurrentFrame = this._pNextFrame++;
                    } while(time > dur);

                    if (this._pCurrentFrame == lastFrame) {
                        this._pCurrentFrame = 0;
                        this._pNextFrame = 1;
                    }

                    this._pBlendWeight = (time - frameTime) / durations[this._pCurrentFrame];
                }
            };

            AnimationClipState.prototype.notifyPlaybackComplete = function () {
                if (this._animationStatePlaybackComplete == null)
                    this._animationStatePlaybackComplete = new away.events.AnimationStateEvent(away.events.AnimationStateEvent.PLAYBACK_COMPLETE, this._pAnimator, this, this._animationClipNode);

                this._animationClipNode.dispatchEvent(this._animationStatePlaybackComplete);
            };
            return AnimationClipState;
        })(animators.AnimationStateBase);
        animators.AnimationClipState = AnimationClipState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        *
        */
        var SkeletonBinaryLERPState = (function (_super) {
            __extends(SkeletonBinaryLERPState, _super);
            function SkeletonBinaryLERPState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);
                this._blendWeight = 0;
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;

                this._skeletonAnimationNode = skeletonAnimationNode;

                this._inputA = animator.getAnimationState(this._skeletonAnimationNode.inputA);
                this._inputB = animator.getAnimationState(this._skeletonAnimationNode.inputB);
            }
            Object.defineProperty(SkeletonBinaryLERPState.prototype, "blendWeight", {
                /**
                * Defines a fractional value between 0 and 1 representing the blending ratio between inputA (0) and inputB (1),
                * used to produce the skeleton pose output.
                *
                * @see inputA
                * @see inputB
                */
                get: function () {
                    return this._blendWeight;
                },
                set: function (value) {
                    this._blendWeight = value;

                    this._pPositionDeltaDirty = true;
                    this._skeletonPoseDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkeletonBinaryLERPState.prototype.phase = function (value) {
                this._skeletonPoseDirty = true;

                this._pPositionDeltaDirty = true;

                this._inputA.phase(value);
                this._inputB.phase(value);
            };

            /**
            * @inheritDoc
            */
            SkeletonBinaryLERPState.prototype._pUpdateTime = function (time /*int*/ ) {
                this._skeletonPoseDirty = true;

                this._inputA.update(time);
                this._inputB.update(time);

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonBinaryLERPState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * @inheritDoc
            */
            SkeletonBinaryLERPState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                var deltA = this._inputA.positionDelta;
                var deltB = this._inputB.positionDelta;

                this._pRootDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
                this._pRootDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
                this._pRootDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
            };

            /**
            * Updates the output skeleton pose of the node based on the blendWeight value between input nodes.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonBinaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                var endPose;
                var endPoses = this._skeletonPose.jointPoses;
                var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
                var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
                var pose1, pose2;
                var p1, p2;
                var tr;
                var numJoints = skeleton.numJoints;

                // :s
                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                for (var i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];

                    if (endPose == null)
                        endPose = endPoses[i] = new animators.JointPose();

                    pose1 = poses1[i];
                    pose2 = poses2[i];
                    p1 = pose1.translation;
                    p2 = pose2.translation;

                    endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);

                    tr = endPose.translation;
                    tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
                    tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
                    tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
                }
            };
            return SkeletonBinaryLERPState;
        })(animators.AnimationStateBase);
        animators.SkeletonBinaryLERPState = SkeletonBinaryLERPState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Vector3D = away.geom.Vector3D;

        /**
        *
        */
        var SkeletonClipState = (function (_super) {
            __extends(SkeletonClipState, _super);
            function SkeletonClipState(animator, skeletonClipNode) {
                _super.call(this, animator, skeletonClipNode);
                this._rootPos = new Vector3D();
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;

                this._skeletonClipNode = skeletonClipNode;
                this._frames = this._skeletonClipNode.frames;
            }
            Object.defineProperty(SkeletonClipState.prototype, "currentPose", {
                /**
                * Returns the current skeleton pose frame of animation in the clip based on the internal playhead position.
                */
                get: function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._currentPose;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonClipState.prototype, "nextPose", {
                /**
                * Returns the next skeleton pose frame of animation in the clip based on the internal playhead position.
                */
                get: function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._nextPose;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonClipState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * @inheritDoc
            */
            SkeletonClipState.prototype._pUpdateTime = function (time /*int*/ ) {
                this._skeletonPoseDirty = true;

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * @inheritDoc
            */
            SkeletonClipState.prototype._pUpdateFrames = function () {
                _super.prototype._pUpdateFrames.call(this);

                this._currentPose = this._frames[this._pCurrentFrame];

                if (this._skeletonClipNode.looping && this._pNextFrame >= this._skeletonClipNode.lastFrame) {
                    this._nextPose = this._frames[0];
                    this._pAnimator.dispatchCycleEvent();
                } else
                    this._nextPose = this._frames[this._pNextFrame];
            };

            /**
            * Updates the output skeleton pose of the node based on the internal playhead position.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonClipState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                if (!this._skeletonClipNode.totalDuration)
                    return;

                if (this._pFramesDirty)
                    this._pUpdateFrames();

                var currentPose = this._currentPose.jointPoses;
                var nextPose = this._nextPose.jointPoses;
                var numJoints = skeleton.numJoints;
                var p1, p2;
                var pose1, pose2;
                var endPoses = this._skeletonPose.jointPoses;
                var endPose;
                var tr;

                // :s
                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                if ((numJoints != currentPose.length) || (numJoints != nextPose.length))
                    throw new Error("joint counts don't match!");

                for (var i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];

                    if (endPose == null)
                        endPose = endPoses[i] = new animators.JointPose();

                    pose1 = currentPose[i];
                    pose2 = nextPose[i];
                    p1 = pose1.translation;
                    p2 = pose2.translation;

                    if (this._skeletonClipNode.highQuality)
                        endPose.orientation.slerp(pose1.orientation, pose2.orientation, this._pBlendWeight);
                    else
                        endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._pBlendWeight);

                    if (i > 0) {
                        tr = endPose.translation;
                        tr.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
                        tr.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
                        tr.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
                    }
                }
            };

            /**
            * @inheritDoc
            */
            SkeletonClipState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                if (this._pFramesDirty)
                    this._pUpdateFrames();

                var p1, p2, p3;
                var totalDelta = this._skeletonClipNode.totalDelta;

                // jumping back, need to reset position
                if ((this._pTimeDir > 0 && this._pNextFrame < this._pOldFrame) || (this._pTimeDir < 0 && this._pNextFrame > this._pOldFrame)) {
                    this._rootPos.x -= totalDelta.x * this._pTimeDir;
                    this._rootPos.y -= totalDelta.y * this._pTimeDir;
                    this._rootPos.z -= totalDelta.z * this._pTimeDir;
                }

                var dx = this._rootPos.x;
                var dy = this._rootPos.y;
                var dz = this._rootPos.z;

                if (this._skeletonClipNode.stitchFinalFrame && this._pNextFrame == this._skeletonClipNode.lastFrame) {
                    p1 = this._frames[0].jointPoses[0].translation;
                    p2 = this._frames[1].jointPoses[0].translation;
                    p3 = this._currentPose.jointPoses[0].translation;

                    this._rootPos.x = p3.x + p1.x + this._pBlendWeight * (p2.x - p1.x);
                    this._rootPos.y = p3.y + p1.y + this._pBlendWeight * (p2.y - p1.y);
                    this._rootPos.z = p3.z + p1.z + this._pBlendWeight * (p2.z - p1.z);
                } else {
                    p1 = this._currentPose.jointPoses[0].translation;
                    p2 = this._frames[this._pNextFrame].jointPoses[0].translation; //cover the instances where we wrap the pose but still want the final frame translation values
                    this._rootPos.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
                    this._rootPos.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
                    this._rootPos.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
                }

                this._pRootDelta.x = this._rootPos.x - dx;
                this._pRootDelta.y = this._rootPos.y - dy;
                this._pRootDelta.z = this._rootPos.z - dz;

                this._pOldFrame = this._pNextFrame;
            };
            return SkeletonClipState;
        })(animators.AnimationClipState);
        animators.SkeletonClipState = SkeletonClipState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var Quaternion = away.geom.Quaternion;

        /**
        *
        */
        var SkeletonDifferenceState = (function (_super) {
            __extends(SkeletonDifferenceState, _super);
            function SkeletonDifferenceState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);
                this._blendWeight = 0;
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;

                this._skeletonAnimationNode = skeletonAnimationNode;

                this._baseInput = animator.getAnimationState(this._skeletonAnimationNode.baseInput);
                this._differenceInput = animator.getAnimationState(this._skeletonAnimationNode.differenceInput);
            }
            Object.defineProperty(SkeletonDifferenceState.prototype, "blendWeight", {
                /**
                * Defines a fractional value between 0 and 1 representing the blending ratio between the base input (0) and difference input (1),
                * used to produce the skeleton pose output.
                *
                * @see #baseInput
                * @see #differenceInput
                */
                get: function () {
                    return this._blendWeight;
                },
                set: function (value) {
                    this._blendWeight = value;

                    this._pPositionDeltaDirty = true;
                    this._skeletonPoseDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkeletonDifferenceState.prototype.phase = function (value) {
                this._skeletonPoseDirty = true;

                this._pPositionDeltaDirty = true;

                this._baseInput.phase(value);
                this._baseInput.phase(value);
            };

            /**
            * @inheritDoc
            */
            SkeletonDifferenceState.prototype._pUpdateTime = function (time /*int*/ ) {
                this._skeletonPoseDirty = true;

                this._baseInput.update(time);
                this._differenceInput.update(time);

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonDifferenceState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * @inheritDoc
            */
            SkeletonDifferenceState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                var deltA = this._baseInput.positionDelta;
                var deltB = this._differenceInput.positionDelta;

                this.positionDelta.x = deltA.x + this._blendWeight * deltB.x;
                this.positionDelta.y = deltA.y + this._blendWeight * deltB.y;
                this.positionDelta.z = deltA.z + this._blendWeight * deltB.z;
            };

            /**
            * Updates the output skeleton pose of the node based on the blendWeight value between base input and difference input nodes.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonDifferenceState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                var endPose;
                var endPoses = this._skeletonPose.jointPoses;
                var basePoses = this._baseInput.getSkeletonPose(skeleton).jointPoses;
                var diffPoses = this._differenceInput.getSkeletonPose(skeleton).jointPoses;
                var base, diff;
                var basePos, diffPos;
                var tr;
                var numJoints = skeleton.numJoints;

                // :s
                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                for (var i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];

                    if (endPose == null)
                        endPose = endPoses[i] = new animators.JointPose();

                    base = basePoses[i];
                    diff = diffPoses[i];
                    basePos = base.translation;
                    diffPos = diff.translation;

                    SkeletonDifferenceState._tempQuat.multiply(diff.orientation, base.orientation);
                    endPose.orientation.lerp(base.orientation, SkeletonDifferenceState._tempQuat, this._blendWeight);

                    tr = endPose.translation;
                    tr.x = basePos.x + this._blendWeight * diffPos.x;
                    tr.y = basePos.y + this._blendWeight * diffPos.y;
                    tr.z = basePos.z + this._blendWeight * diffPos.z;
                }
            };
            SkeletonDifferenceState._tempQuat = new Quaternion();
            return SkeletonDifferenceState;
        })(animators.AnimationStateBase);
        animators.SkeletonDifferenceState = SkeletonDifferenceState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        *
        */
        var SkeletonDirectionalState = (function (_super) {
            __extends(SkeletonDirectionalState, _super);
            function SkeletonDirectionalState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;
                this._blendWeight = 0;
                this._direction = 0;
                this._blendDirty = true;

                this._skeletonAnimationNode = skeletonAnimationNode;

                this._forward = animator.getAnimationState(this._skeletonAnimationNode.forward);
                this._backward = animator.getAnimationState(this._skeletonAnimationNode.backward);
                this._left = animator.getAnimationState(this._skeletonAnimationNode.left);
                this._right = animator.getAnimationState(this._skeletonAnimationNode.right);
            }

            Object.defineProperty(SkeletonDirectionalState.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                /**
                * Defines the direction in degrees of the aniamtion between the forwards (0), right(90) backwards (180) and left(270) input nodes,
                * used to produce the skeleton pose output.
                */
                set: function (value) {
                    if (this._direction == value)
                        return;

                    this._direction = value;

                    this._blendDirty = true;

                    this._skeletonPoseDirty = true;
                    this._pPositionDeltaDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SkeletonDirectionalState.prototype.phase = function (value) {
                if (this._blendDirty)
                    this.updateBlend();

                this._skeletonPoseDirty = true;

                this._pPositionDeltaDirty = true;

                this._inputA.phase(value);
                this._inputB.phase(value);
            };

            /**
            * @inheritDoc
            */
            SkeletonDirectionalState.prototype._pUdateTime = function (time /*int*/ ) {
                if (this._blendDirty)
                    this.updateBlend();

                this._skeletonPoseDirty = true;

                this._inputA.update(time);
                this._inputB.update(time);

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonDirectionalState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * @inheritDoc
            */
            SkeletonDirectionalState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                if (this._blendDirty)
                    this.updateBlend();

                var deltA = this._inputA.positionDelta;
                var deltB = this._inputB.positionDelta;

                this.positionDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
                this.positionDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
                this.positionDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
            };

            /**
            * Updates the output skeleton pose of the node based on the direction value between forward, backwards, left and right input nodes.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonDirectionalState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                if (this._blendDirty)
                    this.updateBlend();

                var endPose;
                var endPoses = this._skeletonPose.jointPoses;
                var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
                var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
                var pose1, pose2;
                var p1, p2;
                var tr;
                var numJoints = skeleton.numJoints;

                // :s
                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                for (var i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];

                    if (endPose == null)
                        endPose = endPoses[i] = new animators.JointPose();

                    pose1 = poses1[i];
                    pose2 = poses2[i];
                    p1 = pose1.translation;
                    p2 = pose2.translation;

                    endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);

                    tr = endPose.translation;
                    tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
                    tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
                    tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
                }
            };

            /**
            * Updates the blend value for the animation output based on the direction value between forward, backwards, left and right input nodes.
            *
            * @private
            */
            SkeletonDirectionalState.prototype.updateBlend = function () {
                this._blendDirty = false;

                if (this._direction < 0 || this._direction > 360) {
                    this._direction %= 360;
                    if (this._direction < 0)
                        this._direction += 360;
                }

                if (this._direction < 90) {
                    this._inputA = this._forward;
                    this._inputB = this._right;
                    this._blendWeight = this._direction / 90;
                } else if (this._direction < 180) {
                    this._inputA = this._right;
                    this._inputB = this._backward;
                    this._blendWeight = (this._direction - 90) / 90;
                } else if (this._direction < 270) {
                    this._inputA = this._backward;
                    this._inputB = this._left;
                    this._blendWeight = (this._direction - 180) / 90;
                } else {
                    this._inputA = this._left;
                    this._inputB = this._forward;
                    this._blendWeight = (this._direction - 270) / 90;
                }
            };
            return SkeletonDirectionalState;
        })(animators.AnimationStateBase);
        animators.SkeletonDirectionalState = SkeletonDirectionalState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        *
        */
        var SkeletonNaryLERPState = (function (_super) {
            __extends(SkeletonNaryLERPState, _super);
            function SkeletonNaryLERPState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);
                this._skeletonPose = new animators.SkeletonPose();
                this._skeletonPoseDirty = true;
                this._blendWeights = new Array();
                this._inputs = new Array();

                this._skeletonAnimationNode = skeletonAnimationNode;

                var i = this._skeletonAnimationNode.numInputs;

                while (i--)
                    this._inputs[i] = animator.getAnimationState(this._skeletonAnimationNode._iInputs[i]);
            }
            /**
            * @inheritDoc
            */
            SkeletonNaryLERPState.prototype.phase = function (value) {
                this._skeletonPoseDirty = true;

                this._pPositionDeltaDirty = true;

                for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
                    if (this._blendWeights[j])
                        this._inputs[j].update(value);
                }
            };

            /**
            * @inheritDoc
            */
            SkeletonNaryLERPState.prototype._pUdateTime = function (time /*int*/ ) {
                for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
                    if (this._blendWeights[j])
                        this._inputs[j].update(time);
                }

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
            */
            SkeletonNaryLERPState.prototype.getSkeletonPose = function (skeleton) {
                if (this._skeletonPoseDirty)
                    this.updateSkeletonPose(skeleton);

                return this._skeletonPose;
            };

            /**
            * Returns the blend weight of the skeleton aniamtion node that resides at the given input index.
            *
            * @param index The input index for which the skeleton animation node blend weight is requested.
            */
            SkeletonNaryLERPState.prototype.getBlendWeightAt = function (index /*uint*/ ) {
                return this._blendWeights[index];
            };

            /**
            * Sets the blend weight of the skeleton aniamtion node that resides at the given input index.
            *
            * @param index The input index on which the skeleton animation node blend weight is to be set.
            * @param blendWeight The blend weight value to use for the given skeleton animation node index.
            */
            SkeletonNaryLERPState.prototype.setBlendWeightAt = function (index /*uint*/ , blendWeight) {
                this._blendWeights[index] = blendWeight;

                this._pPositionDeltaDirty = true;
                this._skeletonPoseDirty = true;
            };

            /**
            * @inheritDoc
            */
            SkeletonNaryLERPState.prototype._pUpdatePositionDelta = function () {
                this._pPositionDeltaDirty = false;

                var delta;
                var weight;

                this.positionDelta.x = 0;
                this.positionDelta.y = 0;
                this.positionDelta.z = 0;

                for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
                    weight = this._blendWeights[j];

                    if (weight) {
                        delta = this._inputs[j].positionDelta;
                        this.positionDelta.x += weight * delta.x;
                        this.positionDelta.y += weight * delta.y;
                        this.positionDelta.z += weight * delta.z;
                    }
                }
            };

            /**
            * Updates the output skeleton pose of the node based on the blend weight values given to the input nodes.
            *
            * @param skeleton The skeleton used by the animator requesting the ouput pose.
            */
            SkeletonNaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
                this._skeletonPoseDirty = false;

                var weight;
                var endPoses = this._skeletonPose.jointPoses;
                var poses;
                var endPose, pose;
                var endTr, tr;
                var endQuat, q;
                var firstPose;
                var i;
                var w0, x0, y0, z0;
                var w1, x1, y1, z1;
                var numJoints = skeleton.numJoints;

                // :s
                if (endPoses.length != numJoints)
                    endPoses.length = numJoints;

                for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
                    weight = this._blendWeights[j];

                    if (!weight)
                        continue;

                    poses = this._inputs[j].getSkeletonPose(skeleton).jointPoses;

                    if (!firstPose) {
                        firstPose = poses;
                        for (i = 0; i < numJoints; ++i) {
                            endPose = endPoses[i];

                            if (endPose == null)
                                endPose = endPoses[i] = new animators.JointPose();

                            pose = poses[i];
                            q = pose.orientation;
                            tr = pose.translation;

                            endQuat = endPose.orientation;

                            endQuat.x = weight * q.x;
                            endQuat.y = weight * q.y;
                            endQuat.z = weight * q.z;
                            endQuat.w = weight * q.w;

                            endTr = endPose.translation;
                            endTr.x = weight * tr.x;
                            endTr.y = weight * tr.y;
                            endTr.z = weight * tr.z;
                        }
                    } else {
                        for (i = 0; i < skeleton.numJoints; ++i) {
                            endPose = endPoses[i];
                            pose = poses[i];

                            q = firstPose[i].orientation;
                            x0 = q.x;
                            y0 = q.y;
                            z0 = q.z;
                            w0 = q.w;

                            q = pose.orientation;
                            tr = pose.translation;

                            x1 = q.x;
                            y1 = q.y;
                            z1 = q.z;
                            w1 = q.w;

                            // find shortest direction
                            if (x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1 < 0) {
                                x1 = -x1;
                                y1 = -y1;
                                z1 = -z1;
                                w1 = -w1;
                            }
                            endQuat = endPose.orientation;
                            endQuat.x += weight * x1;
                            endQuat.y += weight * y1;
                            endQuat.z += weight * z1;
                            endQuat.w += weight * w1;

                            endTr = endPose.translation;
                            endTr.x += weight * tr.x;
                            endTr.y += weight * tr.y;
                            endTr.z += weight * tr.z;
                        }
                    }
                }

                for (i = 0; i < skeleton.numJoints; ++i)
                    endPoses[i].orientation.normalize();
            };
            return SkeletonNaryLERPState;
        })(animators.AnimationStateBase);
        animators.SkeletonNaryLERPState = SkeletonNaryLERPState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        *
        */
        var VertexClipState = (function (_super) {
            __extends(VertexClipState, _super);
            function VertexClipState(animator, vertexClipNode) {
                _super.call(this, animator, vertexClipNode);

                this._vertexClipNode = vertexClipNode;
                this._frames = this._vertexClipNode.frames;
            }
            Object.defineProperty(VertexClipState.prototype, "currentGeometry", {
                /**
                * @inheritDoc
                */
                get: function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._currentGeometry;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexClipState.prototype, "nextGeometry", {
                /**
                * @inheritDoc
                */
                get: function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._nextGeometry;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            VertexClipState.prototype._pUpdateFrames = function () {
                _super.prototype._pUpdateFrames.call(this);

                this._currentGeometry = this._frames[this._pCurrentFrame];

                if (this._vertexClipNode.looping && this._pNextFrame >= this._vertexClipNode.lastFrame) {
                    this._nextGeometry = this._frames[0];
                    this._pAnimator.dispatchCycleEvent();
                } else
                    this._nextGeometry = this._frames[this._pNextFrame];
            };

            /**
            * @inheritDoc
            */
            VertexClipState.prototype._pUpdatePositionDelta = function () {
                //TODO:implement positiondelta functionality for vertex animations
            };
            return VertexClipState;
        })(animators.AnimationClipState);
        animators.VertexClipState = VertexClipState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var CrossfadeTransition = (function () {
            function CrossfadeTransition(blendSpeed) {
                this.blendSpeed = 0.5;
                this.blendSpeed = blendSpeed;
            }
            CrossfadeTransition.prototype.getAnimationNode = function (animator, startNode, endNode, startBlend /*int*/ ) {
                var crossFadeTransitionNode = new animators.CrossfadeTransitionNode();
                crossFadeTransitionNode.inputA = startNode;
                crossFadeTransitionNode.inputB = endNode;
                crossFadeTransitionNode.blendSpeed = this.blendSpeed;
                crossFadeTransitionNode.startBlend = startBlend;

                return crossFadeTransitionNode;
            };
            return CrossfadeTransition;
        })();
        animators.CrossfadeTransition = CrossfadeTransition;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * A skeleton animation node that uses two animation node inputs to blend a lineraly interpolated output of a skeleton pose.
        */
        var CrossfadeTransitionNode = (function (_super) {
            __extends(CrossfadeTransitionNode, _super);
            /**
            * Creates a new <code>CrossfadeTransitionNode</code> object.
            */
            function CrossfadeTransitionNode() {
                _super.call(this);

                this._pStateClass = animators.CrossfadeTransitionState;
            }
            return CrossfadeTransitionNode;
        })(animators.SkeletonBinaryLERPNode);
        animators.CrossfadeTransitionNode = CrossfadeTransitionNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var AnimationStateEvent = away.events.AnimationStateEvent;

        /**
        *
        */
        var CrossfadeTransitionState = (function (_super) {
            __extends(CrossfadeTransitionState, _super);
            function CrossfadeTransitionState(animator, skeletonAnimationNode) {
                _super.call(this, animator, skeletonAnimationNode);

                this._crossfadeTransitionNode = skeletonAnimationNode;
            }
            /**
            * @inheritDoc
            */
            CrossfadeTransitionState.prototype._pUpdateTime = function (time /*int*/ ) {
                this.blendWeight = Math.abs(time - this._crossfadeTransitionNode.startBlend) / (1000 * this._crossfadeTransitionNode.blendSpeed);

                if (this.blendWeight >= 1) {
                    this.blendWeight = 1;

                    if (this._animationStateTransitionComplete == null)
                        this._animationStateTransitionComplete = new AnimationStateEvent(AnimationStateEvent.TRANSITION_COMPLETE, this._pAnimator, this, this._crossfadeTransitionNode);

                    this._crossfadeTransitionNode.dispatchEvent(this._animationStateTransitionComplete);
                }

                _super.prototype._pUpdateTime.call(this, time);
            };
            return CrossfadeTransitionState;
        })(animators.SkeletonBinaryLERPState);
        animators.CrossfadeTransitionState = CrossfadeTransitionState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var AbstractMethodError = away.errors.AbstractMethodError;

        /**
        * Provides an abstract base class for data set classes that hold animation data for use in animator classes.
        *
        * @see away.animators.AnimatorBase
        */
        var AnimationSetBase = (function (_super) {
            __extends(AnimationSetBase, _super);
            function AnimationSetBase() {
                _super.call(this);
                this._animations = new Array();
                this._animationNames = new Array();
                this._animationDictionary = new Object();
            }
            /**
            * Retrieves a temporary GPU register that's still free.
            *
            * @param exclude An array of non-free temporary registers.
            * @param excludeAnother An additional register that's not free.
            * @return A temporary register that can be used.
            */
            AnimationSetBase.prototype._pFindTempReg = function (exclude, excludeAnother) {
                if (typeof excludeAnother === "undefined") { excludeAnother = null; }
                var i = 0;
                var reg;

                while (true) {
                    reg = "vt" + i;
                    if (exclude.indexOf(reg) == -1 && excludeAnother != reg)
                        return reg;
                    ++i;
                }

                // can't be reached
                return null;
            };

            Object.defineProperty(AnimationSetBase.prototype, "usesCPU", {
                /**
                * Indicates whether the properties of the animation data contained within the set combined with
                * the vertex registers already in use on shading materials allows the animation data to utilise
                * GPU calls.
                */
                get: function () {
                    return this._usesCPU;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called by the material to reset the GPU indicator before testing whether register space in the shader
            * is available for running GPU-based animation code.
            *
            * @private
            */
            AnimationSetBase.prototype.resetGPUCompatibility = function () {
                this._usesCPU = false;
            };

            AnimationSetBase.prototype.cancelGPUCompatibility = function () {
                this._usesCPU = true;
            };

            /**
            * @inheritDoc
            */
            AnimationSetBase.prototype.getAGALVertexCode = function (pass, sourceRegisters, targetRegisters, profile) {
                throw new AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            AnimationSetBase.prototype.activate = function (stageGL, pass) {
                throw new AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            AnimationSetBase.prototype.deactivate = function (stageGL, pass) {
                throw new AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            AnimationSetBase.prototype.getAGALFragmentCode = function (pass, shadedTarget, profile) {
                throw new AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            AnimationSetBase.prototype.getAGALUVCode = function (pass, UVSource, UVTarget) {
                throw new AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            AnimationSetBase.prototype.doneAGALCode = function (pass) {
                throw new AbstractMethodError();
            };

            Object.defineProperty(AnimationSetBase.prototype, "assetType", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return away.library.AssetType.ANIMATION_SET;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSetBase.prototype, "animations", {
                /**
                * Returns a vector of animation state objects that make up the contents of the animation data set.
                */
                get: function () {
                    return this._animations;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSetBase.prototype, "animationNames", {
                /**
                * Returns a vector of animation state objects that make up the contents of the animation data set.
                */
                get: function () {
                    return this._animationNames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Check to determine whether a state is registered in the animation set under the given name.
            *
            * @param stateName The name of the animation state object to be checked.
            */
            AnimationSetBase.prototype.hasAnimation = function (name) {
                return this._animationDictionary[name] != null;
            };

            /**
            * Retrieves the animation state object registered in the animation data set under the given name.
            *
            * @param stateName The name of the animation state object to be retrieved.
            */
            AnimationSetBase.prototype.getAnimation = function (name) {
                return this._animationDictionary[name];
            };

            /**
            * Adds an animation state object to the aniamtion data set under the given name.
            *
            * @param stateName The name under which the animation state object will be stored.
            * @param animationState The animation state object to be staored in the set.
            */
            AnimationSetBase.prototype.addAnimation = function (node) {
                if (this._animationDictionary[node.name])
                    throw new away.errors.AnimationSetError("root node name '" + node.name + "' already exists in the set");

                this._animationDictionary[node.name] = node;

                this._animations.push(node);

                this._animationNames.push(node.name);
            };

            /**
            * Cleans up any resources used by the current object.
            */
            AnimationSetBase.prototype.dispose = function () {
            };
            return AnimationSetBase;
        })(away.library.NamedAssetBase);
        animators.AnimationSetBase = AnimationSetBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * Dispatched when playback of an animation inside the animator object starts.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="start", type="away3d.events.AnimatorEvent")]
        /**
        * Dispatched when playback of an animation inside the animator object stops.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="stop", type="away3d.events.AnimatorEvent")]
        /**
        * Dispatched when playback of an animation reaches the end of an animation.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="cycle_complete", type="away3d.events.AnimatorEvent")]
        /**
        * Provides an abstract base class for animator classes that control animation output from a data set subtype of <code>AnimationSetBase</code>.
        *
        * @see away.animators.AnimationSetBase
        */
        var AnimatorBase = (function (_super) {
            __extends(AnimatorBase, _super);
            /**
            * Creates a new <code>AnimatorBase</code> object.
            *
            * @param animationSet The animation data set to be used by the animator object.
            */
            function AnimatorBase(animationSet) {
                _super.call(this);
                this._autoUpdate = true;
                this._time = 0;
                this._playbackSpeed = 1;
                this._pOwners = new Array();
                this._pAbsoluteTime = 0;
                this._animationStates = new Object();
                /**
                * Enables translation of the animated mesh from data returned per frame via the positionDelta property of the active animation node. Defaults to true.
                *
                * @see away.animators.IAnimationState#positionDelta
                */
                this.updatePosition = true;

                this._pAnimationSet = animationSet;

                this._broadcaster = new away.utils.RequestAnimationFrame(this.onEnterFrame, this);
            }
            AnimatorBase.prototype.getAnimationState = function (node) {
                var className = node.stateClass;
                var uID = node.id;

                if (this._animationStates[uID] == null)
                    this._animationStates[uID] = new className(this, node);

                return this._animationStates[uID];
            };

            AnimatorBase.prototype.getAnimationStateByName = function (name) {
                return this.getAnimationState(this._pAnimationSet.getAnimation(name));
            };

            Object.defineProperty(AnimatorBase.prototype, "absoluteTime", {
                /**
                * Returns the internal absolute time of the animator, calculated by the current time and the playback speed.
                *
                * @see #time
                * @see #playbackSpeed
                */
                get: function () {
                    return this._pAbsoluteTime;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "animationSet", {
                /**
                * Returns the animation data set in use by the animator.
                */
                get: function () {
                    return this._pAnimationSet;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeState", {
                /**
                * Returns the current active animation state.
                */
                get: function () {
                    return this._pActiveState;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeAnimation", {
                /**
                * Returns the current active animation node.
                */
                get: function () {
                    return this._pAnimationSet.getAnimation(this._pActiveAnimationName);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeAnimationName", {
                /**
                * Returns the current active animation node.
                */
                get: function () {
                    return this._pActiveAnimationName;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "autoUpdate", {
                /**
                * Determines whether the animators internal update mechanisms are active. Used in cases
                * where manual updates are required either via the <code>time</code> property or <code>update()</code> method.
                * Defaults to true.
                *
                * @see #time
                * @see #update()
                */
                get: function () {
                    return this._autoUpdate;
                },
                set: function (value) {
                    if (this._autoUpdate == value)
                        return;

                    this._autoUpdate = value;

                    if (this._autoUpdate)
                        this.start();
                    else
                        this.stop();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimatorBase.prototype, "time", {
                /**
                * Gets and sets the internal time clock of the animator.
                */
                get: function () {
                    return this._time;
                },
                set: function (value /*int*/ ) {
                    if (this._time == value)
                        return;

                    this.update(value);
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Sets the animation phase of the current active state's animation clip(s).
            *
            * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
            */
            AnimatorBase.prototype.phase = function (value) {
                this._pActiveState.phase(value);
            };

            Object.defineProperty(AnimatorBase.prototype, "playbackSpeed", {
                /**
                * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
                */
                get: function () {
                    return this._playbackSpeed;
                },
                set: function (value) {
                    this._playbackSpeed = value;
                },
                enumerable: true,
                configurable: true
            });


            AnimatorBase.prototype.setRenderState = function (stageGL, renderable, vertexConstantOffset /*int*/ , vertexStreamOffset /*int*/ , camera) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Resumes the automatic playback clock controling the active state of the animator.
            */
            AnimatorBase.prototype.start = function () {
                if (this._isPlaying || !this._autoUpdate)
                    return;

                this._time = this._pAbsoluteTime = away.utils.getTimer();

                this._isPlaying = true;

                this._broadcaster.start();

                if (!this.hasEventListener(away.events.AnimatorEvent.START))
                    return;

                if (this._startEvent == null)
                    this._startEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.START, this);

                this.dispatchEvent(this._startEvent);
            };

            /**
            * Pauses the automatic playback clock of the animator, in case manual updates are required via the
            * <code>time</code> property or <code>update()</code> method.
            *
            * @see #time
            * @see #update()
            */
            AnimatorBase.prototype.stop = function () {
                if (!this._isPlaying)
                    return;

                this._isPlaying = false;

                this._broadcaster.stop();

                if (!this.hasEventListener(away.events.AnimatorEvent.STOP))
                    return;

                if (this._stopEvent == null)
                    this._stopEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.STOP, this);

                this.dispatchEvent(this._stopEvent);
            };

            /**
            * Provides a way to manually update the active state of the animator when automatic
            * updates are disabled.
            *
            * @see #stop()
            * @see #autoUpdate
            */
            AnimatorBase.prototype.update = function (time /*int*/ ) {
                var dt = (time - this._time) * this.playbackSpeed;

                this._pUpdateDeltaTime(dt);

                this._time = time;
            };

            AnimatorBase.prototype.reset = function (name, offset) {
                if (typeof offset === "undefined") { offset = 0; }
                this.getAnimationState(this._pAnimationSet.getAnimation(name)).offset(offset + this._pAbsoluteTime);
            };

            /**
            * Used by the mesh object to which the animator is applied, registers the owner for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.addOwner = function (mesh) {
                this._pOwners.push(mesh);
            };

            /**
            * Used by the mesh object from which the animator is removed, unregisters the owner for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.removeOwner = function (mesh) {
                this._pOwners.splice(this._pOwners.indexOf(mesh), 1);
            };

            /**
            * Internal abstract method called when the time delta property of the animator's contents requires updating.
            *
            * @private
            */
            AnimatorBase.prototype._pUpdateDeltaTime = function (dt) {
                this._pAbsoluteTime += dt;

                this._pActiveState.update(this._pAbsoluteTime);

                if (this.updatePosition)
                    this.applyPositionDelta();
            };

            /**
            * Enter frame event handler for automatically updating the active state of the animator.
            */
            AnimatorBase.prototype.onEnterFrame = function (event) {
                if (typeof event === "undefined") { event = null; }
                this.update(away.utils.getTimer());
            };

            AnimatorBase.prototype.applyPositionDelta = function () {
                var delta = this._pActiveState.positionDelta;
                var dist = delta.length;
                var len;
                if (dist > 0) {
                    len = this._pOwners.length;
                    for (var i = 0; i < len; ++i)
                        this._pOwners[i].translateLocal(delta, dist);
                }
            };

            /**
            *  for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.dispatchCycleEvent = function () {
                if (this.hasEventListener(away.events.AnimatorEvent.CYCLE_COMPLETE)) {
                    if (this._cycleEvent == null)
                        this._cycleEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.CYCLE_COMPLETE, this);

                    this.dispatchEvent(this._cycleEvent);
                }
            };

            /**
            * @inheritDoc
            */
            AnimatorBase.prototype.clone = function () {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            AnimatorBase.prototype.dispose = function () {
            };

            /**
            * @inheritDoc
            */
            AnimatorBase.prototype.testGPUCompatibility = function (pass) {
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(AnimatorBase.prototype, "assetType", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return away.library.AssetType.ANIMATOR;
                },
                enumerable: true,
                configurable: true
            });

            AnimatorBase.prototype.getRenderableSubGeometry = function (renderable, sourceSubGeometry) {
                //nothing to do here
                return sourceSubGeometry;
            };
            return AnimatorBase;
        })(away.library.NamedAssetBase);
        animators.AnimatorBase = AnimatorBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * The animation data set used by particle-based animators, containing particle animation data.
        *
        * @see away.animators.ParticleAnimator
        */
        var ParticleAnimationSet = (function (_super) {
            __extends(ParticleAnimationSet, _super);
            /**
            * Creates a new <code>ParticleAnimationSet</code>
            *
            * @param    [optional] usesDuration    Defines whether the animation set uses the <code>duration</code> data in its static properties to determine how long a particle is visible for. Defaults to false.
            * @param    [optional] usesLooping     Defines whether the animation set uses a looping timeframe for each particle determined by the <code>startTime</code>, <code>duration</code> and <code>delay</code> data in its static properties function. Defaults to false. Requires <code>usesDuration</code> to be true.
            * @param    [optional] usesDelay       Defines whether the animation set uses the <code>delay</code> data in its static properties to determine how long a particle is hidden for. Defaults to false. Requires <code>usesLooping</code> to be true.
            */
            function ParticleAnimationSet(usesDuration, usesLooping, usesDelay) {
                if (typeof usesDuration === "undefined") { usesDuration = false; }
                if (typeof usesLooping === "undefined") { usesLooping = false; }
                if (typeof usesDelay === "undefined") { usesDelay = false; }
                _super.call(this);
                this._animationSubGeometries = new Object();
                this._particleNodes = new Array();
                this._localDynamicNodes = new Array();
                this._localStaticNodes = new Array();
                this._totalLenOfOneVertex = 0;

                //automatically add a particle time node to the set
                this.addAnimation(this._timeNode = new animators.ParticleTimeNode(usesDuration, usesLooping, usesDelay));
            }
            Object.defineProperty(ParticleAnimationSet.prototype, "particleNodes", {
                /**
                * Returns a vector of the particle animation nodes contained within the set.
                */
                get: function () {
                    return this._particleNodes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.addAnimation = function (node) {
                var i;
                var n = node;
                n._iProcessAnimationSetting(this);
                if (n.mode == animators.ParticlePropertiesMode.LOCAL_STATIC) {
                    n._iDataOffset = this._totalLenOfOneVertex;
                    this._totalLenOfOneVertex += n.dataLength;
                    this._localStaticNodes.push(n);
                } else if (n.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC)
                    this._localDynamicNodes.push(n);

                for (i = this._particleNodes.length - 1; i >= 0; i--) {
                    if (this._particleNodes[i].priority <= n.priority)
                        break;
                }

                this._particleNodes.splice(i + 1, 0, n);

                _super.prototype.addAnimation.call(this, node);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.activate = function (stageGL, pass) {
                this._iAnimationRegisterCache = pass.animationRegisterCache;
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.deactivate = function (stageGL, pass) {
                var context = stageGL.contextGL;
                var offset = this._iAnimationRegisterCache.vertexAttributesOffset;
                var used = this._iAnimationRegisterCache.numUsedStreams;
                for (var i = offset; i < used; i++)
                    context.setVertexBufferAt(i, null);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.getAGALVertexCode = function (pass, sourceRegisters, targetRegisters, profile) {
                //grab animationRegisterCache from the materialpassbase or create a new one if the first time
                this._iAnimationRegisterCache = pass.animationRegisterCache;

                if (this._iAnimationRegisterCache == null)
                    this._iAnimationRegisterCache = pass.animationRegisterCache = new animators.AnimationRegisterCache(profile);

                //reset animationRegisterCache
                this._iAnimationRegisterCache.vertexConstantOffset = pass.numUsedVertexConstants;
                this._iAnimationRegisterCache.vertexAttributesOffset = pass.numUsedStreams;
                this._iAnimationRegisterCache.varyingsOffset = pass.numUsedVaryings;
                this._iAnimationRegisterCache.fragmentConstantOffset = pass.numUsedFragmentConstants;
                this._iAnimationRegisterCache.hasUVNode = this.hasUVNode;
                this._iAnimationRegisterCache.needVelocity = this.needVelocity;
                this._iAnimationRegisterCache.hasBillboard = this.hasBillboard;
                this._iAnimationRegisterCache.sourceRegisters = sourceRegisters;
                this._iAnimationRegisterCache.targetRegisters = targetRegisters;
                this._iAnimationRegisterCache.needFragmentAnimation = pass.needFragmentAnimation;
                this._iAnimationRegisterCache.needUVAnimation = pass.needUVAnimation;
                this._iAnimationRegisterCache.hasColorAddNode = this.hasColorAddNode;
                this._iAnimationRegisterCache.hasColorMulNode = this.hasColorMulNode;
                this._iAnimationRegisterCache.reset();

                var code = "";

                code += this._iAnimationRegisterCache.getInitCode();

                var node;
                var i;

                for (i = 0; i < this._particleNodes.length; i++) {
                    node = this._particleNodes[i];
                    if (node.priority < ParticleAnimationSet.POST_PRIORITY)
                        code += node.getAGALVertexCode(pass, this._iAnimationRegisterCache);
                }

                code += this._iAnimationRegisterCache.getCombinationCode();

                for (i = 0; i < this._particleNodes.length; i++) {
                    node = this._particleNodes[i];
                    if (node.priority >= ParticleAnimationSet.POST_PRIORITY && node.priority < ParticleAnimationSet.COLOR_PRIORITY)
                        code += node.getAGALVertexCode(pass, this._iAnimationRegisterCache);
                }

                code += this._iAnimationRegisterCache.initColorRegisters();

                for (i = 0; i < this._particleNodes.length; i++) {
                    node = this._particleNodes[i];
                    if (node.priority >= ParticleAnimationSet.COLOR_PRIORITY)
                        code += node.getAGALVertexCode(pass, this._iAnimationRegisterCache);
                }
                code += this._iAnimationRegisterCache.getColorPassCode();
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.getAGALUVCode = function (pass, UVSource, UVTarget) {
                var code = "";
                if (this.hasUVNode) {
                    this._iAnimationRegisterCache.setUVSourceAndTarget(UVSource, UVTarget);
                    code += "mov " + this._iAnimationRegisterCache.uvTarget + ".xy," + this._iAnimationRegisterCache.uvAttribute.toString() + "\n";
                    var node;
                    for (var i = 0; i < this._particleNodes.length; i++)
                        node = this._particleNodes[i];
                    code += node.getAGALUVCode(pass, this._iAnimationRegisterCache);
                    code += "mov " + this._iAnimationRegisterCache.uvVar.toString() + "," + this._iAnimationRegisterCache.uvTarget + ".xy\n";
                } else
                    code += "mov " + UVTarget + "," + UVSource + "\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.getAGALFragmentCode = function (pass, shadedTarget, profile) {
                return this._iAnimationRegisterCache.getColorCombinationCode(shadedTarget);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.doneAGALCode = function (pass) {
                this._iAnimationRegisterCache.setDataLength();

                //set vertexZeroConst,vertexOneConst,vertexTwoConst
                this._iAnimationRegisterCache.setVertexConst(this._iAnimationRegisterCache.vertexZeroConst.index, 0, 1, 2, 0);
            };

            Object.defineProperty(ParticleAnimationSet.prototype, "usesCPU", {
                /**
                * @inheritDoc
                */
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            ParticleAnimationSet.prototype.cancelGPUCompatibility = function () {
            };

            ParticleAnimationSet.prototype.dispose = function () {
                for (var key in this._animationSubGeometries)
                    this._animationSubGeometries[key].dispose();

                _super.prototype.dispose.call(this);
            };

            ParticleAnimationSet.prototype.getAnimationSubGeometry = function (subMesh) {
                var mesh = subMesh.parentMesh;
                var animationSubGeometry = (mesh.shareAnimationGeometry) ? this._animationSubGeometries[subMesh.subGeometry.id] : this._animationSubGeometries[subMesh.id];

                if (animationSubGeometry)
                    return animationSubGeometry;

                this._iGenerateAnimationSubGeometries(mesh);

                return (mesh.shareAnimationGeometry) ? this._animationSubGeometries[subMesh.subGeometry.id] : this._animationSubGeometries[subMesh.id];
            };

            /** @private */
            ParticleAnimationSet.prototype._iGenerateAnimationSubGeometries = function (mesh) {
                if (this.initParticleFunc == null)
                    throw (new Error("no initParticleFunc set"));

                var geometry = mesh.geometry;

                if (!geometry)
                    throw (new Error("Particle animation can only be performed on a ParticleGeometry object"));

                var i, j, k;
                var animationSubGeometry;
                var newAnimationSubGeometry = false;
                var subGeometry;
                var subMesh;
                var localNode;

                for (i = 0; i < mesh.subMeshes.length; i++) {
                    subMesh = mesh.subMeshes[i];
                    subGeometry = subMesh.subGeometry;
                    if (mesh.shareAnimationGeometry) {
                        animationSubGeometry = this._animationSubGeometries[subGeometry.id];

                        if (animationSubGeometry)
                            continue;
                    }

                    animationSubGeometry = new animators.AnimationSubGeometry();

                    if (mesh.shareAnimationGeometry)
                        this._animationSubGeometries[subGeometry.id] = animationSubGeometry;
                    else
                        this._animationSubGeometries[subMesh.id] = animationSubGeometry;

                    newAnimationSubGeometry = true;

                    //create the vertexData vector that will be used for local node data
                    animationSubGeometry.createVertexData(subGeometry.numVertices, this._totalLenOfOneVertex);
                }

                if (!newAnimationSubGeometry)
                    return;

                var particles = geometry.particles;
                var particlesLength = particles.length;
                var numParticles = geometry.numParticles;
                var particleProperties = new animators.ParticleProperties();
                var particle;

                var oneDataLen;
                var oneDataOffset;
                var counterForVertex;
                var counterForOneData;
                var oneData;
                var numVertices;
                var vertexData;
                var vertexLength;
                var startingOffset;
                var vertexOffset;

                //default values for particle param
                particleProperties.total = numParticles;
                particleProperties.startTime = 0;
                particleProperties.duration = 1000;
                particleProperties.delay = 0.1;

                i = 0;
                j = 0;
                while (i < numParticles) {
                    particleProperties.index = i;

                    //call the init on the particle parameters
                    this.initParticleFunc.call(this.initParticleScope, particleProperties);

                    for (k = 0; k < this._localStaticNodes.length; k++)
                        this._localStaticNodes[k]._iGeneratePropertyOfOneParticle(particleProperties);

                    while (j < particlesLength && (particle = particles[j]).particleIndex == i) {
                        for (k = 0; k < mesh.subMeshes.length; k++) {
                            subMesh = mesh.subMeshes[k];
                            if (subMesh.subGeometry == particle.subGeometry) {
                                animationSubGeometry = (mesh.shareAnimationGeometry) ? this._animationSubGeometries[subMesh.subGeometry.id] : this._animationSubGeometries[subMesh.id];
                                break;
                            }
                        }
                        numVertices = particle.numVertices;
                        vertexData = animationSubGeometry.vertexData;
                        vertexLength = numVertices * this._totalLenOfOneVertex;
                        startingOffset = animationSubGeometry.numProcessedVertices * this._totalLenOfOneVertex;

                        for (k = 0; k < this._localStaticNodes.length; k++) {
                            localNode = this._localStaticNodes[k];
                            oneData = localNode.oneData;
                            oneDataLen = localNode.dataLength;
                            oneDataOffset = startingOffset + localNode._iDataOffset;

                            for (counterForVertex = 0; counterForVertex < vertexLength; counterForVertex += this._totalLenOfOneVertex) {
                                vertexOffset = oneDataOffset + counterForVertex;

                                for (counterForOneData = 0; counterForOneData < oneDataLen; counterForOneData++)
                                    vertexData[vertexOffset + counterForOneData] = oneData[counterForOneData];
                            }
                        }

                        //store particle properties if they need to be retreived for dynamic local nodes
                        if (this._localDynamicNodes.length)
                            animationSubGeometry.animationParticles.push(new animators.ParticleAnimationData(i, particleProperties.startTime, particleProperties.duration, particleProperties.delay, particle));

                        animationSubGeometry.numProcessedVertices += numVertices;

                        //next index
                        j++;
                    }

                    //next particle
                    i++;
                }
            };
            ParticleAnimationSet.POST_PRIORITY = 9;

            ParticleAnimationSet.COLOR_PRIORITY = 18;
            return ParticleAnimationSet;
        })(animators.AnimationSetBase);
        animators.ParticleAnimationSet = ParticleAnimationSet;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var ContextGLProgramType = away.stagegl.ContextGLProgramType;

        /**
        * Provides an interface for assigning paricle-based animation data sets to mesh-based entity objects
        * and controlling the various available states of animation through an interative playhead that can be
        * automatically updated or manually triggered.
        *
        * Requires that the containing geometry of the parent mesh is particle geometry
        *
        * @see away.base.ParticleGeometry
        */
        var ParticleAnimator = (function (_super) {
            __extends(ParticleAnimator, _super);
            /**
            * Creates a new <code>ParticleAnimator</code> object.
            *
            * @param particleAnimationSet The animation data set containing the particle animations used by the animator.
            */
            function ParticleAnimator(particleAnimationSet) {
                _super.call(this, particleAnimationSet);
                this._animationParticleStates = new Array();
                this._animatorParticleStates = new Array();
                this._timeParticleStates = new Array();
                this._totalLenOfOneVertex = 0;
                this._animatorSubGeometries = new Object();
                this._particleAnimationSet = particleAnimationSet;

                var state;
                var node;

                for (var i = 0; i < this._particleAnimationSet.particleNodes.length; i++) {
                    node = this._particleAnimationSet.particleNodes[i];
                    state = this.getAnimationState(node);
                    if (node.mode == animators.ParticlePropertiesMode.LOCAL_DYNAMIC) {
                        this._animatorParticleStates.push(state);
                        node._iDataOffset = this._totalLenOfOneVertex;
                        this._totalLenOfOneVertex += node.dataLength;
                    } else {
                        this._animationParticleStates.push(state);
                    }
                    if (state.needUpdateTime)
                        this._timeParticleStates.push(state);
                }
            }
            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.clone = function () {
                return new ParticleAnimator(this._particleAnimationSet);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.setRenderState = function (stageGL, renderable, vertexConstantOffset /*int*/ , vertexStreamOffset /*int*/ , camera) {
                var animationRegisterCache = this._particleAnimationSet._iAnimationRegisterCache;

                var subMesh = renderable.subMesh;
                var state;
                var i;

                if (!subMesh)
                    throw (new Error("Must be subMesh"));

                //process animation sub geometries
                var animationSubGeometry = this._particleAnimationSet.getAnimationSubGeometry(subMesh);

                for (i = 0; i < this._animationParticleStates.length; i++)
                    this._animationParticleStates[i].setRenderState(stageGL, renderable, animationSubGeometry, animationRegisterCache, camera);

                //process animator subgeometries
                var animatorSubGeometry = this.getAnimatorSubGeometry(subMesh);

                for (i = 0; i < this._animatorParticleStates.length; i++)
                    this._animatorParticleStates[i].setRenderState(stageGL, renderable, animatorSubGeometry, animationRegisterCache, camera);

                stageGL.contextGL.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, animationRegisterCache.vertexConstantOffset, animationRegisterCache.vertexConstantData, animationRegisterCache.numVertexConstant);

                if (animationRegisterCache.numFragmentConstant > 0)
                    stageGL.contextGL.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, animationRegisterCache.fragmentConstantOffset, animationRegisterCache.fragmentConstantData, animationRegisterCache.numFragmentConstant);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.testGPUCompatibility = function (pass) {
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.start = function () {
                _super.prototype.start.call(this);

                for (var i = 0; i < this._timeParticleStates.length; i++)
                    this._timeParticleStates[i].offset(this._pAbsoluteTime);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype._pUpdateDeltaTime = function (dt) {
                this._pAbsoluteTime += dt;

                for (var i = 0; i < this._timeParticleStates.length; i++)
                    this._timeParticleStates[i].update(this._pAbsoluteTime);
            };

            /**
            * @inheritDoc
            */
            ParticleAnimator.prototype.resetTime = function (offset) {
                if (typeof offset === "undefined") { offset = 0; }
                for (var i = 0; i < this._timeParticleStates.length; i++)
                    this._timeParticleStates[i].offset(this._pAbsoluteTime + offset);
                this.update(this.time);
            };

            ParticleAnimator.prototype.dispose = function () {
                for (var key in this._animatorSubGeometries)
                    this._animatorSubGeometries[key].dispose();
            };

            ParticleAnimator.prototype.getAnimatorSubGeometry = function (subMesh) {
                if (!this._animatorParticleStates.length)
                    return;

                var subGeometry = subMesh.subGeometry;
                var animatorSubGeometry = this._animatorSubGeometries[subGeometry.id] = new animators.AnimationSubGeometry();

                //create the vertexData vector that will be used for local state data
                animatorSubGeometry.createVertexData(subGeometry.numVertices, this._totalLenOfOneVertex);

                //pass the particles data to the animator subGeometry
                animatorSubGeometry.animationParticles = this._particleAnimationSet.getAnimationSubGeometry(subMesh).animationParticles;
            };
            return ParticleAnimator;
        })(animators.AnimatorBase);
        animators.ParticleAnimator = ParticleAnimator;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var TriangleSubGeometry = away.base.TriangleSubGeometry;

        var AnimationStateEvent = away.events.AnimationStateEvent;

        var ContextGLProgramType = away.stagegl.ContextGLProgramType;

        /**
        * Provides an interface for assigning skeleton-based animation data sets to mesh-based entity objects
        * and controlling the various available states of animation through an interative playhead that can be
        * automatically updated or manually triggered.
        */
        var SkeletonAnimator = (function (_super) {
            __extends(SkeletonAnimator, _super);
            /**
            * Creates a new <code>SkeletonAnimator</code> object.
            *
            * @param skeletonAnimationSet The animation data set containing the skeleton animations used by the animator.
            * @param skeleton The skeleton object used for calculating the resulting global matrices for transforming skinned mesh data.
            * @param forceCPU Optional value that only allows the animator to perform calculation on the CPU. Defaults to false.
            */
            function SkeletonAnimator(animationSet, skeleton, forceCPU) {
                if (typeof forceCPU === "undefined") { forceCPU = false; }
                var _this = this;
                _super.call(this, animationSet);
                this._globalPose = new animators.SkeletonPose();
                this._morphedSubGeometry = new Object();
                this._morphedSubGeometryDirty = new Object();

                this._skeleton = skeleton;
                this._forceCPU = forceCPU;
                this._jointsPerVertex = animationSet.jointsPerVertex;

                this._numJoints = this._skeleton.numJoints;
                this._globalMatrices = new Array(this._numJoints * 12);

                var j = 0;
                for (var i = 0; i < this._numJoints; ++i) {
                    this._globalMatrices[j++] = 1;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 1;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 0;
                    this._globalMatrices[j++] = 1;
                    this._globalMatrices[j++] = 0;
                }

                this._onTransitionCompleteDelegate = function (event) {
                    return _this.onTransitionComplete(event);
                };
                this._onIndicesUpdateDelegate = function (event) {
                    return _this.onIndicesUpdate(event);
                };
                this._onVerticesUpdateDelegate = function (event) {
                    return _this.onVerticesUpdate(event);
                };
            }
            Object.defineProperty(SkeletonAnimator.prototype, "globalMatrices", {
                /**
                * returns the calculated global matrices of the current skeleton pose.
                *
                * @see #globalPose
                */
                get: function () {
                    if (this._globalPropertiesDirty)
                        this.updateGlobalProperties();

                    return this._globalMatrices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonAnimator.prototype, "globalPose", {
                /**
                * returns the current skeleton pose output from the animator.
                *
                * @see away.animators.data.SkeletonPose
                */
                get: function () {
                    if (this._globalPropertiesDirty)
                        this.updateGlobalProperties();

                    return this._globalPose;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonAnimator.prototype, "skeleton", {
                /**
                * Returns the skeleton object in use by the animator - this defines the number and heirarchy of joints used by the
                * skinned geoemtry to which skeleon animator is applied.
                */
                get: function () {
                    return this._skeleton;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonAnimator.prototype, "forceCPU", {
                /**
                * Indicates whether the skeleton animator is disabled by default for GPU rendering, something that allows the animator to perform calculation on the GPU.
                * Defaults to false.
                */
                get: function () {
                    return this._forceCPU;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkeletonAnimator.prototype, "useCondensedIndices", {
                /**
                * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
                * by condensing the number of joint index values required per mesh. Only applicable to
                * skeleton animations that utilise more than one mesh object. Defaults to false.
                */
                get: function () {
                    return this._useCondensedIndices;
                },
                set: function (value) {
                    this._useCondensedIndices = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkeletonAnimator.prototype.clone = function () {
                /* The cast to SkeletonAnimationSet should never fail, as _animationSet can only be set
                through the constructor, which will only accept a SkeletonAnimationSet. */
                return new SkeletonAnimator(this._pAnimationSet, this._skeleton, this._forceCPU);
            };

            /**
            * Plays an animation state registered with the given name in the animation data set.
            *
            * @param name The data set name of the animation state to be played.
            * @param transition An optional transition object that determines how the animator will transition from the currently active animation state.
            * @param offset An option offset time (in milliseconds) that resets the state's internal clock to the absolute time of the animator plus the offset value. Required for non-looping animation states.
            */
            SkeletonAnimator.prototype.play = function (name, transition, offset) {
                if (typeof transition === "undefined") { transition = null; }
                if (typeof offset === "undefined") { offset = NaN; }
                if (this._pActiveAnimationName == name)
                    return;

                this._pActiveAnimationName = name;

                if (!this._pAnimationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");

                if (transition && this._pActiveNode) {
                    //setup the transition
                    this._pActiveNode = transition.getAnimationNode(this, this._pActiveNode, this._pAnimationSet.getAnimation(name), this._pAbsoluteTime);
                    this._pActiveNode.addEventListener(AnimationStateEvent.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);
                } else
                    this._pActiveNode = this._pAnimationSet.getAnimation(name);

                this._pActiveState = this.getAnimationState(this._pActiveNode);

                if (this.updatePosition) {
                    //update straight away to reset position deltas
                    this._pActiveState.update(this._pAbsoluteTime);
                    this._pActiveState.positionDelta;
                }

                this._activeSkeletonState = this._pActiveState;

                this.start();

                //apply a time offset if specified
                if (!isNaN(offset))
                    this.reset(name, offset);
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimator.prototype.setRenderState = function (stageGL, renderable, vertexConstantOffset /*int*/ , vertexStreamOffset /*int*/ , camera) {
                // do on request of globalProperties
                if (this._globalPropertiesDirty)
                    this.updateGlobalProperties();

                var subGeometry = renderable.subMesh.subGeometry;

                subGeometry.useCondensedIndices = this._useCondensedIndices;

                if (this._useCondensedIndices) {
                    // using a condensed data set
                    this.updateCondensedMatrices(subGeometry.condensedIndexLookUp, subGeometry.numCondensedJoints);
                    stageGL.contextGL.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, vertexConstantOffset, this._condensedMatrices, subGeometry.numCondensedJoints * 3);
                } else {
                    if (this._pAnimationSet.usesCPU) {
                        if (this._morphedSubGeometryDirty[subGeometry.id])
                            this.morphSubGeometry(renderable, subGeometry);

                        return;
                    }
                    stageGL.contextGL.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, vertexConstantOffset, this._globalMatrices, this._numJoints * 3);
                }

                stageGL.activateBuffer(vertexStreamOffset, renderable.getVertexData(TriangleSubGeometry.JOINT_INDEX_DATA), renderable.getVertexOffset(TriangleSubGeometry.JOINT_INDEX_DATA), renderable.JOINT_INDEX_FORMAT);
                stageGL.activateBuffer(vertexStreamOffset + 1, renderable.getVertexData(TriangleSubGeometry.JOINT_WEIGHT_DATA), renderable.getVertexOffset(TriangleSubGeometry.JOINT_WEIGHT_DATA), renderable.JOINT_WEIGHT_FORMAT);
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimator.prototype.testGPUCompatibility = function (pass) {
                if (!this._useCondensedIndices && (this._forceCPU || this._jointsPerVertex > 4 || pass.numUsedVertexConstants + this._numJoints * 3 > 128))
                    this._pAnimationSet.cancelGPUCompatibility();
            };

            /**
            * Applies the calculated time delta to the active animation state node or state transition object.
            */
            SkeletonAnimator.prototype._pUpdateDeltaTime = function (dt) {
                _super.prototype._pUpdateDeltaTime.call(this, dt);

                //invalidate pose matrices
                this._globalPropertiesDirty = true;

                //trigger geometry invalidation if using CPU animation
                if (this._pAnimationSet.usesCPU)
                    for (var key in this._morphedSubGeometryDirty)
                        this._morphedSubGeometryDirty[key] = true;
            };

            SkeletonAnimator.prototype.updateCondensedMatrices = function (condensedIndexLookUp /*uint*/ , numJoints /*uint*/ ) {
                var i = 0, j = 0;
                var len;
                var srcIndex;

                this._condensedMatrices = new Array();

                do {
                    srcIndex = condensedIndexLookUp[i] * 4;
                    len = srcIndex + 12;

                    while (srcIndex < len)
                        this._condensedMatrices[j++] = this._globalMatrices[srcIndex++];
                } while(++i < numJoints);
            };

            SkeletonAnimator.prototype.updateGlobalProperties = function () {
                this._globalPropertiesDirty = false;

                //get global pose
                this.localToGlobalPose(this._activeSkeletonState.getSkeletonPose(this._skeleton), this._globalPose, this._skeleton);

                // convert pose to matrix
                var mtxOffset = 0;
                var globalPoses = this._globalPose.jointPoses;
                var raw;
                var ox, oy, oz, ow;
                var xy2, xz2, xw2;
                var yz2, yw2, zw2;
                var n11, n12, n13;
                var n21, n22, n23;
                var n31, n32, n33;
                var m11, m12, m13, m14;
                var m21, m22, m23, m24;
                var m31, m32, m33, m34;
                var joints = this._skeleton.joints;
                var pose;
                var quat;
                var vec;
                var t;

                for (var i = 0; i < this._numJoints; ++i) {
                    pose = globalPoses[i];
                    quat = pose.orientation;
                    vec = pose.translation;
                    ox = quat.x;
                    oy = quat.y;
                    oz = quat.z;
                    ow = quat.w;

                    xy2 = (t = 2.0 * ox) * oy;
                    xz2 = t * oz;
                    xw2 = t * ow;
                    yz2 = (t = 2.0 * oy) * oz;
                    yw2 = t * ow;
                    zw2 = 2.0 * oz * ow;

                    yz2 = 2.0 * oy * oz;
                    yw2 = 2.0 * oy * ow;
                    zw2 = 2.0 * oz * ow;
                    ox *= ox;
                    oy *= oy;
                    oz *= oz;
                    ow *= ow;

                    n11 = (t = ox - oy) - oz + ow;
                    n12 = xy2 - zw2;
                    n13 = xz2 + yw2;
                    n21 = xy2 + zw2;
                    n22 = -t - oz + ow;
                    n23 = yz2 - xw2;
                    n31 = xz2 - yw2;
                    n32 = yz2 + xw2;
                    n33 = -ox - oy + oz + ow;

                    // prepend inverse bind pose
                    raw = joints[i].inverseBindPose;
                    m11 = raw[0];
                    m12 = raw[4];
                    m13 = raw[8];
                    m14 = raw[12];
                    m21 = raw[1];
                    m22 = raw[5];
                    m23 = raw[9];
                    m24 = raw[13];
                    m31 = raw[2];
                    m32 = raw[6];
                    m33 = raw[10];
                    m34 = raw[14];

                    this._globalMatrices[mtxOffset] = n11 * m11 + n12 * m21 + n13 * m31;
                    this._globalMatrices[mtxOffset + 1] = n11 * m12 + n12 * m22 + n13 * m32;
                    this._globalMatrices[mtxOffset + 2] = n11 * m13 + n12 * m23 + n13 * m33;
                    this._globalMatrices[mtxOffset + 3] = n11 * m14 + n12 * m24 + n13 * m34 + vec.x;
                    this._globalMatrices[mtxOffset + 4] = n21 * m11 + n22 * m21 + n23 * m31;
                    this._globalMatrices[mtxOffset + 5] = n21 * m12 + n22 * m22 + n23 * m32;
                    this._globalMatrices[mtxOffset + 6] = n21 * m13 + n22 * m23 + n23 * m33;
                    this._globalMatrices[mtxOffset + 7] = n21 * m14 + n22 * m24 + n23 * m34 + vec.y;
                    this._globalMatrices[mtxOffset + 8] = n31 * m11 + n32 * m21 + n33 * m31;
                    this._globalMatrices[mtxOffset + 9] = n31 * m12 + n32 * m22 + n33 * m32;
                    this._globalMatrices[mtxOffset + 10] = n31 * m13 + n32 * m23 + n33 * m33;
                    this._globalMatrices[mtxOffset + 11] = n31 * m14 + n32 * m24 + n33 * m34 + vec.z;

                    mtxOffset = mtxOffset + 12;
                }
            };

            SkeletonAnimator.prototype.getRenderableSubGeometry = function (renderable, sourceSubGeometry) {
                this._morphedSubGeometryDirty[sourceSubGeometry.id] = true;

                //early out for GPU animations
                if (!this._pAnimationSet.usesCPU)
                    return sourceSubGeometry;

                var targetSubGeometry;

                if (!(targetSubGeometry = this._morphedSubGeometry[sourceSubGeometry.id])) {
                    //not yet stored
                    targetSubGeometry = this._morphedSubGeometry[sourceSubGeometry.id] = sourceSubGeometry.clone();

                    //turn off auto calculations on the morphed geometry
                    targetSubGeometry.autoDeriveNormals = false;
                    targetSubGeometry.autoDeriveTangents = false;
                    targetSubGeometry.autoDeriveUVs = false;

                    //add event listeners for any changes in UV values on the source geometry
                    sourceSubGeometry.addEventListener(away.events.SubGeometryEvent.INDICES_UPDATED, this._onIndicesUpdateDelegate);
                    sourceSubGeometry.addEventListener(away.events.SubGeometryEvent.VERTICES_UPDATED, this._onVerticesUpdateDelegate);
                }

                return targetSubGeometry;
            };

            /**
            * If the animation can't be performed on GPU, transform vertices manually
            * @param subGeom The subgeometry containing the weights and joint index data per vertex.
            * @param pass The material pass for which we need to transform the vertices
            */
            SkeletonAnimator.prototype.morphSubGeometry = function (renderable, sourceSubGeometry) {
                this._morphedSubGeometryDirty[sourceSubGeometry.id] = false;

                var sourcePositions = sourceSubGeometry.positions;
                var sourceNormals = sourceSubGeometry.vertexNormals;
                var sourceTangents = sourceSubGeometry.vertexTangents;

                var jointIndices = sourceSubGeometry.jointIndices;
                var jointWeights = sourceSubGeometry.jointWeights;

                var targetSubGeometry = this._morphedSubGeometry[sourceSubGeometry.id];

                var targetPositions = targetSubGeometry.positions;
                var targetNormals = targetSubGeometry.vertexNormals;
                var targetTangents = targetSubGeometry.vertexTangents;

                var index = 0;
                var j = 0;
                var k;
                var vx, vy, vz;
                var nx, ny, nz;
                var tx, ty, tz;
                var len = sourcePositions.length;
                var weight;
                var vertX, vertY, vertZ;
                var normX, normY, normZ;
                var tangX, tangY, tangZ;
                var m11, m12, m13, m14;
                var m21, m22, m23, m24;
                var m31, m32, m33, m34;

                while (index < len) {
                    vertX = sourcePositions[index];
                    vertY = sourcePositions[index + 1];
                    vertZ = sourcePositions[index + 2];
                    normX = sourceNormals[index];
                    normY = sourceNormals[index + 1];
                    normZ = sourceNormals[index + 2];
                    tangX = sourceTangents[index];
                    tangY = sourceTangents[index + 1];
                    tangZ = sourceTangents[index + 2];
                    vx = 0;
                    vy = 0;
                    vz = 0;
                    nx = 0;
                    ny = 0;
                    nz = 0;
                    tx = 0;
                    ty = 0;
                    tz = 0;
                    k = 0;
                    while (k < this._jointsPerVertex) {
                        weight = jointWeights[j];
                        if (weight > 0) {
                            // implicit /3*12 (/3 because indices are multiplied by 3 for gpu matrix access, *12 because it's the matrix size)
                            var mtxOffset = jointIndices[j++] << 2;
                            m11 = this._globalMatrices[mtxOffset];
                            m12 = this._globalMatrices[mtxOffset + 1];
                            m13 = this._globalMatrices[mtxOffset + 2];
                            m14 = this._globalMatrices[mtxOffset + 3];
                            m21 = this._globalMatrices[mtxOffset + 4];
                            m22 = this._globalMatrices[mtxOffset + 5];
                            m23 = this._globalMatrices[mtxOffset + 6];
                            m24 = this._globalMatrices[mtxOffset + 7];
                            m31 = this._globalMatrices[mtxOffset + 8];
                            m32 = this._globalMatrices[mtxOffset + 9];
                            m33 = this._globalMatrices[mtxOffset + 10];
                            m34 = this._globalMatrices[mtxOffset + 11];
                            vx += weight * (m11 * vertX + m12 * vertY + m13 * vertZ + m14);
                            vy += weight * (m21 * vertX + m22 * vertY + m23 * vertZ + m24);
                            vz += weight * (m31 * vertX + m32 * vertY + m33 * vertZ + m34);
                            nx += weight * (m11 * normX + m12 * normY + m13 * normZ);
                            ny += weight * (m21 * normX + m22 * normY + m23 * normZ);
                            nz += weight * (m31 * normX + m32 * normY + m33 * normZ);
                            tx += weight * (m11 * tangX + m12 * tangY + m13 * tangZ);
                            ty += weight * (m21 * tangX + m22 * tangY + m23 * tangZ);
                            tz += weight * (m31 * tangX + m32 * tangY + m33 * tangZ);
                            ++k;
                        } else {
                            j += (this._jointsPerVertex - k);
                            k = this._jointsPerVertex;
                        }
                    }

                    targetPositions[index] = vx;
                    targetPositions[index + 1] = vy;
                    targetPositions[index + 2] = vz;
                    targetNormals[index] = nx;
                    targetNormals[index + 1] = ny;
                    targetNormals[index + 2] = nz;
                    targetTangents[index] = tx;
                    targetTangents[index + 1] = ty;
                    targetTangents[index + 2] = tz;

                    index += 3;
                }

                targetSubGeometry.updatePositions(targetPositions);
                targetSubGeometry.updateVertexNormals(targetNormals);
                targetSubGeometry.updateVertexTangents(targetTangents);
            };

            /**
            * Converts a local hierarchical skeleton pose to a global pose
            * @param targetPose The SkeletonPose object that will contain the global pose.
            * @param skeleton The skeleton containing the joints, and as such, the hierarchical data to transform to global poses.
            */
            SkeletonAnimator.prototype.localToGlobalPose = function (sourcePose, targetPose, skeleton) {
                var globalPoses = targetPose.jointPoses;
                var globalJointPose;
                var joints = skeleton.joints;
                var len = sourcePose.numJointPoses;
                var jointPoses = sourcePose.jointPoses;
                var parentIndex;
                var joint;
                var parentPose;
                var pose;
                var or;
                var tr;
                var t;
                var q;

                var x1, y1, z1, w1;
                var x2, y2, z2, w2;
                var x3, y3, z3;

                // :s
                if (globalPoses.length != len)
                    globalPoses.length = len;

                for (var i = 0; i < len; ++i) {
                    globalJointPose = globalPoses[i];

                    if (globalJointPose == null)
                        globalJointPose = globalPoses[i] = new animators.JointPose();

                    joint = joints[i];
                    parentIndex = joint.parentIndex;
                    pose = jointPoses[i];

                    q = globalJointPose.orientation;
                    t = globalJointPose.translation;

                    if (parentIndex < 0) {
                        tr = pose.translation;
                        or = pose.orientation;
                        q.x = or.x;
                        q.y = or.y;
                        q.z = or.z;
                        q.w = or.w;
                        t.x = tr.x;
                        t.y = tr.y;
                        t.z = tr.z;
                    } else {
                        // append parent pose
                        parentPose = globalPoses[parentIndex];

                        // rotate point
                        or = parentPose.orientation;
                        tr = pose.translation;
                        x2 = or.x;
                        y2 = or.y;
                        z2 = or.z;
                        w2 = or.w;
                        x3 = tr.x;
                        y3 = tr.y;
                        z3 = tr.z;

                        w1 = -x2 * x3 - y2 * y3 - z2 * z3;
                        x1 = w2 * x3 + y2 * z3 - z2 * y3;
                        y1 = w2 * y3 - x2 * z3 + z2 * x3;
                        z1 = w2 * z3 + x2 * y3 - y2 * x3;

                        // append parent translation
                        tr = parentPose.translation;
                        t.x = -w1 * x2 + x1 * w2 - y1 * z2 + z1 * y2 + tr.x;
                        t.y = -w1 * y2 + x1 * z2 + y1 * w2 - z1 * x2 + tr.y;
                        t.z = -w1 * z2 - x1 * y2 + y1 * x2 + z1 * w2 + tr.z;

                        // append parent orientation
                        x1 = or.x;
                        y1 = or.y;
                        z1 = or.z;
                        w1 = or.w;
                        or = pose.orientation;
                        x2 = or.x;
                        y2 = or.y;
                        z2 = or.z;
                        w2 = or.w;

                        q.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
                        q.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
                        q.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
                        q.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
                    }
                }
            };

            SkeletonAnimator.prototype.onTransitionComplete = function (event) {
                if (event.type == AnimationStateEvent.TRANSITION_COMPLETE) {
                    event.animationNode.removeEventListener(AnimationStateEvent.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);

                    //if this is the current active state transition, revert control to the active node
                    if (this._pActiveState == event.animationState) {
                        this._pActiveNode = this._pAnimationSet.getAnimation(this._pActiveAnimationName);
                        this._pActiveState = this.getAnimationState(this._pActiveNode);
                        this._activeSkeletonState = this._pActiveState;
                    }
                }
            };

            SkeletonAnimator.prototype.onIndicesUpdate = function (event) {
                var subGeometry = event.target;

                this._morphedSubGeometry[subGeometry.id].updateIndices(subGeometry.indices);
            };

            SkeletonAnimator.prototype.onVerticesUpdate = function (event) {
                var subGeometry = event.target;
                var morphGeometry = this._morphedSubGeometry[subGeometry.id];

                switch (event.dataType) {
                    case TriangleSubGeometry.UV_DATA:
                        morphGeometry.updateUVs(subGeometry.uvs);
                    case TriangleSubGeometry.SECONDARY_UV_DATA:
                        morphGeometry.updateUVs(subGeometry.secondaryUVs);
                }
            };
            return SkeletonAnimator;
        })(animators.AnimatorBase);
        animators.SkeletonAnimator = SkeletonAnimator;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * The animation data set used by skeleton-based animators, containing skeleton animation data.
        *
        * @see away.animators.SkeletonAnimator
        */
        var SkeletonAnimationSet = (function (_super) {
            __extends(SkeletonAnimationSet, _super);
            /**
            * Creates a new <code>SkeletonAnimationSet</code> object.
            *
            * @param jointsPerVertex Sets the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the maximum allowed value is 4. Defaults to 4.
            */
            function SkeletonAnimationSet(jointsPerVertex) {
                if (typeof jointsPerVertex === "undefined") { jointsPerVertex = 4; }
                _super.call(this);

                this._jointsPerVertex = jointsPerVertex;
            }
            Object.defineProperty(SkeletonAnimationSet.prototype, "jointsPerVertex", {
                /**
                * Returns the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the
                * maximum allowed value is 4.
                */
                get: function () {
                    return this._jointsPerVertex;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.getAGALVertexCode = function (pass, sourceRegisters, targetRegisters, profile) {
                var len = sourceRegisters.length;

                var indexOffset0 = pass.numUsedVertexConstants;
                var indexOffset1 = indexOffset0 + 1;
                var indexOffset2 = indexOffset0 + 2;
                var indexStream = "va" + pass.numUsedStreams;
                var weightStream = "va" + (pass.numUsedStreams + 1);
                var indices = [indexStream + ".x", indexStream + ".y", indexStream + ".z", indexStream + ".w"];
                var weights = [weightStream + ".x", weightStream + ".y", weightStream + ".z", weightStream + ".w"];
                var temp1 = this._pFindTempReg(targetRegisters);
                var temp2 = this._pFindTempReg(targetRegisters, temp1);
                var dot = "dp4";
                var code = "";

                for (var i = 0; i < len; ++i) {
                    var src = sourceRegisters[i];

                    for (var j = 0; j < this._jointsPerVertex; ++j) {
                        code += dot + " " + temp1 + ".x, " + src + ", vc[" + indices[j] + "+" + indexOffset0 + "]		\n" + dot + " " + temp1 + ".y, " + src + ", vc[" + indices[j] + "+" + indexOffset1 + "]    	\n" + dot + " " + temp1 + ".z, " + src + ", vc[" + indices[j] + "+" + indexOffset2 + "]		\n" + "mov " + temp1 + ".w, " + src + ".w		\n" + "mul " + temp1 + ", " + temp1 + ", " + weights[j] + "\n"; // apply weight

                        // add or mov to target. Need to write to a temp reg first, because an output can be a target
                        if (j == 0)
                            code += "mov " + temp2 + ", " + temp1 + "\n";
                        else
                            code += "add " + temp2 + ", " + temp2 + ", " + temp1 + "\n";
                    }

                    // switch to dp3 once positions have been transformed, from now on, it should only be vectors instead of points
                    dot = "dp3";
                    code += "mov " + targetRegisters[i] + ", " + temp2 + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.activate = function (stageGL, pass) {
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.deactivate = function (stageGL, pass) {
                var streamOffset = pass.numUsedStreams;
                var context = stageGL.contextGL;
                context.setVertexBufferAt(streamOffset, null);
                context.setVertexBufferAt(streamOffset + 1, null);
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.getAGALFragmentCode = function (pass, shadedTarget, profile) {
                return "";
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.getAGALUVCode = function (pass, UVSource, UVTarget) {
                return "mov " + UVTarget + "," + UVSource + "\n";
            };

            /**
            * @inheritDoc
            */
            SkeletonAnimationSet.prototype.doneAGALCode = function (pass) {
            };
            return SkeletonAnimationSet;
        })(animators.AnimationSetBase);
        animators.SkeletonAnimationSet = SkeletonAnimationSet;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        /**
        * The animation data set used by vertex-based animators, containing vertex animation state data.
        *
        * @see away.animators.VertexAnimator
        */
        var VertexAnimationSet = (function (_super) {
            __extends(VertexAnimationSet, _super);
            /**
            * Creates a new <code>VertexAnimationSet</code> object.
            *
            * @param numPoses The number of poses made available at once to the GPU animation code.
            * @param blendMode Optional value for setting the animation mode of the vertex animator object.
            *
            * @see away3d.animators.data.VertexAnimationMode
            */
            function VertexAnimationSet(numPoses, blendMode) {
                if (typeof numPoses === "undefined") { numPoses = 2; }
                if (typeof blendMode === "undefined") { blendMode = "absolute"; }
                _super.call(this);
                this._streamIndices = new Object();
                this._useNormals = new Object();
                this._useTangents = new Object();
                this._numPoses = numPoses;
                this._blendMode = blendMode;
            }
            Object.defineProperty(VertexAnimationSet.prototype, "numPoses", {
                /**
                * Returns the number of poses made available at once to the GPU animation code.
                */
                get: function () {
                    return this._numPoses;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexAnimationSet.prototype, "blendMode", {
                /**
                * Returns the active blend mode of the vertex animator object.
                */
                get: function () {
                    return this._blendMode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexAnimationSet.prototype, "useNormals", {
                /**
                * Returns whether or not normal data is used in last set GPU pass of the vertex shader.
                */
                get: function () {
                    return this._uploadNormals;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALVertexCode = function (pass, sourceRegisters, targetRegisters, profile) {
                if (this._blendMode == away.animators.VertexAnimationMode.ABSOLUTE)
                    return this.getAbsoluteAGALCode(pass, sourceRegisters, targetRegisters);
                else
                    return this.getAdditiveAGALCode(pass, sourceRegisters, targetRegisters);
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.activate = function (stageGL, pass) {
                var uID = pass._iUniqueId;
                this._uploadNormals = this._useNormals[uID];
                this._uploadTangents = this._useTangents[uID];
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.deactivate = function (stageGL, pass) {
                var uID = pass._iUniqueId;
                var index = this._streamIndices[uID];
                var context = stageGL.contextGL;
                context.setVertexBufferAt(index, null);
                if (this._uploadNormals)
                    context.setVertexBufferAt(index + 1, null);
                if (this._uploadTangents)
                    context.setVertexBufferAt(index + 2, null);
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALFragmentCode = function (pass, shadedTarget, profile) {
                return "";
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALUVCode = function (pass, UVSource, UVTarget) {
                return "mov " + UVTarget + "," + UVSource + "\n";
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.doneAGALCode = function (pass) {
            };

            /**
            * Generates the vertex AGAL code for absolute blending.
            */
            VertexAnimationSet.prototype.getAbsoluteAGALCode = function (pass, sourceRegisters, targetRegisters) {
                var code = "";
                var uID = pass._iUniqueId;
                var temp1 = this._pFindTempReg(targetRegisters);
                var temp2 = this._pFindTempReg(targetRegisters, temp1);
                var regs = new Array("x", "y", "z", "w");
                var len = sourceRegisters.length;
                var constantReg = "vc" + pass.numUsedVertexConstants;
                var useTangents = this._useTangents[uID] = (len > 2);
                this._useNormals[uID] = (len > 1);

                if (len > 2)
                    len = 2;
                var streamIndex = this._streamIndices[uID] = pass.numUsedStreams;

                for (var i = 0; i < len; ++i) {
                    code += "mul " + temp1 + ", " + sourceRegisters[i] + ", " + constantReg + "." + regs[0] + "\n";

                    for (var j = 1; j < this._numPoses; ++j) {
                        code += "mul " + temp2 + ", va" + streamIndex + ", " + constantReg + "." + regs[j] + "\n";

                        if (j < this._numPoses - 1)
                            code += "add " + temp1 + ", " + temp1 + ", " + temp2 + "\n";

                        ++streamIndex;
                    }

                    code += "add " + targetRegisters[i] + ", " + temp1 + ", " + temp2 + "\n";
                }

                // add code for bitangents if tangents are used
                if (useTangents) {
                    code += "dp3 " + temp1 + ".x, " + sourceRegisters[2] + ", " + targetRegisters[1] + "\n" + "mul " + temp1 + ", " + targetRegisters[1] + ", " + temp1 + ".x			 \n" + "sub " + targetRegisters[2] + ", " + sourceRegisters[2] + ", " + temp1 + "\n";
                }
                return code;
            };

            /**
            * Generates the vertex AGAL code for additive blending.
            */
            VertexAnimationSet.prototype.getAdditiveAGALCode = function (pass, sourceRegisters, targetRegisters) {
                var code = "";
                var uID = pass._iUniqueId;
                var len = sourceRegisters.length;
                var regs = ["x", "y", "z", "w"];
                var temp1 = this._pFindTempReg(targetRegisters);
                var k;
                var useTangents = this._useTangents[uID] = (len > 2);
                var useNormals = this._useNormals[uID] = (len > 1);
                var streamIndex = this._streamIndices[uID] = pass.numUsedStreams;

                if (len > 2)
                    len = 2;

                code += "mov  " + targetRegisters[0] + ", " + sourceRegisters[0] + "\n";
                if (useNormals)
                    code += "mov " + targetRegisters[1] + ", " + sourceRegisters[1] + "\n";

                for (var i = 0; i < len; ++i) {
                    for (var j = 0; j < this._numPoses; ++j) {
                        code += "mul " + temp1 + ", va" + (streamIndex + k) + ", vc" + pass.numUsedVertexConstants + "." + regs[j] + "\n" + "add " + targetRegisters[i] + ", " + targetRegisters[i] + ", " + temp1 + "\n";
                        k++;
                    }
                }

                if (useTangents) {
                    code += "dp3 " + temp1 + ".x, " + sourceRegisters[2] + ", " + targetRegisters[1] + "\n" + "mul " + temp1 + ", " + targetRegisters[1] + ", " + temp1 + ".x			 \n" + "sub " + targetRegisters[2] + ", " + sourceRegisters[2] + ", " + temp1 + "\n";
                }

                return code;
            };
            return VertexAnimationSet;
        })(animators.AnimationSetBase);
        animators.VertexAnimationSet = VertexAnimationSet;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (animators) {
        var TriangleSubGeometry = away.base.TriangleSubGeometry;

        var VertexDataPool = away.pool.VertexDataPool;

        /**
        * Provides an interface for assigning vertex-based animation data sets to mesh-based entity objects
        * and controlling the various available states of animation through an interative playhead that can be
        * automatically updated or manually triggered.
        */
        var VertexAnimator = (function (_super) {
            __extends(VertexAnimator, _super);
            /**
            * Creates a new <code>VertexAnimator</code> object.
            *
            * @param vertexAnimationSet The animation data set containing the vertex animations used by the animator.
            */
            function VertexAnimator(vertexAnimationSet) {
                _super.call(this, vertexAnimationSet);
                this._poses = new Array();
                this._weights = Array(1, 0, 0, 0);

                this._vertexAnimationSet = vertexAnimationSet;
                this._numPoses = vertexAnimationSet.numPoses;
                this._blendMode = vertexAnimationSet.blendMode;
            }
            /**
            * @inheritDoc
            */
            VertexAnimator.prototype.clone = function () {
                return new VertexAnimator(this._vertexAnimationSet);
            };

            /**
            * Plays a sequence with a given name. If the sequence is not found, it may not be loaded yet, and it will retry every frame.
            * @param sequenceName The name of the clip to be played.
            */
            VertexAnimator.prototype.play = function (name, transition, offset) {
                if (typeof transition === "undefined") { transition = null; }
                if (typeof offset === "undefined") { offset = NaN; }
                if (this._pActiveAnimationName == name)
                    return;

                this._pActiveAnimationName = name;

                //TODO: implement transitions in vertex animator
                if (!this._pAnimationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");

                this._pActiveNode = this._pAnimationSet.getAnimation(name);

                this._pActiveState = this.getAnimationState(this._pActiveNode);

                if (this.updatePosition) {
                    //update straight away to reset position deltas
                    this._pActiveState.update(this._pAbsoluteTime);
                    this._pActiveState.positionDelta;
                }

                this._activeVertexState = this._pActiveState;

                this.start();

                //apply a time offset if specified
                if (!isNaN(offset))
                    this.reset(name, offset);
            };

            /**
            * @inheritDoc
            */
            VertexAnimator.prototype._pUpdateDeltaTime = function (dt) {
                _super.prototype._pUpdateDeltaTime.call(this, dt);

                var geometryFlag = false;

                if (this._poses[0] != this._activeVertexState.currentGeometry) {
                    this._poses[0] = this._activeVertexState.currentGeometry;
                    geometryFlag = true;
                }

                if (this._poses[1] != this._activeVertexState.nextGeometry) {
                    this._poses[1] = this._activeVertexState.nextGeometry;
                    geometryFlag = true;
                }

                this._weights[0] = 1 - (this._weights[1] = this._activeVertexState.blendWeight);

                if (geometryFlag) {
                    //invalidate meshes
                    var mesh;
                    var len = this._pOwners.length;
                    for (var i = 0; i < len; i++) {
                        mesh = this._pOwners[i];
                        mesh._iInvalidateRenderableGeometries();
                    }
                }
            };

            /**
            * @inheritDoc
            */
            VertexAnimator.prototype.setRenderState = function (stageGL, renderable, vertexConstantOffset /*int*/ , vertexStreamOffset /*int*/ , camera) {
                // todo: add code for when running on cpu
                // if no poses defined, set temp data
                if (!this._poses.length) {
                    this.setNullPose(stageGL, renderable, vertexConstantOffset, vertexStreamOffset);
                    return;
                }

                // this type of animation can only be SubMesh
                var subMesh = renderable.subMesh;
                var subGeom;
                var i;
                var len = this._numPoses;

                stageGL.contextGL.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, vertexConstantOffset, this._weights, 1);

                if (this._blendMode == animators.VertexAnimationMode.ABSOLUTE)
                    i = 1;
                else
                    i = 0;

                for (; i < len; ++i) {
                    subGeom = this._poses[i].subGeometries[subMesh._iIndex] || subMesh.subGeometry;

                    stageGL.activateBuffer(vertexStreamOffset++, VertexDataPool.getItem(subGeom, renderable.getIndexData(), TriangleSubGeometry.POSITION_DATA), subGeom.getOffset(TriangleSubGeometry.POSITION_DATA), TriangleSubGeometry.POSITION_FORMAT);

                    if (this._vertexAnimationSet.useNormals)
                        stageGL.activateBuffer(vertexStreamOffset++, VertexDataPool.getItem(subGeom, renderable.getIndexData(), TriangleSubGeometry.NORMAL_DATA), subGeom.getOffset(TriangleSubGeometry.NORMAL_DATA), TriangleSubGeometry.NORMAL_FORMAT);
                }
            };

            VertexAnimator.prototype.setNullPose = function (stageGL, renderable, vertexConstantOffset /*int*/ , vertexStreamOffset /*int*/ ) {
                stageGL.contextGL.setProgramConstantsFromArray(away.stagegl.ContextGLProgramType.VERTEX, vertexConstantOffset, this._weights, 1);

                if (this._blendMode == animators.VertexAnimationMode.ABSOLUTE) {
                    var len = this._numPoses;
                    for (var i = 1; i < len; ++i) {
                        stageGL.activateBuffer(vertexStreamOffset++, renderable.getVertexData(TriangleSubGeometry.POSITION_DATA), renderable.getVertexOffset(TriangleSubGeometry.POSITION_DATA), TriangleSubGeometry.POSITION_FORMAT);

                        if (this._vertexAnimationSet.useNormals)
                            stageGL.activateBuffer(vertexStreamOffset++, renderable.getVertexData(TriangleSubGeometry.NORMAL_DATA), renderable.getVertexOffset(TriangleSubGeometry.NORMAL_DATA), TriangleSubGeometry.NORMAL_FORMAT);
                    }
                }
                // todo: set temp data for additive?
            };

            /**
            * Verifies if the animation will be used on cpu. Needs to be true for all passes for a material to be able to use it on gpu.
            * Needs to be called if gpu code is potentially required.
            */
            VertexAnimator.prototype.testGPUCompatibility = function (pass) {
            };

            VertexAnimator.prototype.getRenderableSubGeometry = function (renderable, sourceSubGeometry) {
                if (this._blendMode == animators.VertexAnimationMode.ABSOLUTE && this._poses.length)
                    return this._poses[0].subGeometries[renderable.subMesh._iIndex] || sourceSubGeometry;

                //nothing to do here
                return sourceSubGeometry;
            };
            return VertexAnimator;
        })(animators.AnimatorBase);
        animators.VertexAnimator = VertexAnimator;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (parsers) {
        var TriangleSubGeometry = away.base.TriangleSubGeometry;
        var Mesh = away.entities.Mesh;
        var DefaultMaterialManager = away.materials.DefaultMaterialManager;
        var BasicSpecularMethod = away.materials.SpecularBasicMethod;
        var ColorMaterial = away.materials.ColorMaterial;
        var ColorMultiPassMaterial = away.materials.ColorMultiPassMaterial;

        var TextureMaterial = away.materials.TextureMaterial;
        var TextureMultiPassMaterial = away.materials.TextureMultiPassMaterial;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        /**
        * OBJParser provides a parser for the OBJ data type.
        */
        var OBJParser = (function (_super) {
            __extends(OBJParser, _super);
            /**
            * Creates a new OBJParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function OBJParser(scale) {
                if (typeof scale === "undefined") { scale = 1; }
                _super.call(this, URLLoaderDataFormat.TEXT);
                this._mtlLibLoaded = true;
                this._activeMaterialID = "";
                this._scale = scale;
            }
            Object.defineProperty(OBJParser.prototype, "scale", {
                /**
                * Scaling factor applied directly to vertices data
                * @param value The scaling factor.
                */
                set: function (value) {
                    this._scale = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            OBJParser.supportsType = function (extension) {
                extension = extension.toLowerCase();
                return extension == "obj";
            };

            /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            OBJParser.supportsData = function (data) {
                var content = parsers.ParserUtils.toString(data);
                var hasV = false;
                var hasF = false;

                if (content) {
                    hasV = content.indexOf("\nv ") != -1;
                    hasF = content.indexOf("\nf ") != -1;
                }

                return hasV && hasF;
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.id == 'mtl') {
                    var str = parsers.ParserUtils.toString(resourceDependency.data);
                    this.parseMtl(str);
                } else {
                    var asset;

                    if (resourceDependency.assets.length != 1) {
                        return;
                    }

                    asset = resourceDependency.assets[0];

                    if (asset.assetType == away.library.AssetType.TEXTURE) {
                        var lm = new LoadedMaterial();
                        lm.materialID = resourceDependency.id;
                        lm.texture = asset;

                        this._materialLoaded.push(lm);

                        if (this._meshes.length > 0) {
                            this.applyMaterial(lm);
                        }
                    }
                }
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                if (resourceDependency.id == "mtl") {
                    this._mtlLib = false;
                    this._mtlLibLoaded = false;
                } else {
                    var lm = new LoadedMaterial();
                    lm.materialID = resourceDependency.id;
                    this._materialLoaded.push(lm);
                }

                if (this._meshes.length > 0)
                    this.applyMaterial(lm);
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._pProceedParsing = function () {
                var line;
                var creturn = String.fromCharCode(10);
                var trunk;

                if (!this._startedParsing) {
                    this._textData = this._pGetTextData();

                    // Merge linebreaks that are immediately preceeded by
                    // the "escape" backward slash into single lines.
                    this._textData = this._textData.replace(/\\[\r\n]+\s*/gm, ' ');
                }

                if (this._textData.indexOf(creturn) == -1)
                    creturn = String.fromCharCode(13);

                if (!this._startedParsing) {
                    this._startedParsing = true;
                    this._vertices = new Array();
                    this._vertexNormals = new Array();
                    this._materialIDs = new Array();
                    this._materialLoaded = new Array();
                    this._meshes = new Array();
                    this._uvs = new Array();
                    this._stringLength = this._textData.length;
                    this._charIndex = this._textData.indexOf(creturn, 0);
                    this._oldIndex = 0;
                    this._objects = new Array();
                    this._objectIndex = 0;
                }

                while (this._charIndex < this._stringLength && this._pHasTime()) {
                    this._charIndex = this._textData.indexOf(creturn, this._oldIndex);

                    if (this._charIndex == -1)
                        this._charIndex = this._stringLength;

                    line = this._textData.substring(this._oldIndex, this._charIndex);
                    line = line.split('\r').join("");
                    line = line.replace("  ", " ");
                    trunk = line.split(" ");
                    this._oldIndex = this._charIndex + 1;
                    this.parseLine(trunk);

                    // If whatever was parsed on this line resulted in the
                    // parsing being paused to retrieve dependencies, break
                    // here and do not continue parsing until un-paused.
                    if (this.parsingPaused) {
                        return parsers.ParserBase.MORE_TO_PARSE;
                    }
                }

                if (this._charIndex >= this._stringLength) {
                    if (this._mtlLib && !this._mtlLibLoaded) {
                        return parsers.ParserBase.MORE_TO_PARSE;
                    }

                    this.translate();
                    this.applyMaterials();

                    return parsers.ParserBase.PARSING_DONE;
                }

                return parsers.ParserBase.MORE_TO_PARSE;
            };

            OBJParser.prototype._pStartParsing = function (frameLimit) {
                _super.prototype._pStartParsing.call(this, frameLimit);

                //create a content object for Loaders
                this._pContent = new away.containers.DisplayObjectContainer();
            };

            /**
            * Parses a single line in the OBJ file.
            */
            OBJParser.prototype.parseLine = function (trunk) {
                switch (trunk[0]) {
                    case "mtllib":
                        this._mtlLib = true;
                        this._mtlLibLoaded = false;
                        this.loadMtl(trunk[1]);

                        break;

                    case "g":
                        this.createGroup(trunk);

                        break;

                    case "o":
                        this.createObject(trunk);

                        break;

                    case "usemtl":
                        if (this._mtlLib) {
                            if (!trunk[1])
                                trunk[1] = "def000";

                            this._materialIDs.push(trunk[1]);
                            this._activeMaterialID = trunk[1];

                            if (this._currentGroup)
                                this._currentGroup.materialID = this._activeMaterialID;
                        }

                        break;

                    case "v":
                        this.parseVertex(trunk);

                        break;

                    case "vt":
                        this.parseUV(trunk);

                        break;

                    case "vn":
                        this.parseVertexNormal(trunk);

                        break;

                    case "f":
                        this.parseFace(trunk);
                }
            };

            /**
            * Converts the parsed data into an Away3D scenegraph structure
            */
            OBJParser.prototype.translate = function () {
                for (var objIndex = 0; objIndex < this._objects.length; ++objIndex) {
                    var groups = this._objects[objIndex].groups;
                    var numGroups = groups.length;
                    var materialGroups;
                    var numMaterialGroups;
                    var geometry;
                    var mesh;

                    var m;
                    var sm;
                    var bmMaterial;

                    for (var g = 0; g < numGroups; ++g) {
                        geometry = new away.base.Geometry();
                        materialGroups = groups[g].materialGroups;
                        numMaterialGroups = materialGroups.length;

                        for (m = 0; m < numMaterialGroups; ++m)
                            this.translateMaterialGroup(materialGroups[m], geometry);

                        if (geometry.subGeometries.length == 0)
                            continue;

                        // Finalize and force type-based name
                        this._pFinalizeAsset(geometry); //, "");

                        if (this.materialMode < 2)
                            bmMaterial = new TextureMaterial(DefaultMaterialManager.getDefaultTexture());
                        else
                            bmMaterial = new TextureMultiPassMaterial(DefaultMaterialManager.getDefaultTexture());

                        //bmMaterial = new TextureMaterial(DefaultMaterialManager.getDefaultTexture());
                        mesh = new Mesh(geometry, bmMaterial);

                        if (this._objects[objIndex].name) {
                            // this is a full independent object ('o' tag in OBJ file)
                            mesh.name = this._objects[objIndex].name;
                        } else if (groups[g].name) {
                            // this is a group so the sub groups contain the actual mesh object names ('g' tag in OBJ file)
                            mesh.name = groups[g].name;
                        } else {
                            // No name stored. Use empty string which will force it
                            // to be overridden by finalizeAsset() to type default.
                            mesh.name = "";
                        }

                        this._meshes.push(mesh);

                        if (groups[g].materialID != "")
                            bmMaterial.name = groups[g].materialID + "~" + mesh.name;
                        else
                            bmMaterial.name = this._lastMtlID + "~" + mesh.name;

                        if (mesh.subMeshes.length > 1) {
                            for (sm = 1; sm < mesh.subMeshes.length; ++sm)
                                mesh.subMeshes[sm].material = bmMaterial;
                        }

                        //add to the content property
                        this._pContent.addChild(mesh);

                        this._pFinalizeAsset(mesh);
                    }
                }
            };

            /**
            * Translates an obj's material group to a subgeometry.
            * @param materialGroup The material group data to convert.
            * @param geometry The Geometry to contain the converted SubGeometry.
            */
            OBJParser.prototype.translateMaterialGroup = function (materialGroup, geometry) {
                var faces = materialGroup.faces;
                var face;
                var numFaces = faces.length;
                var numVerts;
                var sub;

                var vertices = new Array();
                var uvs = new Array();
                var normals = new Array();
                var indices = new Array();

                this._realIndices = [];
                this._vertexIndex = 0;

                var j;
                for (var i = 0; i < numFaces; ++i) {
                    face = faces[i];
                    numVerts = face.indexIds.length - 1;

                    for (j = 1; j < numVerts; ++j) {
                        this.translateVertexData(face, j, vertices, uvs, indices, normals);
                        this.translateVertexData(face, 0, vertices, uvs, indices, normals);
                        this.translateVertexData(face, j + 1, vertices, uvs, indices, normals);
                    }
                }
                if (vertices.length > 0) {
                    sub = new TriangleSubGeometry(true);
                    sub.autoDeriveNormals = normals.length ? false : true;
                    sub.updateIndices(indices);
                    sub.updatePositions(vertices);
                    sub.updateVertexNormals(normals);
                    sub.updateUVs(uvs);

                    geometry.addSubGeometry(sub);
                }
            };

            OBJParser.prototype.translateVertexData = function (face, vertexIndex, vertices, uvs, indices /*uint*/ , normals) {
                var index;
                var vertex;
                var vertexNormal;
                var uv;

                if (!this._realIndices[face.indexIds[vertexIndex]]) {
                    index = this._vertexIndex;
                    this._realIndices[face.indexIds[vertexIndex]] = ++this._vertexIndex;
                    vertex = this._vertices[face.vertexIndices[vertexIndex] - 1];
                    vertices.push(vertex.x * this._scale, vertex.y * this._scale, vertex.z * this._scale);

                    if (face.normalIndices.length > 0) {
                        vertexNormal = this._vertexNormals[face.normalIndices[vertexIndex] - 1];
                        normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
                    }

                    if (face.uvIndices.length > 0) {
                        try  {
                            uv = this._uvs[face.uvIndices[vertexIndex] - 1];
                            uvs.push(uv.u, uv.v);
                        } catch (e) {
                            switch (vertexIndex) {
                                case 0:
                                    uvs.push(0, 1);
                                    break;
                                case 1:
                                    uvs.push(.5, 0);
                                    break;
                                case 2:
                                    uvs.push(1, 1);
                            }
                        }
                    }
                } else {
                    index = this._realIndices[face.indexIds[vertexIndex]] - 1;
                }

                indices.push(index);
            };

            /**
            * Creates a new object group.
            * @param trunk The data block containing the object tag and its parameters
            */
            OBJParser.prototype.createObject = function (trunk) {
                this._currentGroup = null;
                this._currentMaterialGroup = null;
                this._objects.push(this._currentObject = new ObjectGroup());

                if (trunk)
                    this._currentObject.name = trunk[1];
            };

            /**
            * Creates a new group.
            * @param trunk The data block containing the group tag and its parameters
            */
            OBJParser.prototype.createGroup = function (trunk) {
                if (!this._currentObject)
                    this.createObject(null);
                this._currentGroup = new Group();

                this._currentGroup.materialID = this._activeMaterialID;

                if (trunk)
                    this._currentGroup.name = trunk[1];
                this._currentObject.groups.push(this._currentGroup);

                this.createMaterialGroup(null);
            };

            /**
            * Creates a new material group.
            * @param trunk The data block containing the material tag and its parameters
            */
            OBJParser.prototype.createMaterialGroup = function (trunk) {
                this._currentMaterialGroup = new MaterialGroup();
                if (trunk)
                    this._currentMaterialGroup.url = trunk[1];
                this._currentGroup.materialGroups.push(this._currentMaterialGroup);
            };

            /**
            * Reads the next vertex coordinates.
            * @param trunk The data block containing the vertex tag and its parameters
            */
            OBJParser.prototype.parseVertex = function (trunk) {
                //for the very rare cases of other delimiters/charcodes seen in some obj files
                var v1, v2, v3;
                if (trunk.length > 4) {
                    var nTrunk = [];
                    var val;

                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }

                    v1 = nTrunk[0];
                    v2 = nTrunk[1];
                    v3 = -nTrunk[2];
                    this._vertices.push(new Vertex(v1, v2, v3));
                } else {
                    v1 = parseFloat(trunk[1]);
                    v2 = parseFloat(trunk[2]);
                    v3 = -parseFloat(trunk[3]);

                    this._vertices.push(new Vertex(v1, v2, v3));
                }
            };

            /**
            * Reads the next uv coordinates.
            * @param trunk The data block containing the uv tag and its parameters
            */
            OBJParser.prototype.parseUV = function (trunk) {
                if (trunk.length > 3) {
                    var nTrunk = [];
                    var val;
                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }
                    this._uvs.push(new UV(nTrunk[0], 1 - nTrunk[1]));
                } else {
                    this._uvs.push(new UV(parseFloat(trunk[1]), 1 - parseFloat(trunk[2])));
                }
            };

            /**
            * Reads the next vertex normal coordinates.
            * @param trunk The data block containing the vertex normal tag and its parameters
            */
            OBJParser.prototype.parseVertexNormal = function (trunk) {
                if (trunk.length > 4) {
                    var nTrunk = [];
                    var val;
                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }
                    this._vertexNormals.push(new Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
                } else {
                    this._vertexNormals.push(new Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
                }
            };

            /**
            * Reads the next face's indices.
            * @param trunk The data block containing the face tag and its parameters
            */
            OBJParser.prototype.parseFace = function (trunk) {
                var len = trunk.length;
                var face = new FaceData();

                if (!this._currentGroup) {
                    this.createGroup(null);
                }

                var indices;
                for (var i = 1; i < len; ++i) {
                    if (trunk[i] == "") {
                        continue;
                    }

                    indices = trunk[i].split("/");
                    face.vertexIndices.push(this.parseIndex(parseInt(indices[0]), this._vertices.length));

                    if (indices[1] && String(indices[1]).length > 0)
                        face.uvIndices.push(this.parseIndex(parseInt(indices[1]), this._uvs.length));

                    if (indices[2] && String(indices[2]).length > 0)
                        face.normalIndices.push(this.parseIndex(parseInt(indices[2]), this._vertexNormals.length));

                    face.indexIds.push(trunk[i]);
                }

                this._currentMaterialGroup.faces.push(face);
            };

            /**
            * This is a hack around negative face coords
            */
            OBJParser.prototype.parseIndex = function (index, length) {
                if (index < 0)
                    return index + length + 1;
                else
                    return index;
            };

            OBJParser.prototype.parseMtl = function (data) {
                var materialDefinitions = data.split('newmtl');
                var lines;
                var trunk;
                var j;

                var basicSpecularMethod;
                var useSpecular;
                var useColor;
                var diffuseColor;
                var ambientColor;
                var specularColor;
                var specular;
                var alpha;
                var mapkd;

                for (var i = 0; i < materialDefinitions.length; ++i) {
                    lines = (materialDefinitions[i].split('\r')).join("").split('\n');

                    //lines = (materialDefinitions[i].split('\r') as Array).join("").split('\n');
                    if (lines.length == 1)
                        lines = materialDefinitions[i].split(String.fromCharCode(13));

                    diffuseColor = ambientColor = specularColor = 0xFFFFFF;
                    specular = 0;
                    useSpecular = false;
                    useColor = false;
                    alpha = 1;
                    mapkd = "";

                    for (j = 0; j < lines.length; ++j) {
                        lines[j] = lines[j].replace(/\s+$/, "");

                        if (lines[j].substring(0, 1) != "#" && (j == 0 || lines[j] != "")) {
                            trunk = lines[j].split(" ");

                            if (String(trunk[0]).charCodeAt(0) == 9 || String(trunk[0]).charCodeAt(0) == 32)
                                trunk[0] = trunk[0].substring(1, trunk[0].length);

                            if (j == 0) {
                                this._lastMtlID = trunk.join("");
                                this._lastMtlID = (this._lastMtlID == "") ? "def000" : this._lastMtlID;
                            } else {
                                switch (trunk[0]) {
                                    case "Ka":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3])))
                                            ambientColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                        break;

                                    case "Ks":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                            specularColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                            useSpecular = true;
                                        }
                                        break;

                                    case "Ns":
                                        if (trunk[1] && !isNaN(Number(trunk[1])))
                                            specular = Number(trunk[1]) * 0.001;
                                        if (specular == 0)
                                            useSpecular = false;
                                        break;

                                    case "Kd":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                            diffuseColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                            useColor = true;
                                        }
                                        break;

                                    case "tr":
                                    case "d":
                                        if (trunk[1] && !isNaN(Number(trunk[1])))
                                            alpha = Number(trunk[1]);
                                        break;

                                    case "map_Kd":
                                        mapkd = this.parseMapKdString(trunk);
                                        mapkd = mapkd.replace(/\\/g, "/");
                                }
                            }
                        }
                    }

                    if (mapkd != "") {
                        if (useSpecular) {
                            basicSpecularMethod = new BasicSpecularMethod();
                            basicSpecularMethod.specularColor = specularColor;
                            basicSpecularMethod.specular = specular;

                            var specularData = new SpecularData();
                            specularData.alpha = alpha;
                            specularData.basicSpecularMethod = basicSpecularMethod;
                            specularData.materialID = this._lastMtlID;

                            if (!this._materialSpecularData)
                                this._materialSpecularData = new Array();

                            this._materialSpecularData.push(specularData);
                        }

                        this._pAddDependency(this._lastMtlID, new away.net.URLRequest(mapkd));
                    } else if (useColor && !isNaN(diffuseColor)) {
                        var lm = new LoadedMaterial();
                        lm.materialID = this._lastMtlID;

                        if (alpha == 0)
                            console.log("Warning: an alpha value of 0 was found in mtl color tag (Tr or d) ref:" + this._lastMtlID + ", mesh(es) using it will be invisible!");

                        var cm;

                        if (this.materialMode < 2) {
                            cm = new ColorMaterial(diffuseColor);

                            var colorMat = cm;

                            colorMat.alpha = alpha;
                            colorMat.ambientColor = ambientColor;
                            colorMat.repeat = true;

                            if (useSpecular) {
                                colorMat.specularColor = specularColor;
                                colorMat.specular = specular;
                            }
                        } else {
                            cm = new ColorMultiPassMaterial(diffuseColor);

                            var colorMultiMat = cm;

                            colorMultiMat.ambientColor = ambientColor;
                            colorMultiMat.repeat = true;

                            if (useSpecular) {
                                colorMultiMat.specularColor = specularColor;
                                colorMultiMat.specular = specular;
                            }
                        }

                        lm.cm = cm;

                        this._materialLoaded.push(lm);

                        if (this._meshes.length > 0)
                            this.applyMaterial(lm);
                    }
                }

                this._mtlLibLoaded = true;
            };

            OBJParser.prototype.parseMapKdString = function (trunk) {
                var url = "";
                var i;
                var breakflag;

                for (i = 1; i < trunk.length;) {
                    switch (trunk[i]) {
                        case "-blendu":
                        case "-blendv":
                        case "-cc":
                        case "-clamp":
                        case "-texres":
                            i += 2; //Skip ahead 1 attribute
                            break;
                        case "-mm":
                            i += 3; //Skip ahead 2 attributes
                            break;
                        case "-o":
                        case "-s":
                        case "-t":
                            i += 4; //Skip ahead 3 attributes
                            continue;
                        default:
                            breakflag = true;
                            break;
                    }

                    if (breakflag)
                        break;
                }

                for (i; i < trunk.length; i++) {
                    url += trunk[i];
                    url += " ";
                }

                //Remove the extraneous space and/or newline from the right side
                url = url.replace(/\s+$/, "");

                return url;
            };

            OBJParser.prototype.loadMtl = function (mtlurl) {
                // Add raw-data dependency to queue and load dependencies now,
                // which will pause the parsing in the meantime.
                this._pAddDependency('mtl', new away.net.URLRequest(mtlurl), true);
                this._pPauseAndRetrieveDependencies(); //
            };

            OBJParser.prototype.applyMaterial = function (lm) {
                var decomposeID;
                var mesh;
                var mat;
                var j;
                var specularData;

                for (var i = 0; i < this._meshes.length; ++i) {
                    mesh = this._meshes[i];
                    decomposeID = mesh.material.name.split("~");

                    if (decomposeID[0] == lm.materialID) {
                        if (lm.cm) {
                            if (mesh.material)
                                mesh.material = null;
                            mesh.material = lm.cm;
                        } else if (lm.texture) {
                            if (this.materialMode < 2) {
                                mat = mesh.material;

                                var tm = mat;

                                tm.texture = lm.texture;
                                tm.ambientColor = lm.ambientColor;
                                tm.alpha = lm.alpha;
                                tm.repeat = true;

                                if (lm.specularMethod) {
                                    // By setting the specularMethod property to null before assigning
                                    // the actual method instance, we avoid having the properties of
                                    // the new method being overridden with the settings from the old
                                    // one, which is default behavior of the setter.
                                    tm.specularMethod = null;
                                    tm.specularMethod = lm.specularMethod;
                                } else if (this._materialSpecularData) {
                                    for (j = 0; j < this._materialSpecularData.length; ++j) {
                                        specularData = this._materialSpecularData[j];

                                        if (specularData.materialID == lm.materialID) {
                                            tm.specularMethod = null; // Prevent property overwrite (see above)
                                            tm.specularMethod = specularData.basicSpecularMethod;
                                            tm.ambientColor = specularData.ambientColor;
                                            tm.alpha = specularData.alpha;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                mat = mesh.material;

                                var tmMult = mat;

                                tmMult.texture = lm.texture;
                                tmMult.ambientColor = lm.ambientColor;
                                tmMult.repeat = true;

                                if (lm.specularMethod) {
                                    // By setting the specularMethod property to null before assigning
                                    // the actual method instance, we avoid having the properties of
                                    // the new method being overridden with the settings from the old
                                    // one, which is default behavior of the setter.
                                    tmMult.specularMethod = null;
                                    tmMult.specularMethod = lm.specularMethod;
                                } else if (this._materialSpecularData) {
                                    for (j = 0; j < this._materialSpecularData.length; ++j) {
                                        specularData = this._materialSpecularData[j];

                                        if (specularData.materialID == lm.materialID) {
                                            tmMult.specularMethod = null; // Prevent property overwrite (see above)
                                            tmMult.specularMethod = specularData.basicSpecularMethod;
                                            tmMult.ambientColor = specularData.ambientColor;

                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        mesh.material.name = decomposeID[1] ? decomposeID[1] : decomposeID[0];
                        this._meshes.splice(i, 1);
                        --i;
                    }
                }

                if (lm.cm || mat)
                    this._pFinalizeAsset(lm.cm || mat);
            };

            OBJParser.prototype.applyMaterials = function () {
                if (this._materialLoaded.length == 0)
                    return;

                for (var i = 0; i < this._materialLoaded.length; ++i)
                    this.applyMaterial(this._materialLoaded[i]);
            };
            return OBJParser;
        })(parsers.ParserBase);
        parsers.OBJParser = OBJParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

var BasicSpecularMethod = away.materials.SpecularBasicMethod;
var MaterialBase = away.materials.MaterialBase;
var Texture2DBase = away.textures.Texture2DBase;

var ObjectGroup = (function () {
    function ObjectGroup() {
        this.groups = new Array();
    }
    return ObjectGroup;
})();

var Group = (function () {
    function Group() {
        this.materialGroups = new Array();
    }
    return Group;
})();

var MaterialGroup = (function () {
    function MaterialGroup() {
        this.faces = new Array();
    }
    return MaterialGroup;
})();

var SpecularData = (function () {
    function SpecularData() {
        this.ambientColor = 0xFFFFFF;
        this.alpha = 1;
    }
    return SpecularData;
})();

var LoadedMaterial = (function () {
    function LoadedMaterial() {
        this.ambientColor = 0xFFFFFF;
        this.alpha = 1;
    }
    return LoadedMaterial;
})();

var FaceData = (function () {
    function FaceData() {
        this.vertexIndices = new Array();
        this.uvIndices = new Array();
        this.normalIndices = new Array();
        this.indexIds = new Array();
    }
    return FaceData;
})();

/**
* Texture coordinates value object.
*/
var UV = (function () {
    /**
    * Creates a new <code>UV</code> object.
    *
    * @param    u        [optional]    The horizontal coordinate of the texture value. Defaults to 0.
    * @param    v        [optional]    The vertical coordinate of the texture value. Defaults to 0.
    */
    function UV(u, v) {
        if (typeof u === "undefined") { u = 0; }
        if (typeof v === "undefined") { v = 0; }
        this._u = u;
        this._v = v;
    }
    Object.defineProperty(UV.prototype, "v", {
        /**
        * Defines the vertical coordinate of the texture value.
        */
        get: function () {
            return this._v;
        },
        set: function (value) {
            this._v = value;
        },
        enumerable: true,
        configurable: true
    });


    Object.defineProperty(UV.prototype, "u", {
        /**
        * Defines the horizontal coordinate of the texture value.
        */
        get: function () {
            return this._u;
        },
        set: function (value) {
            this._u = value;
        },
        enumerable: true,
        configurable: true
    });


    /**
    * returns a new UV value Object
    */
    UV.prototype.clone = function () {
        return new UV(this._u, this._v);
    };

    /**
    * returns the value object as a string for trace/debug purpose
    */
    UV.prototype.toString = function () {
        return this._u + "," + this._v;
    };
    return UV;
})();

var Vertex = (function () {
    /**
    * Creates a new <code>Vertex</code> value object.
    *
    * @param    x            [optional]    The x value. Defaults to 0.
    * @param    y            [optional]    The y value. Defaults to 0.
    * @param    z            [optional]    The z value. Defaults to 0.
    * @param    index        [optional]    The index value. Defaults is NaN.
    */
    function Vertex(x, y, z, index) {
        if (typeof x === "undefined") { x = 0; }
        if (typeof y === "undefined") { y = 0; }
        if (typeof z === "undefined") { z = 0; }
        if (typeof index === "undefined") { index = 0; }
        this._x = x;
        this._y = y;
        this._z = z;
        this._index = index;
    }

    Object.defineProperty(Vertex.prototype, "index", {
        get: function () {
            return this._index;
        },
        /**
        * To define/store the index of value object
        * @param    ind        The index
        */
        set: function (ind) {
            this._index = ind;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(Vertex.prototype, "x", {
        /**
        * To define/store the x value of the value object
        * @param    value        The x value
        */
        get: function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: true,
        configurable: true
    });


    Object.defineProperty(Vertex.prototype, "y", {
        /**
        * To define/store the y value of the value object
        * @param    value        The y value
        */
        get: function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: true,
        configurable: true
    });


    Object.defineProperty(Vertex.prototype, "z", {
        /**
        * To define/store the z value of the value object
        * @param    value        The z value
        */
        get: function () {
            return this._z;
        },
        set: function (value) {
            this._z = value;
        },
        enumerable: true,
        configurable: true
    });


    /**
    * returns a new Vertex value Object
    */
    Vertex.prototype.clone = function () {
        return new Vertex(this._x, this._y, this._z);
    };
    return Vertex;
})();
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (parsers) {
        var JointPose = away.animators.JointPose;
        var Skeleton = away.animators.Skeleton;
        var SkeletonAnimationSet = away.animators.SkeletonAnimationSet;
        var SkeletonAnimator = away.animators.SkeletonAnimator;
        var SkeletonClipNode = away.animators.SkeletonClipNode;
        var SkeletonPose = away.animators.SkeletonPose;
        var SkeletonJoint = away.animators.SkeletonJoint;
        var VertexAnimationSet = away.animators.VertexAnimationSet;
        var VertexAnimator = away.animators.VertexAnimator;
        var VertexClipNode = away.animators.VertexClipNode;
        var TriangleSubGeometry = away.base.TriangleSubGeometry;
        var Geometry = away.base.Geometry;
        var BlendMode = away.base.BlendMode;
        var Mesh = away.entities.Mesh;
        var Matrix3D = away.geom.Matrix3D;
        var AssetType = away.library.AssetType;
        var TextureMaterial = away.materials.TextureMaterial;
        var ShadowDitheredMethod = away.materials.ShadowDitheredMethod;
        var ShadowFilteredMethod = away.materials.ShadowFilteredMethod;
        var SkyboxMaterial = away.materials.SkyboxMaterial;
        var SpecularFresnelMethod = away.materials.SpecularFresnelMethod;
        var ShadowHardMethod = away.materials.ShadowHardMethod;
        var SpecularPhongMethod = away.materials.SpecularPhongMethod;

        var ShadowNearMethod = away.materials.ShadowNearMethod;

        var ShadowSoftMethod = away.materials.ShadowSoftMethod;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        /**
        * AWDParser provides a parser for the AWD data type.
        */
        var AWDParser = (function (_super) {
            __extends(AWDParser, _super);
            /**
            * Creates a new AWDParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function AWDParser() {
                _super.call(this, URLLoaderDataFormat.ARRAY_BUFFER);
                //set to "true" to have some console.logs in the Console
                this._debug = false;
                this._startedParsing = false;
                this._texture_users = {};
                this._parsed_header = false;

                this._blocks = new Array();
                this._blocks[0] = new AWDBlock();
                this._blocks[0].data = null; // Zero address means null in AWD

                this.blendModeDic = new Array(); // used to translate ints to blendMode-strings
                this.blendModeDic.push(BlendMode.NORMAL);
                this.blendModeDic.push(BlendMode.ADD);
                this.blendModeDic.push(BlendMode.ALPHA);
                this.blendModeDic.push(BlendMode.DARKEN);
                this.blendModeDic.push(BlendMode.DIFFERENCE);
                this.blendModeDic.push(BlendMode.ERASE);
                this.blendModeDic.push(BlendMode.HARDLIGHT);
                this.blendModeDic.push(BlendMode.INVERT);
                this.blendModeDic.push(BlendMode.LAYER);
                this.blendModeDic.push(BlendMode.LIGHTEN);
                this.blendModeDic.push(BlendMode.MULTIPLY);
                this.blendModeDic.push(BlendMode.NORMAL);
                this.blendModeDic.push(BlendMode.OVERLAY);
                this.blendModeDic.push(BlendMode.SCREEN);
                this.blendModeDic.push(BlendMode.SHADER);
                this.blendModeDic.push(BlendMode.OVERLAY);

                this._depthSizeDic = new Array(); // used to translate ints to depthSize-values
                this._depthSizeDic.push(256);
                this._depthSizeDic.push(512);
                this._depthSizeDic.push(2048);
                this._depthSizeDic.push(1024);
                this._version = Array(); // will contain 2 int (major-version, minor-version) for awd-version-check
            }
            /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            AWDParser.supportsType = function (extension) {
                extension = extension.toLowerCase();
                return extension == "awd";
            };

            /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            AWDParser.supportsData = function (data) {
                return (away.parsers.ParserUtils.toString(data, 3) == 'AWD');
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._iResolveDependency = function (resourceDependency) {
                // this will be called when Dependency has finished loading.
                // the Assets waiting for this Bitmap, can be Texture or CubeTexture.
                // if the Bitmap is awaited by a CubeTexture, we need to check if its the last Bitmap of the CubeTexture,
                // so we know if we have to finalize the Asset (CubeTexture) or not.
                if (resourceDependency.assets.length == 1) {
                    var isCubeTextureArray = resourceDependency.id.split("#");
                    var ressourceID = isCubeTextureArray[0];
                    var asset;
                    var thisBitmapTexture;
                    var block;

                    if (isCubeTextureArray.length == 1) {
                        asset = resourceDependency.assets[0];
                        if (asset) {
                            var mat;
                            var users;

                            block = this._blocks[resourceDependency.id];
                            block.data = asset; // Store finished asset

                            // Reset name of texture to the one defined in the AWD file,
                            // as opposed to whatever the image parser came up with.
                            asset.resetAssetPath(block.name, null, true);
                            block.name = asset.name;

                            // Finalize texture asset to dispatch texture event, which was
                            // previously suppressed while the dependency was loaded.
                            this._pFinalizeAsset(asset);

                            if (this._debug) {
                                console.log("Successfully loaded Bitmap for texture");
                                console.log("Parsed texture: Name = " + block.name);
                            }
                        }
                    }

                    if (isCubeTextureArray.length > 1) {
                        thisBitmapTexture = resourceDependency.assets[0];

                        var tx = thisBitmapTexture;

                        this._cubeTextures[isCubeTextureArray[1]] = tx.htmlImageElement; // ?
                        this._texture_users[ressourceID].push(1);

                        if (this._debug) {
                            console.log("Successfully loaded Bitmap " + this._texture_users[ressourceID].length + " / 6 for Cubetexture");
                        }
                        if (this._texture_users[ressourceID].length == this._cubeTextures.length) {
                            var posX = this._cubeTextures[0];
                            var negX = this._cubeTextures[1];
                            var posY = this._cubeTextures[2];
                            var negY = this._cubeTextures[3];
                            var posZ = this._cubeTextures[4];
                            var negZ = this._cubeTextures[5];

                            asset = new away.textures.ImageCubeTexture(posX, negX, posY, negY, posZ, negZ);
                            block = this._blocks[ressourceID];
                            block.data = asset; // Store finished asset

                            // Reset name of texture to the one defined in the AWD file,
                            // as opposed to whatever the image parser came up with.
                            asset.resetAssetPath(block.name, null, true);
                            block.name = asset.name;

                            // Finalize texture asset to dispatch texture event, which was
                            // previously suppressed while the dependency was loaded.
                            this._pFinalizeAsset(asset);
                            if (this._debug) {
                                console.log("Parsed CubeTexture: Name = " + block.name);
                            }
                        }
                    }
                }
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                //not used - if a dependcy fails, the awaiting Texture or CubeTexture will never be finalized, and the default-bitmaps will be used.
                // this means, that if one Bitmap of a CubeTexture fails, the CubeTexture will have the DefaultTexture applied for all six Bitmaps.
            };

            /**
            * Resolve a dependency name
            *
            * @param resourceDependency The dependency to be resolved.
            */
            AWDParser.prototype._iResolveDependencyName = function (resourceDependency, asset) {
                var oldName = asset.name;

                if (asset) {
                    var block = this._blocks[parseInt(resourceDependency.id)];

                    // Reset name of texture to the one defined in the AWD file,
                    // as opposed to whatever the image parser came up with.
                    asset.resetAssetPath(block.name, null, true);
                }

                var newName = asset.name;

                asset.name = oldName;

                return newName;
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._pProceedParsing = function () {
                if (!this._startedParsing) {
                    this._byteData = this._pGetByteData(); //getByteData();
                    this._startedParsing = true;
                }

                if (!this._parsed_header) {
                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._byteData.endian = Endian.LITTLE_ENDIAN;
                    //----------------------------------------------------------------------------
                    //----------------------------------------------------------------------------
                    // Parse header and decompress body if needed
                    this.parseHeader();

                    switch (this._compression) {
                        case AWDParser.DEFLATE:
                        case AWDParser.LZMA:
                            this._pDieWithError('Compressed AWD formats not yet supported');
                            break;

                        case AWDParser.UNCOMPRESSED:
                            this._body = this._byteData;
                            break;
                    }

                    this._parsed_header = true;
                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._body.endian = Endian.LITTLE_ENDIAN;// Should be default
                    //----------------------------------------------------------------------------
                }

                if (this._body) {
                    while (this._body.getBytesAvailable() > 0 && !this.parsingPaused) {
                        this.parseNextBlock();
                    }

                    //----------------------------------------------------------------------------
                    // Return complete status
                    if (this._body.getBytesAvailable() == 0) {
                        this.dispose();
                        return away.parsers.ParserBase.PARSING_DONE;
                    } else {
                        return away.parsers.ParserBase.MORE_TO_PARSE;
                    }
                } else {
                    switch (this._compression) {
                        case AWDParser.DEFLATE:
                        case AWDParser.LZMA:
                            if (this._debug) {
                                console.log("(!) AWDParser Error: Compressed AWD formats not yet supported (!)");
                            }

                            break;
                    }

                    // Error - most likely _body not set because we do not support compression.
                    return away.parsers.ParserBase.PARSING_DONE;
                }
            };

            AWDParser.prototype._pStartParsing = function (frameLimit) {
                _super.prototype._pStartParsing.call(this, frameLimit);

                //create a content object for Loaders
                this._pContent = new away.containers.DisplayObjectContainer();
            };

            AWDParser.prototype.dispose = function () {
                for (var c in this._blocks) {
                    var b = this._blocks[c];
                    b.dispose();
                }
            };

            AWDParser.prototype.parseNextBlock = function () {
                var block;
                var assetData;
                var isParsed = false;
                var ns;
                var type;
                var flags;
                var len;

                this._cur_block_id = this._body.readUnsignedInt();

                ns = this._body.readUnsignedByte();
                type = this._body.readUnsignedByte();
                flags = this._body.readUnsignedByte();
                len = this._body.readUnsignedInt();

                var blockCompression = bitFlags.test(flags, bitFlags.FLAG4);
                var blockCompressionLZMA = bitFlags.test(flags, bitFlags.FLAG5);

                if (this._accuracyOnBlocks) {
                    this._accuracyMatrix = bitFlags.test(flags, bitFlags.FLAG1);
                    this._accuracyGeo = bitFlags.test(flags, bitFlags.FLAG2);
                    this._accuracyProps = bitFlags.test(flags, bitFlags.FLAG3);
                    this._geoNrType = AWDParser.FLOAT32;

                    if (this._accuracyGeo) {
                        this._geoNrType = AWDParser.FLOAT64;
                    }

                    this._matrixNrType = AWDParser.FLOAT32;

                    if (this._accuracyMatrix) {
                        this._matrixNrType = AWDParser.FLOAT64;
                    }

                    this._propsNrType = AWDParser.FLOAT32;

                    if (this._accuracyProps) {
                        this._propsNrType = AWDParser.FLOAT64;
                    }
                }

                var blockEndAll = this._body.position + len;

                if (len > this._body.getBytesAvailable()) {
                    this._pDieWithError('AWD2 block length is bigger than the bytes that are available!');
                    this._body.position += this._body.getBytesAvailable();
                    return;
                }
                this._newBlockBytes = new away.utils.ByteArray();

                this._body.readBytes(this._newBlockBytes, 0, len);

                //----------------------------------------------------------------------------
                // Compressed AWD Formats not yet supported
                if (blockCompression) {
                    this._pDieWithError('Compressed AWD formats not yet supported');
                    /*
                    if (blockCompressionLZMA)
                    {
                    this._newBlockBytes.uncompress(AWDParser.COMPRESSIONMODE_LZMA);
                    }
                    else
                    {
                    this._newBlockBytes.uncompress();
                    }
                    */
                }

                //----------------------------------------------------------------------------
                // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                //----------------------------------------------------------------------------
                //this._newBlockBytes.endian = Endian.LITTLE_ENDIAN;
                //----------------------------------------------------------------------------
                this._newBlockBytes.position = 0;
                block = new AWDBlock();
                block.len = this._newBlockBytes.position + len;
                block.id = this._cur_block_id;

                var blockEndBlock = this._newBlockBytes.position + len;

                if (blockCompression) {
                    this._pDieWithError('Compressed AWD formats not yet supported');
                    //blockEndBlock   = this._newBlockBytes.position + this._newBlockBytes.length;
                    //block.len       = blockEndBlock;
                }

                if (this._debug) {
                    console.log("AWDBlock:  ID = " + this._cur_block_id + " | TypeID = " + type + " | Compression = " + blockCompression + " | Matrix-Precision = " + this._accuracyMatrix + " | Geometry-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
                }

                this._blocks[this._cur_block_id] = block;

                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    switch (type) {
                        case 11:
                            this.parsePrimitves(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 31:
                            this.parseSkyboxInstance(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 41:
                            this.parseLight(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 42:
                            this.parseCamera(this._cur_block_id);
                            isParsed = true;
                            break;

                        case 51:
                            this.parseLightPicker(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 81:
                            this.parseMaterial_v1(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 83:
                            this.parseCubeTexture(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 91:
                            this.parseSharedMethodBlock(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 92:
                            this.parseShadowMethodBlock(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 111:
                            this.parseMeshPoseAnimation(this._cur_block_id, true);
                            isParsed = true;
                            break;
                        case 112:
                            this.parseMeshPoseAnimation(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 113:
                            this.parseVertexAnimationSet(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 122:
                            this.parseAnimatorSet(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 253:
                            this.parseCommand(this._cur_block_id);
                            isParsed = true;
                            break;
                    }
                    //*/
                }

                //*
                if (isParsed == false) {
                    switch (type) {
                        case 1:
                            this.parseTriangleGeometrieBlock(this._cur_block_id);
                            break;
                        case 22:
                            this.parseContainer(this._cur_block_id);
                            break;
                        case 23:
                            this.parseMeshInstance(this._cur_block_id);
                            break;
                        case 81:
                            this.parseMaterial(this._cur_block_id);
                            break;
                        case 82:
                            this.parseTexture(this._cur_block_id);
                            break;
                        case 101:
                            this.parseSkeleton(this._cur_block_id);
                            break;
                        case 102:
                            this.parseSkeletonPose(this._cur_block_id);
                            break;
                        case 103:
                            this.parseSkeletonAnimation(this._cur_block_id);
                            break;
                        case 121:

                        case 254:
                            this.parseNameSpace(this._cur_block_id);
                            break;
                        case 255:
                            this.parseMetaData(this._cur_block_id);
                            break;
                        default:
                            if (this._debug) {
                                console.log("AWDBlock:   Unknown BlockType  (BlockID = " + this._cur_block_id + ") - Skip " + len + " bytes");
                            }
                            this._newBlockBytes.position += len;
                            break;
                    }
                }

                //*/
                var msgCnt = 0;
                if (this._newBlockBytes.position == blockEndBlock) {
                    if (this._debug) {
                        if (block.errorMessages) {
                            while (msgCnt < block.errorMessages.length) {
                                console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
                                msgCnt++;
                            }
                        }
                    }
                    if (this._debug) {
                        console.log("\n");
                    }
                } else {
                    if (this._debug) {
                        console.log("  (!)(!)(!) Error while reading AWDBlock ID " + this._cur_block_id + " = skip to next block");

                        if (block.errorMessages) {
                            while (msgCnt < block.errorMessages.length) {
                                console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
                                msgCnt++;
                            }
                        }
                    }
                }

                this._body.position = blockEndAll;
                this._newBlockBytes = null;
            };

            //--Parser Blocks---------------------------------------------------------------------------
            //Block ID = 1
            AWDParser.prototype.parseTriangleGeometrieBlock = function (blockID) {
                var geom = new away.base.Geometry();

                // Read name and sub count
                var name = this.parseVarStr();
                var num_subs = this._newBlockBytes.readUnsignedShort();

                // Read optional properties
                var props = this.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });
                var geoScaleU = props.get(1, 1);
                var geoScaleV = props.get(2, 1);

                // Loop through sub meshes
                var subs_parsed = 0;
                while (subs_parsed < num_subs) {
                    var i;
                    var sm_len, sm_end;
                    var sub_geom;
                    var w_indices;
                    var weights;

                    sm_len = this._newBlockBytes.readUnsignedInt();
                    sm_end = this._newBlockBytes.position + sm_len;

                    // Ignore for now
                    var subProps = this.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });

                    while (this._newBlockBytes.position < sm_end) {
                        var idx = 0;
                        var str_ftype, str_type, str_len, str_end;

                        // Type, field type, length
                        str_type = this._newBlockBytes.readUnsignedByte();
                        str_ftype = this._newBlockBytes.readUnsignedByte();
                        str_len = this._newBlockBytes.readUnsignedInt();
                        str_end = this._newBlockBytes.position + str_len;

                        var x, y, z;

                        if (str_type == 1) {
                            var verts = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                // TODO: Respect stream field type
                                x = this.readNumber(this._accuracyGeo);
                                y = this.readNumber(this._accuracyGeo);
                                z = this.readNumber(this._accuracyGeo);

                                verts[idx++] = x;
                                verts[idx++] = y;
                                verts[idx++] = z;
                            }
                        } else if (str_type == 2) {
                            var indices = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                // TODO: Respect stream field type
                                indices[idx++] = this._newBlockBytes.readUnsignedShort();
                            }
                        } else if (str_type == 3) {
                            var uvs = new Array();
                            while (this._newBlockBytes.position < str_end) {
                                uvs[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else if (str_type == 4) {
                            var normals = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                normals[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else if (str_type == 6) {
                            w_indices = Array();

                            while (this._newBlockBytes.position < str_end) {
                                w_indices[idx++] = this._newBlockBytes.readUnsignedShort() * 3; // TODO: Respect stream field type
                            }
                        } else if (str_type == 7) {
                            weights = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                weights[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else {
                            this._newBlockBytes.position = str_end;
                        }
                    }

                    this.parseUserAttributes(); // Ignore sub-mesh attributes for now

                    sub_geom = new TriangleSubGeometry(true);
                    if (weights)
                        sub_geom.jointsPerVertex = weights.length / (verts.length / 3);
                    if (normals)
                        sub_geom.autoDeriveNormals = false;
                    if (uvs)
                        sub_geom.autoDeriveUVs = false;
                    sub_geom.updateIndices(indices);
                    sub_geom.updatePositions(verts);
                    sub_geom.updateVertexNormals(normals);
                    sub_geom.updateUVs(uvs);
                    sub_geom.updateVertexTangents(null);
                    sub_geom.updateJointWeights(weights);
                    sub_geom.updateJointIndices(w_indices);

                    var scaleU = subProps.get(1, 1);
                    var scaleV = subProps.get(2, 1);
                    var setSubUVs = false;

                    if ((geoScaleU != scaleU) || (geoScaleV != scaleV)) {
                        setSubUVs = true;
                        scaleU = geoScaleU / scaleU;
                        scaleV = geoScaleV / scaleV;
                    }

                    if (setSubUVs)
                        sub_geom.scaleUV(scaleU, scaleV);

                    geom.addSubGeometry(sub_geom);

                    // TODO: Somehow map in-sub to out-sub indices to enable look-up
                    // when creating meshes (and their material assignments.)
                    subs_parsed++;
                }
                if ((geoScaleU != 1) || (geoScaleV != 1))
                    geom.scaleUV(geoScaleU, geoScaleV);
                this.parseUserAttributes();
                this._pFinalizeAsset(geom, name);
                this._blocks[blockID].data = geom;

                if (this._debug) {
                    console.log("Parsed a TriangleGeometry: Name = " + name + "| Id = " + sub_geom.id);
                }
            };

            //Block ID = 11
            AWDParser.prototype.parsePrimitves = function (blockID) {
                var name;
                var prefab;
                var primType;
                var subs_parsed;
                var props;
                var bsm;

                // Read name and sub count
                name = this.parseVarStr();
                primType = this._newBlockBytes.readUnsignedByte();
                props = this.parseProperties({ 101: this._geoNrType, 102: this._geoNrType, 103: this._geoNrType, 110: this._geoNrType, 111: this._geoNrType, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 303: AWDParser.UINT16, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 703: AWDParser.BOOL, 704: AWDParser.BOOL });

                var primitiveTypes = ["Unsupported Type-ID", "PrimitivePlanePrefab", "PrimitiveCubePrefab", "PrimitiveSpherePrefab", "PrimitiveCylinderPrefab", "PrimitivesConePrefab", "PrimitivesCapsulePrefab", "PrimitivesTorusPrefab"];

                switch (primType) {
                    case 1:
                        prefab = new away.prefabs.PrimitivePlanePrefab(props.get(101, 100), props.get(102, 100), props.get(301, 1), props.get(302, 1), props.get(701, true), props.get(702, false));
                        break;

                    case 2:
                        prefab = new away.prefabs.PrimitiveCubePrefab(props.get(101, 100), props.get(102, 100), props.get(103, 100), props.get(301, 1), props.get(302, 1), props.get(303, 1), props.get(701, true));
                        break;

                    case 3:
                        prefab = new away.prefabs.PrimitiveSpherePrefab(props.get(101, 50), props.get(301, 16), props.get(302, 12), props.get(701, true));
                        break;

                    case 4:
                        prefab = new away.prefabs.PrimitiveCylinderPrefab(props.get(101, 50), props.get(102, 50), props.get(103, 100), props.get(301, 16), props.get(302, 1), true, true, true); // bool701, bool702, bool703, bool704);
                        if (!props.get(701, true))
                            prefab.topClosed = false;
                        if (!props.get(702, true))
                            prefab.bottomClosed = false;
                        if (!props.get(703, true))
                            prefab.yUp = false;

                        break;

                    case 5:
                        prefab = new away.prefabs.PrimitiveConePrefab(props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 1), props.get(701, true), props.get(702, true));
                        break;

                    case 6:
                        prefab = new away.prefabs.PrimitiveCapsulePrefab(props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 15), props.get(701, true));
                        break;

                    case 7:
                        prefab = new away.prefabs.PrimitiveTorusPrefab(props.get(101, 50), props.get(102, 50), props.get(301, 16), props.get(302, 8), props.get(701, true));
                        break;

                    default:
                        prefab = new away.prefabs.PrefabBase();
                        console.log("ERROR: UNSUPPORTED PREFAB_TYPE");
                        break;
                }

                if ((props.get(110, 1) != 1) || (props.get(111, 1) != 1)) {
                    //geom.subGeometries;
                    //geom.scaleUV(props.get(110, 1), props.get(111, 1)); //TODO add back scaling to prefabs
                }

                this.parseUserAttributes();
                prefab.name = name;
                this._pFinalizeAsset(prefab, name);
                this._blocks[blockID].data = prefab;

                if (this._debug) {
                    if ((primType < 0) || (primType > 7)) {
                        primType = 0;
                    }
                    console.log("Parsed a Primivite: Name = " + name + "| type = " + primitiveTypes[primType]);
                }
            };

            // Block ID = 22
            AWDParser.prototype.parseContainer = function (blockID) {
                var name;
                var par_id;
                var mtx;
                var ctr;
                var parent;

                par_id = this._newBlockBytes.readUnsignedInt();
                mtx = this.parseMatrix3D();
                name = this.parseVarStr();

                var parentName = "Root (TopLevel)";
                ctr = new away.containers.DisplayObjectContainer();
                ctr.transform.matrix3D = mtx;

                var returnedArray = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH]);

                if (returnedArray[0]) {
                    var obj = returnedArray[1].addChild(ctr);
                    parentName = returnedArray[1].name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this ObjectContainer3D");
                } else {
                    //add to the content property
                    this._pContent.addChild(ctr);
                }

                // in AWD version 2.1 we read the Container properties
                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    var props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });
                    ctr.pivot = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                } else {
                    this.parseProperties(null);
                }

                // the extraProperties should only be set for AWD2.1-Files, but is read for both versions
                ctr.extra = this.parseUserAttributes();

                this._pFinalizeAsset(ctr, name);
                this._blocks[blockID].data = ctr;

                if (this._debug) {
                    console.log("Parsed a Container: Name = '" + name + "' | Parent-Name = " + parentName);
                }
            };

            // Block ID = 23
            AWDParser.prototype.parseMeshInstance = function (blockID) {
                var num_materials;
                var materials_parsed;
                var parent;
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var parentName = "Root (TopLevel)";
                var data_id = this._newBlockBytes.readUnsignedInt();
                var geom;
                var returnedArrayGeometry = this.getAssetByID(data_id, [AssetType.GEOMETRY]);

                if (returnedArrayGeometry[0]) {
                    geom = returnedArrayGeometry[1];
                } else {
                    this._blocks[blockID].addError("Could not find a Geometry for this Mesh. A empty Geometry is created!");
                    geom = new away.base.Geometry();
                }

                this._blocks[blockID].geoID = data_id;
                var materials = new Array();
                num_materials = this._newBlockBytes.readUnsignedShort();

                var materialNames = new Array();
                materials_parsed = 0;

                var returnedArrayMaterial;

                while (materials_parsed < num_materials) {
                    var mat_id;
                    mat_id = this._newBlockBytes.readUnsignedInt();
                    returnedArrayMaterial = this.getAssetByID(mat_id, [AssetType.MATERIAL]);
                    if ((!returnedArrayMaterial[0]) && (mat_id > 0)) {
                        this._blocks[blockID].addError("Could not find Material Nr " + materials_parsed + " (ID = " + mat_id + " ) for this Mesh");
                    }

                    var m = returnedArrayMaterial[1];

                    materials.push(m);
                    materialNames.push(m.name);

                    materials_parsed++;
                }

                var mesh = new Mesh(geom, null);
                mesh.transform.matrix3D = mtx;

                var returnedArrayParent = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH]);

                if (returnedArrayParent[0]) {
                    var objC = returnedArrayParent[1];
                    objC.addChild(mesh);
                    parentName = objC.name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this Mesh");
                } else {
                    //add to the content property
                    this._pContent.addChild(mesh);
                }

                if (materials.length >= 1 && mesh.subMeshes.length == 1) {
                    mesh.material = materials[0];
                } else if (materials.length > 1) {
                    var i;

                    for (i = 0; i < mesh.subMeshes.length; i++) {
                        mesh.subMeshes[i].material = materials[Math.min(materials.length - 1, i)];
                    }
                }
                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    var props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8, 5: AWDParser.BOOL });
                    mesh.pivot = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                    mesh.castsShadows = props.get(5, true);
                } else {
                    this.parseProperties(null);
                }

                mesh.extra = this.parseUserAttributes();

                this._pFinalizeAsset(mesh, name);
                this._blocks[blockID].data = mesh;

                if (this._debug) {
                    console.log("Parsed a Mesh: Name = '" + name + "' | Parent-Name = " + parentName + "| Geometry-Name = " + geom.name + " | SubMeshes = " + mesh.subMeshes.length + " | Mat-Names = " + materialNames.toString());
                }
            };

            //Block ID 31
            AWDParser.prototype.parseSkyboxInstance = function (blockID) {
                var name = this.parseVarStr();
                var cubeTexAddr = this._newBlockBytes.readUnsignedInt();

                var returnedArrayCubeTex = this.getAssetByID(cubeTexAddr, [AssetType.TEXTURE], "CubeTexture");
                if ((!returnedArrayCubeTex[0]) && (cubeTexAddr != 0))
                    this._blocks[blockID].addError("Could not find the Cubetexture (ID = " + cubeTexAddr + " ) for this Skybox");
                var asset = new away.entities.Skybox(new SkyboxMaterial(returnedArrayCubeTex[1]));

                this.parseProperties(null);
                asset.extra = this.parseUserAttributes();
                this._pFinalizeAsset(asset, name);
                this._blocks[blockID].data = asset;
                if (this._debug)
                    console.log("Parsed a Skybox: Name = '" + name + "' | CubeTexture-Name = " + returnedArrayCubeTex[1].name);
            };

            //Block ID = 41
            AWDParser.prototype.parseLight = function (blockID) {
                var light;
                var newShadowMapper;

                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var lightType = this._newBlockBytes.readUnsignedByte();
                var props = this.parseProperties({ 1: this._propsNrType, 2: this._propsNrType, 3: AWDParser.COLOR, 4: this._propsNrType, 5: this._propsNrType, 6: AWDParser.BOOL, 7: AWDParser.COLOR, 8: this._propsNrType, 9: AWDParser.UINT8, 10: AWDParser.UINT8, 11: this._propsNrType, 12: AWDParser.UINT16, 21: this._matrixNrType, 22: this._matrixNrType, 23: this._matrixNrType });
                var shadowMapperType = props.get(9, 0);
                var parentName = "Root (TopLevel)";
                var lightTypes = ["Unsupported LightType", "PointLight", "DirectionalLight"];
                var shadowMapperTypes = ["No ShadowMapper", "DirectionalShadowMapper", "NearDirectionalShadowMapper", "CascadeShadowMapper", "CubeMapShadowMapper"];

                if (lightType == 1) {
                    light = new away.lights.PointLight();

                    light.radius = props.get(1, 90000);
                    light.fallOff = props.get(2, 100000);

                    if (shadowMapperType > 0) {
                        if (shadowMapperType == 4) {
                            newShadowMapper = new away.lights.CubeMapShadowMapper();
                        }
                    }

                    light.transform.matrix3D = mtx;
                }

                if (lightType == 2) {
                    light = new away.lights.DirectionalLight(props.get(21, 0), props.get(22, -1), props.get(23, 1));

                    if (shadowMapperType > 0) {
                        if (shadowMapperType == 1) {
                            newShadowMapper = new away.lights.DirectionalShadowMapper();
                        }
                        //if (shadowMapperType == 2)
                        //  newShadowMapper = new NearDirectionalShadowMapper(props.get(11, 0.5));
                        //if (shadowMapperType == 3)
                        //   newShadowMapper = new CascadeShadowMapper(props.get(12, 3));
                    }
                }
                light.color = props.get(3, 0xffffff);
                light.specular = props.get(4, 1.0);
                light.diffuse = props.get(5, 1.0);
                light.ambientColor = props.get(7, 0xffffff);
                light.ambient = props.get(8, 0.0);

                // if a shadowMapper has been created, adjust the depthMapSize if needed, assign to light and set castShadows to true
                if (newShadowMapper) {
                    if (newShadowMapper instanceof away.lights.CubeMapShadowMapper) {
                        if (props.get(10, 1) != 1) {
                            newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 1)];
                        }
                    } else {
                        if (props.get(10, 2) != 2) {
                            newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 2)];
                        }
                    }

                    light.shadowMapper = newShadowMapper;
                    light.castsShadows = true;
                }

                if (par_id != 0) {
                    var returnedArrayParent = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH]);

                    if (returnedArrayParent[0]) {
                        returnedArrayParent[1].addChild(light);
                        parentName = returnedArrayParent[1].name;
                    } else {
                        this._blocks[blockID].addError("Could not find a parent for this Light");
                    }
                } else {
                    //add to the content property
                    this._pContent.addChild(light);
                }

                this.parseUserAttributes();

                this._pFinalizeAsset(light, name);

                this._blocks[blockID].data = light;

                if (this._debug)
                    console.log("Parsed a Light: Name = '" + name + "' | Type = " + lightTypes[lightType] + " | Parent-Name = " + parentName + " | ShadowMapper-Type = " + shadowMapperTypes[shadowMapperType]);
            };

            //Block ID = 43
            AWDParser.prototype.parseCamera = function (blockID) {
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var parentName = "Root (TopLevel)";
                var projection;

                this._newBlockBytes.readUnsignedByte(); //set as active camera
                this._newBlockBytes.readShort(); //lengthof lenses - not used yet

                var projectiontype = this._newBlockBytes.readShort();
                var props = this.parseProperties({ 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 104: this._propsNrType });

                switch (projectiontype) {
                    case 5001:
                        projection = new away.projections.PerspectiveProjection(props.get(101, 60));
                        break;
                    case 5002:
                        projection = new away.projections.OrthographicProjection(props.get(101, 500));
                        break;
                    case 5003:
                        projection = new away.projections.OrthographicOffCenterProjection(props.get(101, -400), props.get(102, 400), props.get(103, -300), props.get(104, 300));
                        break;
                    default:
                        console.log("unsupportedLenstype");
                        return;
                }

                var camera = new away.entities.Camera(projection);
                camera.transform.matrix3D = mtx;

                var returnedArrayParent = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH]);

                if (returnedArrayParent[0]) {
                    var objC = returnedArrayParent[1];
                    objC.addChild(camera);

                    parentName = objC.name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this Camera");
                } else {
                    //add to the content property
                    this._pContent.addChild(camera);
                }

                camera.name = name;
                props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });
                camera.pivot = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                camera.extra = this.parseUserAttributes();

                this._pFinalizeAsset(camera, name);

                this._blocks[blockID].data = camera;

                if (this._debug) {
                    console.log("Parsed a Camera: Name = '" + name + "' | Projectiontype = " + projection + " | Parent-Name = " + parentName);
                }
            };

            //Block ID = 51
            AWDParser.prototype.parseLightPicker = function (blockID) {
                var name = this.parseVarStr();
                var numLights = this._newBlockBytes.readUnsignedShort();
                var lightsArray = new Array();
                var k = 0;
                var lightID = 0;

                var returnedArrayLight;
                var lightsArrayNames = new Array();

                for (k = 0; k < numLights; k++) {
                    lightID = this._newBlockBytes.readUnsignedInt();
                    returnedArrayLight = this.getAssetByID(lightID, [AssetType.LIGHT]);

                    if (returnedArrayLight[0]) {
                        lightsArray.push(returnedArrayLight[1]);
                        lightsArrayNames.push(returnedArrayLight[1].name);
                    } else {
                        this._blocks[blockID].addError("Could not find a Light Nr " + k + " (ID = " + lightID + " ) for this LightPicker");
                    }
                }

                if (lightsArray.length == 0) {
                    this._blocks[blockID].addError("Could not create this LightPicker, cause no Light was found.");
                    this.parseUserAttributes();
                    return;
                }

                var lightPick = new away.materials.StaticLightPicker(lightsArray);
                lightPick.name = name;

                this.parseUserAttributes();
                this._pFinalizeAsset(lightPick, name);

                this._blocks[blockID].data = lightPick;
                if (this._debug) {
                    console.log("Parsed a StaticLightPicker: Name = '" + name + "' | Texture-Name = " + lightsArrayNames.toString());
                }
            };

            //Block ID = 81
            AWDParser.prototype.parseMaterial = function (blockID) {
                // TODO: not used
                ////blockLength = block.len;
                var name;
                var type;
                var props;
                var mat;
                var attributes;
                var finalize;
                var num_methods;
                var methods_parsed;
                var returnedArray;

                name = this.parseVarStr();
                type = this._newBlockBytes.readUnsignedByte();
                num_methods = this._newBlockBytes.readUnsignedByte();

                // Read material numerical properties
                // (1=color, 2=bitmap url, 10=alpha, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
                props = this.parseProperties({ 1: AWDParser.INT32, 2: AWDParser.BADDR, 10: this._propsNrType, 11: AWDParser.BOOL, 12: this._propsNrType, 13: AWDParser.BOOL });

                methods_parsed = 0;
                while (methods_parsed < num_methods) {
                    var method_type;

                    method_type = this._newBlockBytes.readUnsignedShort();
                    this.parseProperties(null);
                    this.parseUserAttributes();
                    methods_parsed += 1;
                }
                var debugString = "";
                attributes = this.parseUserAttributes();
                if (type === 1) {
                    debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
                    var color;
                    color = props.get(1, 0xcccccc);
                    if (this.materialMode < 2)
                        mat = new away.materials.ColorMaterial(color, props.get(10, 1.0));
                    else
                        mat = new away.materials.ColorMultiPassMaterial(color);
                } else if (type === 2) {
                    var tex_addr = props.get(2, 0);

                    returnedArray = this.getAssetByID(tex_addr, [AssetType.TEXTURE]);
                    if ((!returnedArray[0]) && (tex_addr > 0)) {
                        this._blocks[blockID].addError("Could not find the DiffsueTexture (ID = " + tex_addr + " ) for this Material");
                    }

                    if (this.materialMode < 2) {
                        mat = new TextureMaterial(returnedArray[1]);

                        var txMaterial = mat;

                        txMaterial.alphaBlending = props.get(11, false);
                        txMaterial.alpha = props.get(10, 1.0);
                        debugString += "Parsed a TextureMaterial(SinglePass): Name = '" + name + "' | Texture-Name = " + mat.name;
                    } else {
                        mat = new away.materials.TextureMultiPassMaterial(returnedArray[1]);
                        debugString += "Parsed a TextureMaterial(MultipAss): Name = '" + name + "' | Texture-Name = " + mat.name;
                    }
                }

                mat.extra = attributes;
                if (this.materialMode < 2) {
                    var spmb = mat;
                    spmb.alphaThreshold = props.get(12, 0.0);
                } else {
                    var mpmb = mat;
                    mpmb.alphaThreshold = props.get(12, 0.0);
                }

                mat.repeat = props.get(13, false);
                this._pFinalizeAsset(mat, name);
                this._blocks[blockID].data = mat;

                if (this._debug) {
                    console.log(debugString);
                }
            };

            // Block ID = 81 AWD2.1
            AWDParser.prototype.parseMaterial_v1 = function (blockID) {
                var mat;
                var normalTexture;
                var specTexture;
                var returnedArray;

                var name = this.parseVarStr();
                var type = this._newBlockBytes.readUnsignedByte();
                var num_methods = this._newBlockBytes.readUnsignedByte();
                var props = this.parseProperties({ 1: AWDParser.UINT32, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 4: AWDParser.UINT8, 5: AWDParser.BOOL, 6: AWDParser.BOOL, 7: AWDParser.BOOL, 8: AWDParser.BOOL, 9: AWDParser.UINT8, 10: this._propsNrType, 11: AWDParser.BOOL, 12: this._propsNrType, 13: AWDParser.BOOL, 15: this._propsNrType, 16: AWDParser.UINT32, 17: AWDParser.BADDR, 18: this._propsNrType, 19: this._propsNrType, 20: AWDParser.UINT32, 21: AWDParser.BADDR, 22: AWDParser.BADDR });
                var spezialType = props.get(4, 0);
                var debugString = "";

                if (spezialType >= 2) {
                    this._blocks[blockID].addError("Material-spezialType '" + spezialType + "' is not supported, can only be 0:singlePass, 1:MultiPass !");
                    return;
                }

                if (this.materialMode == 1) {
                    spezialType = 0;
                } else if (this.materialMode == 2) {
                    spezialType = 1;
                }

                if (spezialType < 2) {
                    if (type == 1) {
                        var color = props.get(1, 0xcccccc);

                        if (spezialType == 1) {
                            mat = new away.materials.ColorMultiPassMaterial(color);
                            debugString += "Parsed a ColorMaterial(MultiPass): Name = '" + name + "' | ";
                        } else {
                            mat = new away.materials.ColorMaterial(color, props.get(10, 1.0));
                            mat.alphaBlending = props.get(11, false);
                            debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
                        }
                    } else if (type == 2) {
                        var tex_addr = props.get(2, 0);
                        returnedArray = this.getAssetByID(tex_addr, [AssetType.TEXTURE]);

                        if ((!returnedArray[0]) && (tex_addr > 0)) {
                            this._blocks[blockID].addError("Could not find the DiffuseTexture (ID = " + tex_addr + " ) for this TextureMaterial");
                        }
                        var texture = returnedArray[1];
                        var ambientTexture;
                        var ambientTex_addr = props.get(17, 0);

                        returnedArray = this.getAssetByID(ambientTex_addr, [AssetType.TEXTURE]);

                        if ((!returnedArray[0]) && (ambientTex_addr != 0)) {
                            this._blocks[blockID].addError("Could not find the AmbientTexture (ID = " + ambientTex_addr + " ) for this TextureMaterial");
                        }

                        if (returnedArray[0]) {
                            ambientTexture = returnedArray[1];
                        }

                        if (spezialType == 1) {
                            mat = new away.materials.TextureMultiPassMaterial(texture);
                            debugString += "Parsed a TextureMaterial(MultiPass): Name = '" + name + "' | Texture-Name = " + texture.name;

                            if (ambientTexture) {
                                mat.ambientTexture = ambientTexture;
                                debugString += " | AmbientTexture-Name = " + ambientTexture.name;
                            }
                        } else {
                            mat = new TextureMaterial(texture);
                            debugString += "Parsed a TextureMaterial(SinglePass): Name = '" + name + "' | Texture-Name = " + texture.name;

                            if (ambientTexture) {
                                mat.ambientTexture = ambientTexture;
                                debugString += " | AmbientTexture-Name = " + ambientTexture.name;
                            }

                            mat.alpha = props.get(10, 1.0);
                            mat.alphaBlending = props.get(11, false);
                        }
                    }

                    var normalTex_addr = props.get(3, 0);

                    returnedArray = this.getAssetByID(normalTex_addr, [AssetType.TEXTURE]);

                    if ((!returnedArray[0]) && (normalTex_addr != 0)) {
                        this._blocks[blockID].addError("Could not find the NormalTexture (ID = " + normalTex_addr + " ) for this TextureMaterial");
                    }

                    if (returnedArray[0]) {
                        normalTexture = returnedArray[1];
                        debugString += " | NormalTexture-Name = " + normalTexture.name;
                    }

                    var specTex_addr = props.get(21, 0);
                    returnedArray = this.getAssetByID(specTex_addr, [AssetType.TEXTURE]);

                    if ((!returnedArray[0]) && (specTex_addr != 0)) {
                        this._blocks[blockID].addError("Could not find the SpecularTexture (ID = " + specTex_addr + " ) for this TextureMaterial");
                    }
                    if (returnedArray[0]) {
                        specTexture = returnedArray[1];
                        debugString += " | SpecularTexture-Name = " + specTexture.name;
                    }

                    var lightPickerAddr = props.get(22, 0);
                    returnedArray = this.getAssetByID(lightPickerAddr, [AssetType.LIGHT_PICKER]);

                    if ((!returnedArray[0]) && (lightPickerAddr)) {
                        this._blocks[blockID].addError("Could not find the LightPicker (ID = " + lightPickerAddr + " ) for this TextureMaterial");
                    } else {
                        mat.lightPicker = returnedArray[1];
                        //debugString+=" | Lightpicker-Name = "+LightPickerBase(returnedArray[1]).name;
                    }

                    mat.smooth = props.get(5, true);
                    mat.mipmap = props.get(6, true);
                    mat.bothSides = props.get(7, false);
                    mat.alphaPremultiplied = props.get(8, false);
                    mat.blendMode = this.blendModeDic[props.get(9, 0)];
                    mat.repeat = props.get(13, false);

                    if (spezialType == 0) {
                        if (normalTexture) {
                            mat.normalMap = normalTexture;
                        }
                        if (specTexture) {
                            mat.specularMap = specTexture;
                        }

                        mat.alphaThreshold = props.get(12, 0.0);
                        mat.ambient = props.get(15, 1.0);
                        mat.ambientColor = props.get(16, 0xffffff);
                        mat.specular = props.get(18, 1.0);
                        mat.gloss = props.get(19, 50);
                        mat.specularColor = props.get(20, 0xffffff);
                    } else {
                        if (normalTexture) {
                            mat.normalMap = normalTexture;
                        }
                        if (specTexture) {
                            mat.specularMap = specTexture;
                        }

                        mat.alphaThreshold = props.get(12, 0.0);
                        mat.ambient = props.get(15, 1.0);
                        mat.ambientColor = props.get(16, 0xffffff);
                        mat.specular = props.get(18, 1.0);
                        mat.gloss = props.get(19, 50);
                        mat.specularColor = props.get(20, 0xffffff);
                    }

                    var methods_parsed = 0;
                    var targetID;

                    while (methods_parsed < num_methods) {
                        var method_type;
                        method_type = this._newBlockBytes.readUnsignedShort();

                        props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 801: AWDParser.MTX4x4 });

                        switch (method_type) {
                            case 999:
                                targetID = props.get(1, 0);
                                returnedArray = this.getAssetByID(targetID, [AssetType.EFFECTS_METHOD]);

                                if (!returnedArray[0]) {
                                    this._blocks[blockID].addError("Could not find the EffectMethod (ID = " + targetID + " ) for this Material");
                                } else {
                                    if (spezialType == 0) {
                                        mat.addMethod(returnedArray[1]);
                                    }
                                    if (spezialType == 1) {
                                        mat.addMethod(returnedArray[1]);
                                    }

                                    debugString += " | EffectMethod-Name = " + returnedArray[1].name;
                                }

                                break;

                            case 998:
                                targetID = props.get(1, 0);
                                returnedArray = this.getAssetByID(targetID, [AssetType.SHADOW_MAP_METHOD]);

                                if (!returnedArray[0]) {
                                    this._blocks[blockID].addError("Could not find the ShadowMethod (ID = " + targetID + " ) for this Material");
                                } else {
                                    if (spezialType == 0) {
                                        mat.shadowMethod = returnedArray[1];
                                    }

                                    if (spezialType == 1) {
                                        mat.shadowMethod = returnedArray[1];
                                    }

                                    debugString += " | ShadowMethod-Name = " + returnedArray[1].name;
                                }

                                break;

                            case 102:
                                if (spezialType == 0)
                                    mat.specularMethod = new SpecularPhongMethod();
                                if (spezialType == 1)
                                    mat.specularMethod = new SpecularPhongMethod();
                                debugString += " | SpecularPhongMethod";
                                break;

                            case 104:
                                if (spezialType == 0) {
                                    mat.specularMethod = new SpecularFresnelMethod(props.get(701, true), mat.specularMethod);
                                    mat.specularMethod.fresnelPower = props.get(101, 5);
                                    mat.specularMethod.normalReflectance = props.get(102, 0.1);
                                }
                                if (spezialType == 1) {
                                    mat.specularMethod = new SpecularFresnelMethod(props.get(701, true), mat.specularMethod);
                                    mat.specularMethod.fresnelPower = props.get(101, 5);
                                    mat.specularMethod.normalReflectance = props.get(102, 0.1);
                                }
                                debugString += " | SpecularFresnelMethod";
                                break;
                        }
                        this.parseUserAttributes();
                        methods_parsed += 1;
                    }
                }
                mat.extra = this.parseUserAttributes();
                this._pFinalizeAsset(mat, name);

                this._blocks[blockID].data = mat;
                if (this._debug) {
                    console.log(debugString);
                }
            };

            //Block ID = 82
            AWDParser.prototype.parseTexture = function (blockID) {
                var asset;

                this._blocks[blockID].name = this.parseVarStr();

                var type = this._newBlockBytes.readUnsignedByte();
                var data_len;

                this._texture_users[this._cur_block_id.toString()] = [];

                // External
                if (type == 0) {
                    data_len = this._newBlockBytes.readUnsignedInt();
                    var url;
                    url = this._newBlockBytes.readUTFBytes(data_len);
                    this._pAddDependency(this._cur_block_id.toString(), new away.net.URLRequest(url), false, null, true);
                } else {
                    data_len = this._newBlockBytes.readUnsignedInt();

                    var data;
                    data = new away.utils.ByteArray();
                    this._newBlockBytes.readBytes(data, 0, data_len);

                    //
                    // AWDParser - Fix for FireFox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=715075 .
                    //
                    // Converting data to image here instead of parser - fix FireFox bug where image width / height is 0 when created from data
                    // This gives the browser time to initialise image width / height.
                    this._pAddDependency(this._cur_block_id.toString(), null, false, away.parsers.ParserUtils.byteArrayToImage(data), true);
                    //this._pAddDependency(this._cur_block_id.toString(), null, false, data, true);
                }

                // Ignore for now
                this.parseProperties(null);
                this._blocks[blockID].extras = this.parseUserAttributes();
                this._pPauseAndRetrieveDependencies();
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    var textureStylesNames = ["external", "embed"];
                    console.log("Start parsing a " + textureStylesNames[type] + " Bitmap for Texture");
                }
            };

            //Block ID = 83
            AWDParser.prototype.parseCubeTexture = function (blockID) {
                //blockLength = block.len;
                var data_len;
                var asset;
                var i;

                this._cubeTextures = new Array();
                this._texture_users[this._cur_block_id.toString()] = [];

                var type = this._newBlockBytes.readUnsignedByte();

                this._blocks[blockID].name = this.parseVarStr();

                for (i = 0; i < 6; i++) {
                    this._texture_users[this._cur_block_id.toString()] = [];
                    this._cubeTextures.push(null);

                    // External
                    if (type == 0) {
                        data_len = this._newBlockBytes.readUnsignedInt();
                        var url;
                        url = this._newBlockBytes.readUTFBytes(data_len);

                        this._pAddDependency(this._cur_block_id.toString() + "#" + i, new away.net.URLRequest(url), false, null, true);
                    } else {
                        data_len = this._newBlockBytes.readUnsignedInt();
                        var data;
                        data = new away.utils.ByteArray();

                        this._newBlockBytes.readBytes(data, 0, data_len);

                        this._pAddDependency(this._cur_block_id.toString() + "#" + i, null, false, away.parsers.ParserUtils.byteArrayToImage(data), true);
                    }
                }

                // Ignore for now
                this.parseProperties(null);
                this._blocks[blockID].extras = this.parseUserAttributes();
                this._pPauseAndRetrieveDependencies();
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    var textureStylesNames = ["external", "embed"];
                    console.log("Start parsing 6 " + textureStylesNames[type] + " Bitmaps for CubeTexture");
                }
            };

            //Block ID = 91
            AWDParser.prototype.parseSharedMethodBlock = function (blockID) {
                var asset;

                this._blocks[blockID].name = this.parseVarStr();
                asset = this.parseSharedMethodList(blockID);
                this.parseUserAttributes();
                this._blocks[blockID].data = asset;
                this._pFinalizeAsset(asset, this._blocks[blockID].name);
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    console.log("Parsed a EffectMethod: Name = " + asset.name + " Type = " + asset);
                }
            };

            //Block ID = 92
            AWDParser.prototype.parseShadowMethodBlock = function (blockID) {
                var type;
                var data_len;
                var asset;
                var shadowLightID;
                this._blocks[blockID].name = this.parseVarStr();

                shadowLightID = this._newBlockBytes.readUnsignedInt();
                var returnedArray = this.getAssetByID(shadowLightID, [AssetType.LIGHT]);

                if (!returnedArray[0]) {
                    this._blocks[blockID].addError("Could not find the TargetLight (ID = " + shadowLightID + " ) for this ShadowMethod - ShadowMethod not created");
                    return;
                }

                asset = this.parseShadowMethodList(returnedArray[1], blockID);

                if (!asset)
                    return;

                this.parseUserAttributes(); // Ignore for now
                this._pFinalizeAsset(asset, this._blocks[blockID].name);
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    console.log("Parsed a ShadowMapMethodMethod: Name = " + asset.name + " | Type = " + asset + " | Light-Name = ", returnedArray[1].name);
                }
            };

            //Block ID = 253
            AWDParser.prototype.parseCommand = function (blockID) {
                var hasBlocks = (this._newBlockBytes.readUnsignedByte() == 1);
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();

                var parentObject;
                var targetObject;

                var returnedArray = this.getAssetByID(par_id, [AssetType.CONTAINER, AssetType.LIGHT, AssetType.MESH]);

                if (returnedArray[0]) {
                    parentObject = returnedArray[1];
                }

                var numCommands = this._newBlockBytes.readShort();
                var typeCommand = this._newBlockBytes.readShort();

                var props = this.parseProperties({ 1: AWDParser.BADDR });

                switch (typeCommand) {
                    case 1:
                        var targetID = props.get(1, 0);
                        var returnedArrayTarget = this.getAssetByID(targetID, [AssetType.LIGHT, AssetType.TEXTURE_PROJECTOR]);

                        if ((!returnedArrayTarget[0]) && (targetID != 0)) {
                            this._blocks[blockID].addError("Could not find the light (ID = " + targetID + " ( for this CommandBock!");
                            return;
                        }

                        targetObject = returnedArrayTarget[1];

                        if (parentObject) {
                            parentObject.addChild(targetObject);
                        }

                        targetObject.transform.matrix3D = mtx;

                        break;
                }

                if (targetObject) {
                    props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });

                    targetObject.pivot = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                    targetObject.extra = this.parseUserAttributes();
                }
                this._blocks[blockID].data = targetObject;

                if (this._debug) {
                    console.log("Parsed a CommandBlock: Name = '" + name);
                }
            };

            //blockID 255
            AWDParser.prototype.parseMetaData = function (blockID) {
                var props = this.parseProperties({ 1: AWDParser.UINT32, 2: AWDParser.AWDSTRING, 3: AWDParser.AWDSTRING, 4: AWDParser.AWDSTRING, 5: AWDParser.AWDSTRING });

                if (this._debug) {
                    console.log("Parsed a MetaDataBlock: TimeStamp         = " + props.get(1, 0));
                    console.log("                        EncoderName       = " + props.get(2, "unknown"));
                    console.log("                        EncoderVersion    = " + props.get(3, "unknown"));
                    console.log("                        GeneratorName     = " + props.get(4, "unknown"));
                    console.log("                        GeneratorVersion  = " + props.get(5, "unknown"));
                }
            };

            //blockID 254
            AWDParser.prototype.parseNameSpace = function (blockID) {
                var id = this._newBlockBytes.readUnsignedByte();
                var nameSpaceString = this.parseVarStr();
                if (this._debug)
                    console.log("Parsed a NameSpaceBlock: ID = " + id + " | String = " + nameSpaceString);
            };

            //--Parser UTILS---------------------------------------------------------------------------
            // this functions reads and creates a ShadowMethodMethod
            AWDParser.prototype.parseShadowMethodList = function (light, blockID) {
                var methodType = this._newBlockBytes.readUnsignedShort();
                var shadowMethod;
                var props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 801: AWDParser.MTX4x4 });

                var targetID;
                var returnedArray;
                switch (methodType) {
                    case 1002:
                        targetID = props.get(1, 0);
                        returnedArray = this.getAssetByID(targetID, [AssetType.SHADOW_MAP_METHOD]);
                        if (!returnedArray[0]) {
                            this._blocks[blockID].addError("Could not find the ShadowBaseMethod (ID = " + targetID + " ) for this ShadowNearMethod - ShadowMethod not created");
                            return shadowMethod;
                        }
                        shadowMethod = new ShadowNearMethod(returnedArray[1]);
                        break;
                    case 1101:
                        shadowMethod = new ShadowFilteredMethod(light);
                        shadowMethod.alpha = props.get(101, 1);
                        shadowMethod.epsilon = props.get(102, 0.002);
                        break;

                    case 1102:
                        shadowMethod = new ShadowDitheredMethod(light, props.get(201, 5));
                        shadowMethod.alpha = props.get(101, 1);
                        shadowMethod.epsilon = props.get(102, 0.002);
                        shadowMethod.range = props.get(103, 1);

                        break;
                    case 1103:
                        shadowMethod = new ShadowSoftMethod(light, props.get(201, 5));
                        shadowMethod.alpha = props.get(101, 1);
                        shadowMethod.epsilon = props.get(102, 0.002);
                        shadowMethod.range = props.get(103, 1);

                        break;
                    case 1104:
                        shadowMethod = new ShadowHardMethod(light);
                        shadowMethod.alpha = props.get(101, 1);
                        shadowMethod.epsilon = props.get(102, 0.002);
                        break;
                }
                this.parseUserAttributes();
                return shadowMethod;
            };

            //Block ID 101
            AWDParser.prototype.parseSkeleton = function (blockID /*uint*/ ) {
                var name = this.parseVarStr();
                var num_joints = this._newBlockBytes.readUnsignedShort();
                var skeleton = new Skeleton();
                this.parseProperties(null); // Discard properties for now

                var joints_parsed = 0;
                while (joints_parsed < num_joints) {
                    var joint;
                    var ibp;

                    // Ignore joint id
                    this._newBlockBytes.readUnsignedShort();
                    joint = new SkeletonJoint();
                    joint.parentIndex = this._newBlockBytes.readUnsignedShort() - 1; // 0=null in AWD
                    joint.name = this.parseVarStr();

                    ibp = this.parseMatrix3D();
                    joint.inverseBindPose = ibp.rawData;

                    // Ignore joint props/attributes for now
                    this.parseProperties(null);
                    this.parseUserAttributes();
                    skeleton.joints.push(joint);
                    joints_parsed++;
                }

                // Discard attributes for now
                this.parseUserAttributes();
                this._pFinalizeAsset(skeleton, name);
                this._blocks[blockID].data = skeleton;
                if (this._debug)
                    console.log("Parsed a Skeleton: Name = " + skeleton.name + " | Number of Joints = " + joints_parsed);
            };

            //Block ID = 102
            AWDParser.prototype.parseSkeletonPose = function (blockID /*uint*/ ) {
                var name = this.parseVarStr();
                var num_joints = this._newBlockBytes.readUnsignedShort();
                this.parseProperties(null); // Ignore properties for now

                var pose = new SkeletonPose();

                var joints_parsed = 0;
                while (joints_parsed < num_joints) {
                    var joint_pose;
                    var has_transform;
                    joint_pose = new JointPose();
                    has_transform = this._newBlockBytes.readUnsignedByte();
                    if (has_transform == 1) {
                        var mtx_data = this.parseMatrix43RawData();

                        var mtx = new Matrix3D(mtx_data);
                        joint_pose.orientation.fromMatrix(mtx);
                        joint_pose.translation.copyFrom(mtx.position);

                        pose.jointPoses[joints_parsed] = joint_pose;
                    }
                    joints_parsed++;
                }

                // Skip attributes for now
                this.parseUserAttributes();
                this._pFinalizeAsset(pose, name);
                this._blocks[blockID].data = pose;
                if (this._debug)
                    console.log("Parsed a SkeletonPose: Name = " + pose.name + " | Number of Joints = " + joints_parsed);
            };

            //blockID 103
            AWDParser.prototype.parseSkeletonAnimation = function (blockID /*uint*/ ) {
                var frame_dur;
                var pose_addr;
                var name = this.parseVarStr();
                var clip = new SkeletonClipNode();
                var num_frames = this._newBlockBytes.readUnsignedShort();
                this.parseProperties(null); // Ignore properties for now

                var frames_parsed = 0;
                var returnedArray;
                while (frames_parsed < num_frames) {
                    pose_addr = this._newBlockBytes.readUnsignedInt();
                    frame_dur = this._newBlockBytes.readUnsignedShort();
                    returnedArray = this.getAssetByID(pose_addr, [AssetType.SKELETON_POSE]);
                    if (!returnedArray[0])
                        this._blocks[blockID].addError("Could not find the SkeletonPose Frame # " + frames_parsed + " (ID = " + pose_addr + " ) for this SkeletonClipNode");
                    else
                        clip.addFrame(this._blocks[pose_addr].data, frame_dur);
                    frames_parsed++;
                }
                if (clip.frames.length == 0) {
                    this._blocks[blockID].addError("Could not this SkeletonClipNode, because no Frames where set.");
                    return;
                }

                // Ignore attributes for now
                this.parseUserAttributes();
                this._pFinalizeAsset(clip, name);
                this._blocks[blockID].data = clip;
                if (this._debug)
                    console.log("Parsed a SkeletonClipNode: Name = " + clip.name + " | Number of Frames = " + clip.frames.length);
            };

            //Block ID = 111 /  Block ID = 112
            AWDParser.prototype.parseMeshPoseAnimation = function (blockID /*uint*/ , poseOnly) {
                if (typeof poseOnly === "undefined") { poseOnly = false; }
                var num_frames = 1;
                var num_submeshes;
                var frames_parsed;
                var subMeshParsed;
                var frame_dur;
                var x;
                var y;
                var z;
                var str_len;
                var str_end;
                var geometry;
                var subGeom;
                var idx = 0;
                var clip = new VertexClipNode();
                var indices;
                var verts;
                var num_Streams = 0;
                var streamsParsed = 0;
                var streamtypes = new Array();
                var props;
                var thisGeo;
                var name = this.parseVarStr();
                var geoAdress = this._newBlockBytes.readUnsignedInt();
                var returnedArray = this.getAssetByID(geoAdress, [AssetType.GEOMETRY]);
                if (!returnedArray[0]) {
                    this._blocks[blockID].addError("Could not find the target-Geometry-Object " + geoAdress + " ) for this VertexClipNode");
                    return;
                }
                var uvs = this.getUVForVertexAnimation(geoAdress);
                if (!poseOnly)
                    num_frames = this._newBlockBytes.readUnsignedShort();

                num_submeshes = this._newBlockBytes.readUnsignedShort();
                num_Streams = this._newBlockBytes.readUnsignedShort();
                streamsParsed = 0;
                while (streamsParsed < num_Streams) {
                    streamtypes.push(this._newBlockBytes.readUnsignedShort());
                    streamsParsed++;
                }
                props = this.parseProperties({ 1: AWDParser.BOOL, 2: AWDParser.BOOL });

                clip.looping = props.get(1, true);
                clip.stitchFinalFrame = props.get(2, false);

                frames_parsed = 0;
                while (frames_parsed < num_frames) {
                    frame_dur = this._newBlockBytes.readUnsignedShort();
                    geometry = new Geometry();
                    subMeshParsed = 0;
                    while (subMeshParsed < num_submeshes) {
                        streamsParsed = 0;
                        str_len = this._newBlockBytes.readUnsignedInt();
                        str_end = this._newBlockBytes.position + str_len;
                        while (streamsParsed < num_Streams) {
                            if (streamtypes[streamsParsed] == 1) {
                                indices = returnedArray[1].subGeometries[subMeshParsed].indices;
                                verts = new Array();
                                idx = 0;
                                while (this._newBlockBytes.position < str_end) {
                                    x = this.readNumber(this._accuracyGeo);
                                    y = this.readNumber(this._accuracyGeo);
                                    z = this.readNumber(this._accuracyGeo);
                                    verts[idx++] = x;
                                    verts[idx++] = y;
                                    verts[idx++] = z;
                                }
                                subGeom = new TriangleSubGeometry(true);
                                subGeom.updateIndices(indices);
                                subGeom.updatePositions(verts);
                                subGeom.updateUVs(uvs[subMeshParsed]);
                                subGeom.updateVertexNormals(null);
                                subGeom.updateVertexTangents(null);
                                subGeom.autoDeriveNormals = false;
                                subGeom.autoDeriveTangents = false;
                                subMeshParsed++;
                                geometry.addSubGeometry(subGeom);
                            } else
                                this._newBlockBytes.position = str_end;
                            streamsParsed++;
                        }
                    }
                    clip.addFrame(geometry, frame_dur);
                    frames_parsed++;
                }
                this.parseUserAttributes();
                this._pFinalizeAsset(clip, name);

                this._blocks[blockID].data = clip;
                if (this._debug)
                    console.log("Parsed a VertexClipNode: Name = " + clip.name + " | Target-Geometry-Name = " + returnedArray[1].name + " | Number of Frames = " + clip.frames.length);
            };

            //BlockID 113
            AWDParser.prototype.parseVertexAnimationSet = function (blockID /*uint*/ ) {
                var poseBlockAdress;
                var outputString = "";
                var name = this.parseVarStr();
                var num_frames = this._newBlockBytes.readUnsignedShort();
                var props = this.parseProperties({ 1: AWDParser.UINT16 });
                var frames_parsed = 0;
                var skeletonFrames = new Array();
                var vertexFrames = new Array();
                while (frames_parsed < num_frames) {
                    poseBlockAdress = this._newBlockBytes.readUnsignedInt();
                    var returnedArray = this.getAssetByID(poseBlockAdress, [AssetType.ANIMATION_NODE]);
                    if (!returnedArray[0])
                        this._blocks[blockID].addError("Could not find the AnimationClipNode Nr " + frames_parsed + " ( " + poseBlockAdress + " ) for this AnimationSet");
                    else {
                        if (returnedArray[1] instanceof VertexClipNode)
                            vertexFrames.push(returnedArray[1]);
                        if (returnedArray[1] instanceof SkeletonClipNode)
                            skeletonFrames.push(returnedArray[1]);
                    }
                    frames_parsed++;
                }
                if ((vertexFrames.length == 0) && (skeletonFrames.length == 0)) {
                    this._blocks[blockID].addError("Could not create this AnimationSet, because it contains no animations");
                    return;
                }
                this.parseUserAttributes();
                if (vertexFrames.length > 0) {
                    var newVertexAnimationSet = new VertexAnimationSet();
                    for (var i = 0; i < vertexFrames.length; i++)
                        newVertexAnimationSet.addAnimation(vertexFrames[i]);
                    this._pFinalizeAsset(newVertexAnimationSet, name);
                    this._blocks[blockID].data = newVertexAnimationSet;
                    if (this._debug)
                        console.log("Parsed a VertexAnimationSet: Name = " + name + " | Animations = " + newVertexAnimationSet.animations.length + " | Animation-Names = " + newVertexAnimationSet.animationNames.toString());
                } else if (skeletonFrames.length > 0) {
                    returnedArray = this.getAssetByID(poseBlockAdress, [AssetType.ANIMATION_NODE]);
                    var newSkeletonAnimationSet = new SkeletonAnimationSet(props.get(1, 4));
                    for (var i = 0; i < skeletonFrames.length; i++)
                        newSkeletonAnimationSet.addAnimation(skeletonFrames[i]);
                    this._pFinalizeAsset(newSkeletonAnimationSet, name);
                    this._blocks[blockID].data = newSkeletonAnimationSet;
                    if (this._debug)
                        console.log("Parsed a SkeletonAnimationSet: Name = " + name + " | Animations = " + newSkeletonAnimationSet.animations.length + " | Animation-Names = " + newSkeletonAnimationSet.animationNames.toString());
                }
            };

            //BlockID 122
            AWDParser.prototype.parseAnimatorSet = function (blockID /*uint*/ ) {
                var targetMesh;
                var animSetBlockAdress;
                var targetAnimationSet;
                var outputString = "";
                var name = this.parseVarStr();
                var type = this._newBlockBytes.readUnsignedShort();

                var props = this.parseProperties({ 1: AWDParser.BADDR });

                animSetBlockAdress = this._newBlockBytes.readUnsignedInt();
                var targetMeshLength = this._newBlockBytes.readUnsignedShort();
                var meshAdresses = new Array();
                for (var i = 0; i < targetMeshLength; i++)
                    meshAdresses.push(this._newBlockBytes.readUnsignedInt());

                var activeState = this._newBlockBytes.readUnsignedShort();
                var autoplay = (this._newBlockBytes.readUnsignedByte() == 1);
                this.parseUserAttributes();
                this.parseUserAttributes();

                var returnedArray;
                var targetMeshes = new Array();

                for (i = 0; i < meshAdresses.length; i++) {
                    returnedArray = this.getAssetByID(meshAdresses[i], [AssetType.MESH]);
                    if (returnedArray[0])
                        targetMeshes.push(returnedArray[1]);
                }
                returnedArray = this.getAssetByID(animSetBlockAdress, [AssetType.ANIMATION_SET]);
                if (!returnedArray[0]) {
                    this._blocks[blockID].addError("Could not find the AnimationSet ( " + animSetBlockAdress + " ) for this Animator");
                    ;
                    return;
                }
                targetAnimationSet = returnedArray[1];
                var thisAnimator;
                if (type == 1) {
                    returnedArray = this.getAssetByID(props.get(1, 0), [AssetType.SKELETON]);
                    if (!returnedArray[0]) {
                        this._blocks[blockID].addError("Could not find the Skeleton ( " + props.get(1, 0) + " ) for this Animator");
                        return;
                    }
                    thisAnimator = new SkeletonAnimator(targetAnimationSet, returnedArray[1]);
                } else if (type == 2)
                    thisAnimator = new VertexAnimator(targetAnimationSet);

                this._pFinalizeAsset(thisAnimator, name);
                this._blocks[blockID].data = thisAnimator;
                for (i = 0; i < targetMeshes.length; i++) {
                    if (type == 1)
                        targetMeshes[i].animator = thisAnimator;
                    if (type == 2)
                        targetMeshes[i].animator = thisAnimator;
                }
                if (this._debug)
                    console.log("Parsed a Animator: Name = " + name);
            };

            // this functions reads and creates a EffectMethod
            AWDParser.prototype.parseSharedMethodList = function (blockID) {
                var methodType = this._newBlockBytes.readUnsignedShort();
                var effectMethodReturn;

                var props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 104: this._propsNrType, 105: this._propsNrType, 106: this._propsNrType, 107: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL });
                var targetID;
                var returnedArray;

                switch (methodType) {
                    case 403:
                        targetID = props.get(1, 0);
                        console.log('ENV MAP', targetID);

                        returnedArray = this.getAssetByID(targetID, [AssetType.TEXTURE], "CubeTexture");
                        if (!returnedArray[0])
                            this._blocks[blockID].addError("Could not find the EnvMap (ID = " + targetID + " ) for this EnvMapMethod");
                        effectMethodReturn = new away.materials.EffectEnvMapMethod(returnedArray[1], props.get(101, 1));
                        targetID = props.get(2, 0);
                        if (targetID > 0) {
                            returnedArray = this.getAssetByID(targetID, [AssetType.TEXTURE]);
                            if (!returnedArray[0])
                                this._blocks[blockID].addError("Could not find the Mask-texture (ID = " + targetID + " ) for this EnvMapMethod");
                            // Todo: test mask with EnvMapMethod
                            //(<away.materials.EnvMapMethod> effectMethodReturn).mask = <away.textures.Texture2DBase> returnedArray[1];
                        }
                        break;
                }
                this.parseUserAttributes();
                return effectMethodReturn;
            };

            AWDParser.prototype.parseUserAttributes = function () {
                var attributes;
                var list_len;
                var attibuteCnt;

                list_len = this._newBlockBytes.readUnsignedInt();

                if (list_len > 0) {
                    var list_end;

                    attributes = {};

                    list_end = this._newBlockBytes.position + list_len;

                    while (this._newBlockBytes.position < list_end) {
                        var ns_id;
                        var attr_key;
                        var attr_type;
                        var attr_len;
                        var attr_val;

                        // TODO: Properly tend to namespaces in attributes
                        ns_id = this._newBlockBytes.readUnsignedByte();
                        attr_key = this.parseVarStr();
                        attr_type = this._newBlockBytes.readUnsignedByte();
                        attr_len = this._newBlockBytes.readUnsignedInt();

                        if ((this._newBlockBytes.position + attr_len) > list_end) {
                            console.log("           Error in reading attribute # " + attibuteCnt + " = skipped to end of attribute-list");
                            this._newBlockBytes.position = list_end;
                            return attributes;
                        }

                        switch (attr_type) {
                            case AWDParser.AWDSTRING:
                                attr_val = this._newBlockBytes.readUTFBytes(attr_len);
                                break;
                            case AWDParser.INT8:
                                attr_val = this._newBlockBytes.readByte();
                                break;
                            case AWDParser.INT16:
                                attr_val = this._newBlockBytes.readShort();
                                break;
                            case AWDParser.INT32:
                                attr_val = this._newBlockBytes.readInt();
                                break;
                            case AWDParser.BOOL:
                            case AWDParser.UINT8:
                                attr_val = this._newBlockBytes.readUnsignedByte();
                                break;
                            case AWDParser.UINT16:
                                attr_val = this._newBlockBytes.readUnsignedShort();
                                break;
                            case AWDParser.UINT32:
                            case AWDParser.BADDR:
                                attr_val = this._newBlockBytes.readUnsignedInt();
                                break;
                            case AWDParser.FLOAT32:
                                attr_val = this._newBlockBytes.readFloat();
                                break;
                            case AWDParser.FLOAT64:
                                attr_val = this._newBlockBytes.readDouble();
                                break;
                            default:
                                attr_val = 'unimplemented attribute type ' + attr_type;
                                this._newBlockBytes.position += attr_len;
                                break;
                        }

                        if (this._debug) {
                            console.log("attribute = name: " + attr_key + "  / value = " + attr_val);
                        }

                        attributes[attr_key] = attr_val;
                        attibuteCnt += 1;
                    }
                }

                return attributes;
            };

            AWDParser.prototype.parseProperties = function (expected) {
                var list_end;
                var list_len;
                var propertyCnt = 0;
                var props = new AWDProperties();

                list_len = this._newBlockBytes.readUnsignedInt();
                list_end = this._newBlockBytes.position + list_len;

                if (expected) {
                    while (this._newBlockBytes.position < list_end) {
                        var len;
                        var key;
                        var type;

                        key = this._newBlockBytes.readUnsignedShort();
                        len = this._newBlockBytes.readUnsignedInt();

                        if ((this._newBlockBytes.position + len) > list_end) {
                            console.log("           Error in reading property # " + propertyCnt + " = skipped to end of propertie-list");
                            this._newBlockBytes.position = list_end;
                            return props;
                        }

                        if (expected.hasOwnProperty(key.toString())) {
                            type = expected[key];
                            props.set(key, this.parseAttrValue(type, len));
                        } else {
                            this._newBlockBytes.position += len;
                        }

                        propertyCnt += 1;
                    }
                } else {
                    this._newBlockBytes.position = list_end;
                }

                return props;
            };

            AWDParser.prototype.parseAttrValue = function (type, len) {
                var elem_len;
                var read_func;

                switch (type) {
                    case AWDParser.BOOL:
                    case AWDParser.INT8:
                        elem_len = 1;
                        read_func = this._newBlockBytes.readByte;
                        break;

                    case AWDParser.INT16:
                        elem_len = 2;
                        read_func = this._newBlockBytes.readShort;
                        break;

                    case AWDParser.INT32:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readInt;
                        break;

                    case AWDParser.UINT8:
                        elem_len = 1;
                        read_func = this._newBlockBytes.readUnsignedByte;
                        break;

                    case AWDParser.UINT16:
                        elem_len = 2;
                        read_func = this._newBlockBytes.readUnsignedShort;
                        break;

                    case AWDParser.UINT32:
                    case AWDParser.COLOR:
                    case AWDParser.BADDR:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readUnsignedInt;
                        break;

                    case AWDParser.FLOAT32:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readFloat;
                        break;

                    case AWDParser.FLOAT64:
                        elem_len = 8;
                        read_func = this._newBlockBytes.readDouble;
                        break;

                    case AWDParser.AWDSTRING:
                        return this._newBlockBytes.readUTFBytes(len);

                    case AWDParser.VECTOR2x1:
                    case AWDParser.VECTOR3x1:
                    case AWDParser.VECTOR4x1:
                    case AWDParser.MTX3x2:
                    case AWDParser.MTX3x3:
                    case AWDParser.MTX4x3:
                    case AWDParser.MTX4x4:
                        elem_len = 8;
                        read_func = this._newBlockBytes.readDouble;
                        break;
                }

                if (elem_len < len) {
                    var list = [];
                    var num_read = 0;
                    var num_elems = len / elem_len;

                    while (num_read < num_elems) {
                        list.push(read_func.apply(this._newBlockBytes)); // list.push(read_func());
                        num_read++;
                    }

                    return list;
                } else {
                    var val = read_func.apply(this._newBlockBytes);
                    return val;
                }
            };

            AWDParser.prototype.parseHeader = function () {
                var flags;
                var body_len;

                this._byteData.position = 3; // Skip magic string and parse version

                this._version[0] = this._byteData.readUnsignedByte();
                this._version[1] = this._byteData.readUnsignedByte();

                flags = this._byteData.readUnsignedShort(); // Parse bit flags

                this._streaming = bitFlags.test(flags, bitFlags.FLAG1);

                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    this._accuracyMatrix = bitFlags.test(flags, bitFlags.FLAG2);
                    this._accuracyGeo = bitFlags.test(flags, bitFlags.FLAG3);
                    this._accuracyProps = bitFlags.test(flags, bitFlags.FLAG4);
                }

                // if we set _accuracyOnBlocks, the precision-values are read from each block-header.
                // set storagePrecision types
                this._geoNrType = AWDParser.FLOAT32;

                if (this._accuracyGeo) {
                    this._geoNrType = AWDParser.FLOAT64;
                }

                this._matrixNrType = AWDParser.FLOAT32;

                if (this._accuracyMatrix) {
                    this._matrixNrType = AWDParser.FLOAT64;
                }

                this._propsNrType = AWDParser.FLOAT32;

                if (this._accuracyProps) {
                    this._propsNrType = AWDParser.FLOAT64;
                }

                this._compression = this._byteData.readUnsignedByte(); // compression

                if (this._debug) {
                    console.log("Import AWDFile of version = " + this._version[0] + " - " + this._version[1]);
                    console.log("Global Settings = Compression = " + this._compression + " | Streaming = " + this._streaming + " | Matrix-Precision = " + this._accuracyMatrix + " | Geometry-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
                }

                // Check file integrity
                body_len = this._byteData.readUnsignedInt();
                if (!this._streaming && body_len != this._byteData.getBytesAvailable()) {
                    this._pDieWithError('AWD2 body length does not match header integrity field');
                }
            };

            // Helper - functions
            AWDParser.prototype.getUVForVertexAnimation = function (meshID /*uint*/ ) {
                if (this._blocks[meshID].data instanceof Mesh)
                    meshID = this._blocks[meshID].geoID;
                if (this._blocks[meshID].uvsForVertexAnimation)
                    return this._blocks[meshID].uvsForVertexAnimation;
                var geometry = this._blocks[meshID].data;
                var geoCnt = 0;
                var ud;
                var uStride;
                var uOffs;
                var numPoints;
                var i;
                var newUvs;
                var sub_geom;
                this._blocks[meshID].uvsForVertexAnimation = new Array();
                while (geoCnt < geometry.subGeometries.length) {
                    newUvs = new Array();
                    sub_geom = geometry.subGeometries[geoCnt];
                    numPoints = sub_geom.numVertices;
                    ud = sub_geom.uvs;
                    uStride = sub_geom.getStride(TriangleSubGeometry.UV_DATA);
                    uOffs = sub_geom.getOffset(TriangleSubGeometry.UV_DATA);
                    for (i = 0; i < numPoints; i++) {
                        newUvs.push(ud[uOffs + i * uStride + 0]);
                        newUvs.push(ud[uOffs + i * uStride + 1]);
                    }
                    this._blocks[meshID].uvsForVertexAnimation.push(newUvs);
                    geoCnt++;
                }
                return this._blocks[meshID].uvsForVertexAnimation;
            };

            AWDParser.prototype.parseVarStr = function () {
                var len = this._newBlockBytes.readUnsignedShort();
                return this._newBlockBytes.readUTFBytes(len);
            };

            AWDParser.prototype.getAssetByID = function (assetID, assetTypesToGet, extraTypeInfo) {
                if (typeof extraTypeInfo === "undefined") { extraTypeInfo = "SingleTexture"; }
                var returnArray = new Array();
                var typeCnt = 0;
                if (assetID > 0) {
                    if (this._blocks[assetID]) {
                        if (this._blocks[assetID].data) {
                            while (typeCnt < assetTypesToGet.length) {
                                var iasset = this._blocks[assetID].data;

                                if (iasset.assetType == assetTypesToGet[typeCnt]) {
                                    //if the right assetType was found
                                    if ((assetTypesToGet[typeCnt] == AssetType.TEXTURE) && (extraTypeInfo == "CubeTexture")) {
                                        if (this._blocks[assetID].data instanceof away.textures.ImageCubeTexture) {
                                            returnArray.push(true);
                                            returnArray.push(this._blocks[assetID].data);
                                            return returnArray;
                                        }
                                    }
                                    if ((assetTypesToGet[typeCnt] == AssetType.TEXTURE) && (extraTypeInfo == "SingleTexture")) {
                                        if (this._blocks[assetID].data instanceof away.textures.ImageTexture) {
                                            returnArray.push(true);
                                            returnArray.push(this._blocks[assetID].data);
                                            return returnArray;
                                        }
                                    } else {
                                        returnArray.push(true);
                                        returnArray.push(this._blocks[assetID].data);
                                        return returnArray;
                                    }
                                }

                                //if ((assetTypesToGet[typeCnt] == AssetType.GEOMETRY) && (IAsset(_blocks[assetID].data).assetType == AssetType.MESH)) {
                                if ((assetTypesToGet[typeCnt] == AssetType.GEOMETRY) && (iasset.assetType == AssetType.MESH)) {
                                    var mesh = this._blocks[assetID].data;

                                    returnArray.push(true);
                                    returnArray.push(mesh.geometry);
                                    return returnArray;
                                }

                                typeCnt++;
                            }
                        }
                    }
                }

                // if the has not returned anything yet, the asset is not found, or the found asset is not the right type.
                returnArray.push(false);
                returnArray.push(this.getDefaultAsset(assetTypesToGet[0], extraTypeInfo));
                return returnArray;
            };

            AWDParser.prototype.getDefaultAsset = function (assetType, extraTypeInfo) {
                switch (true) {
                    case (assetType == AssetType.TEXTURE):
                        if (extraTypeInfo == "CubeTexture")
                            return this.getDefaultCubeTexture();
                        if (extraTypeInfo == "SingleTexture")
                            return this.getDefaultTexture();
                        break;
                    case (assetType == AssetType.MATERIAL):
                        return this.getDefaultMaterial();
                        break;
                    default:
                        break;
                }

                return null;
            };

            AWDParser.prototype.getDefaultMaterial = function () {
                if (!this._defaultBitmapMaterial)
                    this._defaultBitmapMaterial = away.materials.DefaultMaterialManager.getDefaultMaterial();

                return this._defaultBitmapMaterial;
            };

            AWDParser.prototype.getDefaultTexture = function () {
                if (!this._defaultTexture)
                    this._defaultTexture = away.materials.DefaultMaterialManager.getDefaultTexture();

                return this._defaultTexture;
            };

            AWDParser.prototype.getDefaultCubeTexture = function () {
                if (!this._defaultCubeTexture) {
                    var defaultBitmap = away.materials.DefaultMaterialManager.createCheckeredBitmapData();

                    this._defaultCubeTexture = new away.textures.BitmapCubeTexture(defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap);
                    this._defaultCubeTexture.name = "defaultCubeTexture";
                }

                return this._defaultCubeTexture;
            };

            AWDParser.prototype.readNumber = function (precision) {
                if (typeof precision === "undefined") { precision = false; }
                if (precision)
                    return this._newBlockBytes.readDouble();
                return this._newBlockBytes.readFloat();
            };

            AWDParser.prototype.parseMatrix3D = function () {
                return new Matrix3D(this.parseMatrix43RawData());
            };

            AWDParser.prototype.parseMatrix32RawData = function () {
                var i;
                var mtx_raw = new Array(6);
                for (i = 0; i < 6; i++) {
                    mtx_raw[i] = this._newBlockBytes.readFloat();
                }

                return mtx_raw;
            };

            AWDParser.prototype.parseMatrix43RawData = function () {
                var mtx_raw = new Array(16);

                mtx_raw[0] = this.readNumber(this._accuracyMatrix);
                mtx_raw[1] = this.readNumber(this._accuracyMatrix);
                mtx_raw[2] = this.readNumber(this._accuracyMatrix);
                mtx_raw[3] = 0.0;
                mtx_raw[4] = this.readNumber(this._accuracyMatrix);
                mtx_raw[5] = this.readNumber(this._accuracyMatrix);
                mtx_raw[6] = this.readNumber(this._accuracyMatrix);
                mtx_raw[7] = 0.0;
                mtx_raw[8] = this.readNumber(this._accuracyMatrix);
                mtx_raw[9] = this.readNumber(this._accuracyMatrix);
                mtx_raw[10] = this.readNumber(this._accuracyMatrix);
                mtx_raw[11] = 0.0;
                mtx_raw[12] = this.readNumber(this._accuracyMatrix);
                mtx_raw[13] = this.readNumber(this._accuracyMatrix);
                mtx_raw[14] = this.readNumber(this._accuracyMatrix);
                mtx_raw[15] = 1.0;

                //TODO: fix max exporter to remove NaN values in joint 0 inverse bind pose
                if (isNaN(mtx_raw[0])) {
                    mtx_raw[0] = 1;
                    mtx_raw[1] = 0;
                    mtx_raw[2] = 0;
                    mtx_raw[4] = 0;
                    mtx_raw[5] = 1;
                    mtx_raw[6] = 0;
                    mtx_raw[8] = 0;
                    mtx_raw[9] = 0;
                    mtx_raw[10] = 1;
                    mtx_raw[12] = 0;
                    mtx_raw[13] = 0;
                    mtx_raw[14] = 0;
                }

                return mtx_raw;
            };
            AWDParser.COMPRESSIONMODE_LZMA = "lzma";
            AWDParser.UNCOMPRESSED = 0;
            AWDParser.DEFLATE = 1;
            AWDParser.LZMA = 2;
            AWDParser.INT8 = 1;
            AWDParser.INT16 = 2;
            AWDParser.INT32 = 3;
            AWDParser.UINT8 = 4;
            AWDParser.UINT16 = 5;
            AWDParser.UINT32 = 6;
            AWDParser.FLOAT32 = 7;
            AWDParser.FLOAT64 = 8;
            AWDParser.BOOL = 21;
            AWDParser.COLOR = 22;
            AWDParser.BADDR = 23;
            AWDParser.AWDSTRING = 31;
            AWDParser.AWDBYTEARRAY = 32;
            AWDParser.VECTOR2x1 = 41;
            AWDParser.VECTOR3x1 = 42;
            AWDParser.VECTOR4x1 = 43;
            AWDParser.MTX3x2 = 44;
            AWDParser.MTX3x3 = 45;
            AWDParser.MTX4x3 = 46;
            AWDParser.MTX4x4 = 47;
            return AWDParser;
        })(away.parsers.ParserBase);
        parsers.AWDParser = AWDParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

var AWDBlock = (function () {
    function AWDBlock() {
    }
    AWDBlock.prototype.dispose = function () {
        this.id = null;
        this.bytes = null;
        this.errorMessages = null;
        this.uvsForVertexAnimation = null;
    };

    AWDBlock.prototype.addError = function (errorMsg) {
        if (!this.errorMessages)
            this.errorMessages = new Array();
        this.errorMessages.push(errorMsg);
    };
    return AWDBlock;
})();

var bitFlags = (function () {
    function bitFlags() {
    }
    bitFlags.test = function (flags, testFlag) {
        return (flags & testFlag) == testFlag;
    };
    bitFlags.FLAG1 = 1;
    bitFlags.FLAG2 = 2;
    bitFlags.FLAG3 = 4;
    bitFlags.FLAG4 = 8;
    bitFlags.FLAG5 = 16;
    bitFlags.FLAG6 = 32;
    bitFlags.FLAG7 = 64;
    bitFlags.FLAG8 = 128;
    bitFlags.FLAG9 = 256;
    bitFlags.FLAG10 = 512;
    bitFlags.FLAG11 = 1024;
    bitFlags.FLAG12 = 2048;
    bitFlags.FLAG13 = 4096;
    bitFlags.FLAG14 = 8192;
    bitFlags.FLAG15 = 16384;
    bitFlags.FLAG16 = 32768;
    return bitFlags;
})();

var AWDProperties = (function () {
    function AWDProperties() {
    }
    AWDProperties.prototype.set = function (key, value) {
        this[key.toString()] = value;
    };

    AWDProperties.prototype.get = function (key, fallback) {
        if (this.hasOwnProperty(key.toString())) {
            return this[key.toString()];
        } else {
            return fallback;
        }
    };
    return AWDProperties;
})();
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (parsers) {
        var SubGeometry = away.base.TriangleSubGeometry;
        var ColorMaterial = away.materials.ColorMaterial;
        var ColorMultiPassMaterial = away.materials.ColorMultiPassMaterial;
        var DefaultMaterialManager = away.materials.DefaultMaterialManager;

        var TextureMaterial = away.materials.TextureMaterial;
        var TextureMultiPassMaterial = away.materials.TextureMultiPassMaterial;

        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        /**
        * Max3DSParser provides a parser for the 3ds data type.
        */
        var Max3DSParser = (function (_super) {
            __extends(Max3DSParser, _super);
            /**
            * Creates a new <code>Max3DSParser</code> object.
            *
            * @param useSmoothingGroups Determines whether the parser looks for smoothing groups in the 3ds file or assumes uniform smoothing. Defaults to true.
            */
            function Max3DSParser(useSmoothingGroups) {
                if (typeof useSmoothingGroups === "undefined") { useSmoothingGroups = true; }
                _super.call(this, URLLoaderDataFormat.ARRAY_BUFFER);

                this._useSmoothingGroups = useSmoothingGroups;
            }
            /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            Max3DSParser.supportsType = function (extension) {
                extension = extension.toLowerCase();
                return extension == "3ds";
            };

            /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            Max3DSParser.supportsData = function (data) {
                var ba;

                ba = parsers.ParserUtils.toByteArray(data);
                if (ba) {
                    ba.position = 0;
                    if (ba.readShort() == 0x4d4d)
                        return true;
                }

                return false;
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.assets.length == 1) {
                    var asset;

                    asset = resourceDependency.assets[0];
                    if (asset.assetType == away.library.AssetType.TEXTURE) {
                        var tex;

                        tex = this._textures[resourceDependency.id];
                        tex.texture = asset;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                // TODO: Implement
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._pProceedParsing = function () {
                if (!this._byteData) {
                    this._byteData = this._pGetByteData();
                    this._byteData.position = 0;

                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._byteData.endian = Endian.LITTLE_ENDIAN;// Should be default
                    //----------------------------------------------------------------------------
                    this._textures = {};
                    this._materials = {};
                    this._unfinalized_objects = {};
                }

                while (this._pHasTime()) {
                    // If we are currently working on an object, and the most recent chunk was
                    // the last one in that object, finalize the current object.
                    if (this._cur_mat && this._byteData.position >= this._cur_mat_end)
                        this.finalizeCurrentMaterial();
                    else if (this._cur_obj && this._byteData.position >= this._cur_obj_end) {
                        // Can't finalize at this point, because we have to wait until the full
                        // animation section has been parsed for any potential pivot definitions
                        this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
                        this._cur_obj_end = Number.MAX_VALUE;
                        this._cur_obj = null;
                    }

                    if (this._byteData.getBytesAvailable() > 0) {
                        var cid;
                        var len;
                        var end;

                        cid = this._byteData.readUnsignedShort();
                        len = this._byteData.readUnsignedInt();
                        end = this._byteData.position + (len - 6);

                        switch (cid) {
                            case 0x4D4D:
                            case 0x3D3D:
                            case 0xB000:
                                continue;
                                break;

                            case 0xAFFF:
                                this._cur_mat_end = end;
                                this._cur_mat = this.parseMaterial();
                                break;

                            case 0x4000:
                                this._cur_obj_end = end;
                                this._cur_obj = new ObjectVO();
                                this._cur_obj.name = this.readNulTermstring();
                                this._cur_obj.materials = new Array();
                                this._cur_obj.materialFaces = {};
                                break;

                            case 0x4100:
                                this._cur_obj.type = away.library.AssetType.MESH;
                                break;

                            case 0x4110:
                                this.parseVertexList();
                                break;

                            case 0x4120:
                                this.parseFaceList();
                                break;

                            case 0x4140:
                                this.parseUVList();
                                break;

                            case 0x4130:
                                this.parseFaceMaterialList();
                                break;

                            case 0x4160:
                                this._cur_obj.transform = this.readTransform();
                                break;

                            case 0xB002:
                                this.parseObjectAnimation(end);
                                break;

                            case 0x4150:
                                this.parseSmoothingGroups();
                                break;

                            default:
                                // Skip this (unknown) chunk
                                this._byteData.position += (len - 6);
                                break;
                        }

                        // Pause parsing if there were any dependencies found during this
                        // iteration (i.e. if there are any dependencies that need to be
                        // retrieved at this time.)
                        if (this.dependencies.length) {
                            this._pPauseAndRetrieveDependencies();
                            break;
                        }
                    }
                }

                // More parsing is required if the entire byte array has not yet
                // been read, or if there is a currently non-finalized object in
                // the pipeline.
                if (this._byteData.getBytesAvailable() || this._cur_obj || this._cur_mat) {
                    return parsers.ParserBase.MORE_TO_PARSE;
                } else {
                    var name;

                    for (name in this._unfinalized_objects) {
                        var obj;
                        obj = this.constructObject(this._unfinalized_objects[name]);
                        if (obj) {
                            //add to the content property
                            this._pContent.addChild(obj);

                            this._pFinalizeAsset(obj, name);
                        }
                    }

                    return parsers.ParserBase.PARSING_DONE;
                }
            };

            Max3DSParser.prototype._pStartParsing = function (frameLimit) {
                _super.prototype._pStartParsing.call(this, frameLimit);

                //create a content object for Loaders
                this._pContent = new away.containers.DisplayObjectContainer();
            };

            Max3DSParser.prototype.parseMaterial = function () {
                var mat;

                mat = new MaterialVO();

                while (this._byteData.position < this._cur_mat_end) {
                    var cid;
                    var len;
                    var end;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();
                    end = this._byteData.position + (len - 6);

                    switch (cid) {
                        case 0xA000:
                            mat.name = this.readNulTermstring();
                            break;

                        case 0xA010:
                            mat.ambientColor = this.readColor();
                            break;

                        case 0xA020:
                            mat.diffuseColor = this.readColor();
                            break;

                        case 0xA030:
                            mat.specularColor = this.readColor();
                            break;

                        case 0xA081:
                            mat.twoSided = true;
                            break;

                        case 0xA200:
                            mat.colorMap = this.parseTexture(end);
                            break;

                        case 0xA204:
                            mat.specularMap = this.parseTexture(end);
                            break;

                        default:
                            this._byteData.position = end;
                            break;
                    }
                }

                return mat;
            };

            Max3DSParser.prototype.parseTexture = function (end /*uint*/ ) {
                var tex;

                tex = new TextureVO();

                while (this._byteData.position < end) {
                    var cid;
                    var len;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();

                    switch (cid) {
                        case 0xA300:
                            tex.url = this.readNulTermstring();
                            break;

                        default:
                            // Skip this unknown texture sub-chunk
                            this._byteData.position += (len - 6);
                            break;
                    }
                }

                this._textures[tex.url] = tex;
                this._pAddDependency(tex.url, new away.net.URLRequest(tex.url));

                return tex;
            };

            Max3DSParser.prototype.parseVertexList = function () {
                var i;
                var len;
                var count;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.verts = new Array(count * 3);

                i = 0;
                len = this._cur_obj.verts.length;
                while (i < len) {
                    var x, y, z;

                    x = this._byteData.readFloat();
                    y = this._byteData.readFloat();
                    z = this._byteData.readFloat();

                    this._cur_obj.verts[i++] = x;
                    this._cur_obj.verts[i++] = z;
                    this._cur_obj.verts[i++] = y;
                }
            };

            Max3DSParser.prototype.parseFaceList = function () {
                var i;
                var len;
                var count;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.indices = new Array(count * 3);

                i = 0;
                len = this._cur_obj.indices.length;
                while (i < len) {
                    var i0, i1, i2;

                    i0 = this._byteData.readUnsignedShort();
                    i1 = this._byteData.readUnsignedShort();
                    i2 = this._byteData.readUnsignedShort();

                    this._cur_obj.indices[i++] = i0;
                    this._cur_obj.indices[i++] = i2;
                    this._cur_obj.indices[i++] = i1;

                    // Skip "face info", irrelevant in Away3D
                    this._byteData.position += 2;
                }

                this._cur_obj.smoothingGroups = new Array(count);
            };

            Max3DSParser.prototype.parseSmoothingGroups = function () {
                var len = this._cur_obj.indices.length / 3;
                var i = 0;
                while (i < len) {
                    this._cur_obj.smoothingGroups[i] = this._byteData.readUnsignedInt();
                    i++;
                }
            };

            Max3DSParser.prototype.parseUVList = function () {
                var i;
                var len;
                var count;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.uvs = new Array(count * 2);

                i = 0;
                len = this._cur_obj.uvs.length;
                while (i < len) {
                    this._cur_obj.uvs[i++] = this._byteData.readFloat();
                    this._cur_obj.uvs[i++] = 1.0 - this._byteData.readFloat();
                }
            };

            Max3DSParser.prototype.parseFaceMaterialList = function () {
                var mat;
                var count;
                var i;
                var faces;

                mat = this.readNulTermstring();
                count = this._byteData.readUnsignedShort();

                faces = new Array(count);
                i = 0;
                while (i < faces.length)
                    faces[i++] = this._byteData.readUnsignedShort();

                this._cur_obj.materials.push(mat);
                this._cur_obj.materialFaces[mat] = faces;
            };

            Max3DSParser.prototype.parseObjectAnimation = function (end) {
                var vo;
                var obj;
                var pivot;
                var name;
                var hier;

                // Pivot defaults to origin
                pivot = new away.geom.Vector3D;

                while (this._byteData.position < end) {
                    var cid;
                    var len;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();

                    switch (cid) {
                        case 0xb010:
                            name = this.readNulTermstring();
                            this._byteData.position += 4;
                            hier = this._byteData.readShort();
                            break;

                        case 0xb013:
                            pivot.x = this._byteData.readFloat();
                            pivot.z = this._byteData.readFloat();
                            pivot.y = this._byteData.readFloat();
                            break;

                        default:
                            this._byteData.position += (len - 6);
                            break;
                    }
                }

                // If name is "$$$DUMMY" this is an empty object (e.g. a container)
                // and will be ignored in this version of the parser
                // TODO: Implement containers in 3DS parser.
                if (name != '$$$DUMMY' && this._unfinalized_objects.hasOwnProperty(name)) {
                    vo = this._unfinalized_objects[name];
                    obj = this.constructObject(vo, pivot);

                    if (obj) {
                        //add to the content property
                        this._pContent.addChild(obj);

                        this._pFinalizeAsset(obj, vo.name);
                    }

                    delete this._unfinalized_objects[name];
                }
            };

            Max3DSParser.prototype.constructObject = function (obj, pivot) {
                if (typeof pivot === "undefined") { pivot = null; }
                if (obj.type == away.library.AssetType.MESH) {
                    var i;
                    var sub;
                    var geom;
                    var mat;
                    var mesh;
                    var mtx;
                    var vertices;
                    var faces;

                    if (obj.materials.length > 1)
                        console.log("The Away3D 3DS parser does not support multiple materials per mesh at this point.");

                    // Ignore empty objects
                    if (!obj.indices || obj.indices.length == 0)
                        return null;

                    vertices = new Array(obj.verts.length / 3);
                    faces = new Array(obj.indices.length / 3);

                    this.prepareData(vertices, faces, obj);

                    if (this._useSmoothingGroups)
                        this.applySmoothGroups(vertices, faces);

                    obj.verts = new Array(vertices.length * 3);
                    for (i = 0; i < vertices.length; i++) {
                        obj.verts[i * 3] = vertices[i].x;
                        obj.verts[i * 3 + 1] = vertices[i].y;
                        obj.verts[i * 3 + 2] = vertices[i].z;
                    }
                    obj.indices = new Array(faces.length * 3);

                    for (i = 0; i < faces.length; i++) {
                        obj.indices[i * 3] = faces[i].a;
                        obj.indices[i * 3 + 1] = faces[i].b;
                        obj.indices[i * 3 + 2] = faces[i].c;
                    }

                    if (obj.uvs) {
                        // If the object had UVs to start with, use UVs generated by
                        // smoothing group splitting algorithm. Otherwise those UVs
                        // will be nonsense and should be skipped.
                        obj.uvs = new Array(vertices.length * 2);
                        for (i = 0; i < vertices.length; i++) {
                            obj.uvs[i * 2] = vertices[i].u;
                            obj.uvs[i * 2 + 1] = vertices[i].v;
                        }
                    }

                    geom = new away.base.Geometry();

                    // Construct sub-geometries (potentially splitting buffers)
                    // and add them to geometry.
                    sub = new SubGeometry(true);
                    sub.updateIndices(obj.indices);
                    sub.updatePositions(obj.verts);
                    sub.updateUVs(obj.uvs);

                    geom.addSubGeometry(sub);

                    if (obj.materials.length > 0) {
                        var mname;
                        mname = obj.materials[0];
                        mat = this._materials[mname].material;
                    }

                    // Apply pivot translation to geometry if a pivot was
                    // found while parsing the keyframe chunk earlier.
                    if (pivot) {
                        if (obj.transform) {
                            // If a transform was found while parsing the
                            // object chunk, use it to find the local pivot vector
                            var dat = obj.transform.concat();
                            dat[12] = 0;
                            dat[13] = 0;
                            dat[14] = 0;
                            mtx = new away.geom.Matrix3D(dat);
                            pivot = mtx.transformVector(pivot);
                        }

                        pivot.scaleBy(-1);

                        mtx = new away.geom.Matrix3D();
                        mtx.appendTranslation(pivot.x, pivot.y, pivot.z);
                        geom.applyTransformation(mtx);
                    }

                    // Apply transformation to geometry if a transformation
                    // was found while parsing the object chunk earlier.
                    if (obj.transform) {
                        mtx = new away.geom.Matrix3D(obj.transform);
                        mtx.invert();
                        geom.applyTransformation(mtx);
                    }

                    // Final transform applied to geometry. Finalize the geometry,
                    // which will no longer be modified after this point.
                    this._pFinalizeAsset(geom, obj.name.concat('_geom'));

                    // Build mesh and return it
                    mesh = new away.entities.Mesh(geom, mat);
                    mesh.transform.matrix3D = new away.geom.Matrix3D(obj.transform);
                    return mesh;
                }

                // If reached, unknown
                return null;
            };

            Max3DSParser.prototype.prepareData = function (vertices, faces, obj) {
                // convert raw ObjectVO's data to structured VertexVO and FaceVO
                var i;
                var j;
                var k;
                var len = obj.verts.length;
                for (i = 0, j = 0, k = 0; i < len;) {
                    var v = new VertexVO;
                    v.x = obj.verts[i++];
                    v.y = obj.verts[i++];
                    v.z = obj.verts[i++];
                    if (obj.uvs) {
                        v.u = obj.uvs[j++];
                        v.v = obj.uvs[j++];
                    }
                    vertices[k++] = v;
                }
                len = obj.indices.length;
                for (i = 0, k = 0; i < len;) {
                    var f = new FaceVO();
                    f.a = obj.indices[i++];
                    f.b = obj.indices[i++];
                    f.c = obj.indices[i++];
                    f.smoothGroup = obj.smoothingGroups[k] || 0;
                    faces[k++] = f;
                }
            };

            Max3DSParser.prototype.applySmoothGroups = function (vertices, faces) {
                // clone vertices according to following rule:
                // clone if vertex's in faces from groups 1+2 and 3
                // don't clone if vertex's in faces from groups 1+2, 3 and 1+3
                var i;
                var j;
                var k;
                var l;
                var len;
                var numVerts = vertices.length;
                var numFaces = faces.length;

                // extract groups data for vertices
                var vGroups = new Array(numVerts);
                for (i = 0; i < numVerts; i++)
                    vGroups[i] = new Array();
                for (i = 0; i < numFaces; i++) {
                    var face = faces[i];
                    for (j = 0; j < 3; j++) {
                        var groups = vGroups[(j == 0) ? face.a : ((j == 1) ? face.b : face.c)];
                        var group = face.smoothGroup;
                        for (k = groups.length - 1; k >= 0; k--) {
                            if ((group & groups[k]) > 0) {
                                group |= groups[k];
                                groups.splice(k, 1);
                                k = groups.length - 1;
                            }
                        }
                        groups.push(group);
                    }
                }

                // clone vertices
                var vClones = new Array(numVerts);
                for (i = 0; i < numVerts; i++) {
                    if ((len = vGroups[i].length) < 1)
                        continue;
                    var clones = new Array(len);
                    vClones[i] = clones;
                    clones[0] = i;
                    var v0 = vertices[i];
                    for (j = 1; j < len; j++) {
                        var v1 = new VertexVO;
                        v1.x = v0.x;
                        v1.y = v0.y;
                        v1.z = v0.z;
                        v1.u = v0.u;
                        v1.v = v0.v;
                        clones[j] = vertices.length;
                        vertices.push(v1);
                    }
                }
                numVerts = vertices.length;

                for (i = 0; i < numFaces; i++) {
                    face = faces[i];
                    group = face.smoothGroup;
                    for (j = 0; j < 3; j++) {
                        k = (j == 0) ? face.a : ((j == 1) ? face.b : face.c);
                        groups = vGroups[k];
                        len = groups.length;
                        clones = vClones[k];
                        for (l = 0; l < len; l++) {
                            if (((group == 0) && (groups[l] == 0)) || ((group & groups[l]) > 0)) {
                                var index = clones[l];
                                if (group == 0) {
                                    // vertex is unique if no smoothGroup found
                                    groups.splice(l, 1);
                                    clones.splice(l, 1);
                                }
                                if (j == 0)
                                    face.a = index;
                                else if (j == 1)
                                    face.b = index;
                                else
                                    face.c = index;
                                l = len;
                            }
                        }
                    }
                }
            };

            Max3DSParser.prototype.finalizeCurrentMaterial = function () {
                var mat;
                if (this.materialMode < 2) {
                    if (this._cur_mat.colorMap)
                        mat = new TextureMaterial(this._cur_mat.colorMap.texture || DefaultMaterialManager.getDefaultTexture());
                    else
                        mat = new ColorMaterial(this._cur_mat.diffuseColor);
                    mat.ambientColor = this._cur_mat.ambientColor;
                    mat.specularColor = this._cur_mat.specularColor;
                } else {
                    if (this._cur_mat.colorMap)
                        mat = new TextureMultiPassMaterial(this._cur_mat.colorMap.texture || DefaultMaterialManager.getDefaultTexture());
                    else
                        mat = new ColorMultiPassMaterial(this._cur_mat.diffuseColor);
                    mat.ambientColor = this._cur_mat.ambientColor;
                    mat.specularColor = this._cur_mat.specularColor;
                }

                mat.bothSides = this._cur_mat.twoSided;

                this._pFinalizeAsset(mat, this._cur_mat.name);

                this._materials[this._cur_mat.name] = this._cur_mat;
                this._cur_mat.material = mat;

                this._cur_mat = null;
            };

            Max3DSParser.prototype.readNulTermstring = function () {
                var chr;
                var str = "";

                while ((chr = this._byteData.readUnsignedByte()) > 0)
                    str += String.fromCharCode(chr);

                return str;
            };

            Max3DSParser.prototype.readTransform = function () {
                var data;

                data = new Array(16);

                // X axis
                data[0] = this._byteData.readFloat(); // X
                data[2] = this._byteData.readFloat(); // Z
                data[1] = this._byteData.readFloat(); // Y
                data[3] = 0;

                // Z axis
                data[8] = this._byteData.readFloat(); // X
                data[10] = this._byteData.readFloat(); // Z
                data[9] = this._byteData.readFloat(); // Y
                data[11] = 0;

                // Y Axis
                data[4] = this._byteData.readFloat(); // X
                data[6] = this._byteData.readFloat(); // Z
                data[5] = this._byteData.readFloat(); // Y
                data[7] = 0;

                // Translation
                data[12] = this._byteData.readFloat(); // X
                data[14] = this._byteData.readFloat(); // Z
                data[13] = this._byteData.readFloat(); // Y
                data[15] = 1;

                return data;
            };

            Max3DSParser.prototype.readColor = function () {
                var cid;
                var len;
                var r, g, b;

                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();

                switch (cid) {
                    case 0x0010:
                        r = this._byteData.readFloat() * 255;
                        g = this._byteData.readFloat() * 255;
                        b = this._byteData.readFloat() * 255;
                        break;
                    case 0x0011:
                        r = this._byteData.readUnsignedByte();
                        g = this._byteData.readUnsignedByte();
                        b = this._byteData.readUnsignedByte();
                        break;
                    default:
                        this._byteData.position += (len - 6);
                        break;
                }

                return (r << 16) | (g << 8) | b;
            };
            return Max3DSParser;
        })(parsers.ParserBase);
        parsers.Max3DSParser = Max3DSParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

var Vector3D = away.geom.Vector3D;

var TextureVO = (function () {
    function TextureVO() {
    }
    return TextureVO;
})();

var MaterialVO = (function () {
    function MaterialVO() {
    }
    return MaterialVO;
})();

var ObjectVO = (function () {
    function ObjectVO() {
    }
    return ObjectVO;
})();

var VertexVO = (function () {
    function VertexVO() {
    }
    return VertexVO;
})();

var FaceVO = (function () {
    function FaceVO() {
    }
    return FaceVO;
})();
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (parsers) {
        var Geometry = away.base.Geometry;
        var TriangleSubGeometry = away.base.TriangleSubGeometry;
        var VertexAnimationSet = away.animators.VertexAnimationSet;
        var VertexClipNode = away.animators.VertexClipNode;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        /**
        * MD2Parser provides a parser for the MD2 data type.
        */
        var MD2Parser = (function (_super) {
            __extends(MD2Parser, _super);
            /**
            * Creates a new MD2Parser object.
            * @param textureType The extension of the texture (e.g. jpg/png/...)
            * @param ignoreTexturePath If true, the path of the texture is ignored
            */
            function MD2Parser(textureType, ignoreTexturePath) {
                if (typeof textureType === "undefined") { textureType = "jpg"; }
                if (typeof ignoreTexturePath === "undefined") { ignoreTexturePath = true; }
                _super.call(this, URLLoaderDataFormat.ARRAY_BUFFER);
                this._clipNodes = new Object();
                // the current subgeom being built
                this._animationSet = new VertexAnimationSet();
                this.materialFinal = false;
                this.geoCreated = false;
                this._textureType = textureType;
                this._ignoreTexturePath = ignoreTexturePath;
            }
            /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            MD2Parser.supportsType = function (extension) {
                extension = extension.toLowerCase();
                return extension == "md2";
            };

            /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            MD2Parser.supportsData = function (data) {
                return (parsers.ParserUtils.toString(data, 4) == 'IDP2');
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.assets.length != 1)
                    return;

                var asset = resourceDependency.assets[0];
                if (asset) {
                    var material;
                    if (this.materialMode < 2)
                        material = new away.materials.TextureMaterial(asset);
                    else
                        material = new away.materials.TextureMultiPassMaterial(asset);

                    //add to the content property
                    this._pContent.addChild(this._mesh);

                    material.name = this._mesh.material.name;
                    this._mesh.material = material;
                    this._pFinalizeAsset(material);
                    this._pFinalizeAsset(this._mesh.geometry);
                    this._pFinalizeAsset(this._mesh);
                }
                this.materialFinal = true;
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                // apply system default
                if (this.materialMode < 2)
                    this._mesh.material = away.materials.DefaultMaterialManager.getDefaultMaterial();
                else
                    this._mesh.material = new away.materials.TextureMultiPassMaterial(away.materials.DefaultMaterialManager.getDefaultTexture());

                //add to the content property
                this._pContent.addChild(this._mesh);

                this._pFinalizeAsset(this._mesh.geometry);
                this._pFinalizeAsset(this._mesh);
                this.materialFinal = true;
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._pProceedParsing = function () {
                if (!this._startedParsing) {
                    this._byteData = this._pGetByteData();
                    this._startedParsing = true;

                    // Reset bytearray read position (which may have been
                    // moved forward by the supportsData() function.)
                    this._byteData.position = 0;
                }

                while (this._pHasTime()) {
                    if (!this._parsedHeader) {
                        //----------------------------------------------------------------------------
                        // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                        //----------------------------------------------------------------------------
                        //this._byteData.endian = Endian.LITTLE_ENDIAN;
                        // TODO: Create a mesh only when encountered (if it makes sense
                        // for this file format) and return it using this._pFinalizeAsset()
                        this._geometry = new Geometry();
                        this._mesh = new away.entities.Mesh(this._geometry, null);
                        if (this.materialMode < 2)
                            this._mesh.material = away.materials.DefaultMaterialManager.getDefaultMaterial();
                        else
                            this._mesh.material = new away.materials.TextureMultiPassMaterial(away.materials.DefaultMaterialManager.getDefaultTexture());

                        //_geometry.animation = new VertexAnimation(2, VertexAnimationMode.ABSOLUTE);
                        //_animator = new VertexAnimator(VertexAnimationState(_mesh.animationState));
                        // Parse header and decompress body
                        this.parseHeader();
                        this.parseMaterialNames();
                    } else if (!this._parsedUV) {
                        this.parseUV();
                    } else if (!this._parsedFaces) {
                        this.parseFaces();
                    } else if (!this._parsedFrames) {
                        this.parseFrames();
                    } else if ((this.geoCreated) && (this.materialFinal)) {
                        return away.parsers.ParserBase.PARSING_DONE;
                    } else if (!this.geoCreated) {
                        this.geoCreated = true;

                        //create default subgeometry
                        this._geometry.addSubGeometry(this._firstSubGeom.clone());

                        // Force name to be chosen by this._pFinalizeAsset()
                        this._mesh.name = "";
                        if (this.materialFinal) {
                            //add to the content property
                            this._pContent.addChild(this._mesh);

                            this._pFinalizeAsset(this._mesh.geometry);
                            this._pFinalizeAsset(this._mesh);
                        }

                        this._pPauseAndRetrieveDependencies();
                    }
                }

                return away.parsers.ParserBase.MORE_TO_PARSE;
            };

            MD2Parser.prototype._pStartParsing = function (frameLimit) {
                _super.prototype._pStartParsing.call(this, frameLimit);

                //create a content object for Loaders
                this._pContent = new away.containers.DisplayObjectContainer();
            };

            /**
            * Reads in all that MD2 Header data that is declared as private variables.
            * I know its a lot, and it looks ugly, but only way to do it in Flash
            */
            MD2Parser.prototype.parseHeader = function () {
                this._ident = this._byteData.readInt();
                this._version = this._byteData.readInt();
                this._skinWidth = this._byteData.readInt();
                this._skinHeight = this._byteData.readInt();

                //skip this._frameSize
                this._byteData.readInt();
                this._numSkins = this._byteData.readInt();
                this._numVertices = this._byteData.readInt();
                this._numST = this._byteData.readInt();
                this._numTris = this._byteData.readInt();

                //skip this._numGlCmds
                this._byteData.readInt();
                this._numFrames = this._byteData.readInt();
                this._offsetSkins = this._byteData.readInt();
                this._offsetST = this._byteData.readInt();
                this._offsetTris = this._byteData.readInt();
                this._offsetFrames = this._byteData.readInt();

                //skip this._offsetGlCmds
                this._byteData.readInt();
                this._offsetEnd = this._byteData.readInt();

                this._parsedHeader = true;
            };

            /**
            * Parses the file names for the materials.
            */
            MD2Parser.prototype.parseMaterialNames = function () {
                var url;
                var name;
                var extIndex;
                var slashIndex;
                this._materialNames = new Array();
                this._byteData.position = this._offsetSkins;

                var regExp = new RegExp("[^a-zA-Z0-9\\_\/.]", "g");
                for (var i = 0; i < this._numSkins; ++i) {
                    name = this._byteData.readUTFBytes(64);
                    name = name.replace(regExp, "");
                    extIndex = name.lastIndexOf(".");
                    if (this._ignoreTexturePath)
                        slashIndex = name.lastIndexOf("/");
                    if (name.toLowerCase().indexOf(".jpg") == -1 && name.toLowerCase().indexOf(".png") == -1) {
                        name = name.substring(slashIndex + 1, extIndex);
                        url = name + "." + this._textureType;
                    } else {
                        url = name;
                    }

                    this._materialNames[i] = name;

                    // only support 1 skin TODO: really?
                    if (this.dependencies.length == 0)
                        this._pAddDependency(name, new away.net.URLRequest(url));
                }

                if (this._materialNames.length > 0)
                    this._mesh.material.name = this._materialNames[0];
                else
                    this.materialFinal = true;
            };

            /**
            * Parses the uv data for the mesh.
            */
            MD2Parser.prototype.parseUV = function () {
                var j = 0;

                this._uvs = new Array(this._numST * 2);
                this._byteData.position = this._offsetST;
                for (var i = 0; i < this._numST; i++) {
                    this._uvs[j++] = this._byteData.readShort() / this._skinWidth;
                    this._uvs[j++] = this._byteData.readShort() / this._skinHeight;
                }

                this._parsedUV = true;
            };

            /**
            * Parses unique indices for the faces.
            */
            MD2Parser.prototype.parseFaces = function () {
                var a, b, c, ta, tb, tc;
                var i;

                this._vertIndices = new Array();
                this._uvIndices = new Array();
                this._indices = new Array();

                this._byteData.position = this._offsetTris;

                for (i = 0; i < this._numTris; i++) {
                    //collect vertex indices
                    a = this._byteData.readUnsignedShort();
                    b = this._byteData.readUnsignedShort();
                    c = this._byteData.readUnsignedShort();

                    //collect uv indices
                    ta = this._byteData.readUnsignedShort();
                    tb = this._byteData.readUnsignedShort();
                    tc = this._byteData.readUnsignedShort();

                    this.addIndex(a, ta);
                    this.addIndex(b, tb);
                    this.addIndex(c, tc);
                }

                var len = this._uvIndices.length;
                this._finalUV = new Array(len * 2);

                for (i = 0; i < len; ++i) {
                    this._finalUV[i << 1] = this._uvs[this._uvIndices[i] << 1];
                    this._finalUV[(i << 1) + 1] = this._uvs[(this._uvIndices[i] << 1) + 1];
                }

                this._parsedFaces = true;
            };

            /**
            * Adds a face index to the list if it doesn't exist yet, based on vertexIndex and uvIndex, and adds the
            * corresponding vertex and uv data in the correct location.
            * @param vertexIndex The original index in the vertex list.
            * @param uvIndex The original index in the uv list.
            */
            MD2Parser.prototype.addIndex = function (vertexIndex /*uint*/ , uvIndex /*uint*/ ) {
                var index = this.findIndex(vertexIndex, uvIndex);

                if (index == -1) {
                    this._indices.push(this._vertIndices.length);
                    this._vertIndices.push(vertexIndex);
                    this._uvIndices.push(uvIndex);
                } else
                    this._indices.push(index);
            };

            /**
            * Finds the final index corresponding to the original MD2's vertex and uv indices. Returns -1 if it wasn't added yet.
            * @param vertexIndex The original index in the vertex list.
            * @param uvIndex The original index in the uv list.
            * @return The index of the final mesh corresponding to the original vertex and uv index. -1 if it doesn't exist yet.
            */
            MD2Parser.prototype.findIndex = function (vertexIndex /*uint*/ , uvIndex /*uint*/ ) {
                var len = this._vertIndices.length;

                for (var i = 0; i < len; ++i) {
                    if (this._vertIndices[i] == vertexIndex && this._uvIndices[i] == uvIndex)
                        return i;
                }

                return -1;
            };

            /**
            * Parses all the frame geometries.
            */
            MD2Parser.prototype.parseFrames = function () {
                var sx, sy, sz;
                var tx, ty, tz;
                var geometry;
                var subGeom;
                var vertLen = this._vertIndices.length;
                var fvertices;
                var tvertices;
                var i, j, k;

                //var ch : number /*uint*/;
                var name = "";
                var prevClip = null;

                this._byteData.position = this._offsetFrames;

                for (i = 0; i < this._numFrames; i++) {
                    tvertices = new Array();
                    fvertices = new Array(vertLen * 3);

                    sx = this._byteData.readFloat();
                    sy = this._byteData.readFloat();
                    sz = this._byteData.readFloat();

                    tx = this._byteData.readFloat();
                    ty = this._byteData.readFloat();
                    tz = this._byteData.readFloat();

                    name = this.readFrameName();

                    for (j = 0; j < this._numVertices; j++, this._byteData.position++)
                        tvertices.push(sx * this._byteData.readUnsignedByte() + tx, sy * this._byteData.readUnsignedByte() + ty, sz * this._byteData.readUnsignedByte() + tz);

                    k = 0;
                    for (j = 0; j < vertLen; j++) {
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3];
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 2];
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 1];
                    }

                    subGeom = new TriangleSubGeometry(true);

                    if (this._firstSubGeom == null)
                        this._firstSubGeom = subGeom;

                    geometry = new Geometry();
                    geometry.addSubGeometry(subGeom);

                    subGeom.updateIndices(this._indices);
                    subGeom.updatePositions(fvertices);
                    subGeom.updateUVs(this._finalUV);
                    subGeom.vertexNormals;
                    subGeom.vertexTangents;
                    subGeom.autoDeriveNormals = false;
                    subGeom.autoDeriveTangents = false;

                    var clip = this._clipNodes[name];

                    if (!clip) {
                        // If another sequence was parsed before this one, starting
                        // a new state means the previous one is complete and can
                        // hence be finalized.
                        if (prevClip) {
                            this._pFinalizeAsset(prevClip);
                            this._animationSet.addAnimation(prevClip);
                        }

                        clip = new VertexClipNode();
                        clip.name = name;
                        clip.stitchFinalFrame = true;

                        this._clipNodes[name] = clip;

                        prevClip = clip;
                    }
                    clip.addFrame(geometry, 1000 / away.parsers.MD2Parser.FPS);
                }

                // Finalize the last state
                if (prevClip) {
                    this._pFinalizeAsset(prevClip);
                    this._animationSet.addAnimation(prevClip);
                }

                // Force this._pFinalizeAsset() to decide name
                this._pFinalizeAsset(this._animationSet);

                this._parsedFrames = true;
            };

            MD2Parser.prototype.readFrameName = function () {
                var name = "";
                var k = 0;
                for (var j = 0; j < 16; j++) {
                    var ch = this._byteData.readUnsignedByte();

                    if (Math.floor(ch) > 0x39 && Math.floor(ch) <= 0x7A && k == 0)
                        name += String.fromCharCode(ch);

                    if (Math.floor(ch) >= 0x30 && Math.floor(ch) <= 0x39)
                        k++;
                }
                return name;
            };
            MD2Parser.FPS = 6;
            return MD2Parser;
        })(parsers.ParserBase);
        parsers.MD2Parser = MD2Parser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (parsers) {
        var JointPose = away.animators.JointPose;
        var SkeletonPose = away.animators.SkeletonPose;
        var SkeletonClipNode = away.animators.SkeletonClipNode;
        var Quaternion = away.geom.Quaternion;
        var Vector3D = away.geom.Vector3D;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        /**
        * MD5AnimParser provides a parser for the md5anim data type, providing an animation sequence for the md5 format.
        *
        * todo: optimize
        */
        var MD5AnimParser = (function (_super) {
            __extends(MD5AnimParser, _super);
            /**
            * Creates a new MD5AnimParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function MD5AnimParser(additionalRotationAxis, additionalRotationRadians) {
                if (typeof additionalRotationAxis === "undefined") { additionalRotationAxis = null; }
                if (typeof additionalRotationRadians === "undefined") { additionalRotationRadians = 0; }
                _super.call(this, URLLoaderDataFormat.TEXT);
                this._parseIndex = 0;
                this._line = 0;
                this._charLineIndex = 0;
                this._rotationQuat = new Quaternion();
                var t1 = new Quaternion();
                var t2 = new Quaternion();

                t1.fromAxisAngle(Vector3D.X_AXIS, -Math.PI * .5);
                t2.fromAxisAngle(Vector3D.Y_AXIS, -Math.PI * .5);

                this._rotationQuat.multiply(t2, t1);

                if (additionalRotationAxis) {
                    this._rotationQuat.multiply(t2, t1);
                    t1.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
                    this._rotationQuat.multiply(t1, this._rotationQuat);
                }
            }
            /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            MD5AnimParser.supportsType = function (extension) {
                extension = extension.toLowerCase();
                return extension == "md5anim";
            };

            /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            MD5AnimParser.supportsData = function (data) {
                return false;
            };

            /**
            * @inheritDoc
            */
            MD5AnimParser.prototype._pProceedParsing = function () {
                var token;

                if (!this._startedParsing) {
                    this._textData = this._pGetTextData();
                    this._startedParsing = true;
                }

                while (this._pHasTime()) {
                    token = this.getNextToken();
                    switch (token) {
                        case MD5AnimParser.COMMENT_TOKEN:
                            this.ignoreLine();
                            break;
                        case "":
                            break;
                        case MD5AnimParser.VERSION_TOKEN:
                            this._version = this.getNextInt();
                            if (this._version != 10)
                                throw new Error("Unknown version number encountered!");
                            break;
                        case MD5AnimParser.COMMAND_LINE_TOKEN:
                            this.parseCMD();
                            break;
                        case MD5AnimParser.NUM_FRAMES_TOKEN:
                            this._numFrames = this.getNextInt();
                            this._bounds = new Array();
                            this._frameData = new Array();
                            break;
                        case MD5AnimParser.NUM_JOINTS_TOKEN:
                            this._numJoints = this.getNextInt();
                            this._hierarchy = new Array(this._numJoints);
                            this._baseFrameData = new Array(this._numJoints);
                            break;
                        case MD5AnimParser.FRAME_RATE_TOKEN:
                            this._frameRate = this.getNextInt();
                            break;
                        case MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN:
                            this._numAnimatedComponents = this.getNextInt();
                            break;
                        case MD5AnimParser.HIERARCHY_TOKEN:
                            this.parseHierarchy();
                            break;
                        case MD5AnimParser.BOUNDS_TOKEN:
                            this.parseBounds();
                            break;
                        case MD5AnimParser.BASE_FRAME_TOKEN:
                            this.parseBaseFrame();
                            break;
                        case MD5AnimParser.FRAME_TOKEN:
                            this.parseFrame();
                            break;
                        default:
                            if (!this._reachedEOF)
                                this.sendUnknownKeywordError();
                    }

                    if (this._reachedEOF) {
                        this._clip = new SkeletonClipNode();
                        this.translateClip();
                        this._pFinalizeAsset(this._clip);
                        return parsers.ParserBase.PARSING_DONE;
                    }
                }
                return parsers.ParserBase.MORE_TO_PARSE;
            };

            /**
            * Converts all key frame data to an SkinnedAnimationSequence.
            */
            MD5AnimParser.prototype.translateClip = function () {
                for (var i = 0; i < this._numFrames; ++i)
                    this._clip.addFrame(this.translatePose(this._frameData[i]), 1000 / this._frameRate);
            };

            /**
            * Converts a single key frame data to a SkeletonPose.
            * @param frameData The actual frame data.
            * @return A SkeletonPose containing the frame data's pose.
            */
            MD5AnimParser.prototype.translatePose = function (frameData) {
                var hierarchy;
                var pose;
                var base;
                var flags;
                var j;
                var translate = new Vector3D();
                var orientation = new Quaternion();
                var components = frameData.components;
                var skelPose = new SkeletonPose();
                var jointPoses = skelPose.jointPoses;

                for (var i = 0; i < this._numJoints; ++i) {
                    j = 0;
                    pose = new JointPose();
                    hierarchy = this._hierarchy[i];
                    base = this._baseFrameData[i];
                    flags = hierarchy.flags;
                    translate.x = base.position.x;
                    translate.y = base.position.y;
                    translate.z = base.position.z;
                    orientation.x = base.orientation.x;
                    orientation.y = base.orientation.y;
                    orientation.z = base.orientation.z;

                    if (flags & 1)
                        translate.x = components[hierarchy.startIndex + (j++)];
                    if (flags & 2)
                        translate.y = components[hierarchy.startIndex + (j++)];
                    if (flags & 4)
                        translate.z = components[hierarchy.startIndex + (j++)];
                    if (flags & 8)
                        orientation.x = components[hierarchy.startIndex + (j++)];
                    if (flags & 16)
                        orientation.y = components[hierarchy.startIndex + (j++)];
                    if (flags & 32)
                        orientation.z = components[hierarchy.startIndex + (j++)];

                    var w = 1 - orientation.x * orientation.x - orientation.y * orientation.y - orientation.z * orientation.z;
                    orientation.w = w < 0 ? 0 : -Math.sqrt(w);

                    if (hierarchy.parentIndex < 0) {
                        pose.orientation.multiply(this._rotationQuat, orientation);
                        pose.translation = this._rotationQuat.rotatePoint(translate);
                    } else {
                        pose.orientation.copyFrom(orientation);
                        pose.translation.x = translate.x;
                        pose.translation.y = translate.y;
                        pose.translation.z = translate.z;
                    }
                    pose.orientation.y = -pose.orientation.y;
                    pose.orientation.z = -pose.orientation.z;
                    pose.translation.x = -pose.translation.x;

                    jointPoses[i] = pose;
                }

                return skelPose;
            };

            /**
            * Parses the skeleton's hierarchy data.
            */
            MD5AnimParser.prototype.parseHierarchy = function () {
                var ch;
                var data;
                var token = this.getNextToken();
                var i = 0;

                if (token != "{")
                    this.sendUnknownKeywordError();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    data = new HierarchyData();
                    data.name = this.parseLiteralstring();
                    data.parentIndex = this.getNextInt();
                    data.flags = this.getNextInt();
                    data.startIndex = this.getNextInt();
                    this._hierarchy[i++] = data;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5AnimParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Parses frame bounds.
            */
            MD5AnimParser.prototype.parseBounds = function () {
                var ch;
                var data;
                var token = this.getNextToken();
                var i = 0;

                if (token != "{")
                    this.sendUnknownKeywordError();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    data = new BoundsData();
                    data.min = this.parseVector3D();
                    data.max = this.parseVector3D();
                    this._bounds[i++] = data;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5AnimParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Parses the base frame.
            */
            MD5AnimParser.prototype.parseBaseFrame = function () {
                var ch;
                var data;
                var token = this.getNextToken();
                var i = 0;

                if (token != "{")
                    this.sendUnknownKeywordError();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    data = new BaseFrameData();
                    data.position = this.parseVector3D();
                    data.orientation = this.parseQuaternion();
                    this._baseFrameData[i++] = data;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5AnimParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Parses a single frame.
            */
            MD5AnimParser.prototype.parseFrame = function () {
                var ch;
                var data;
                var token;
                var frameIndex;

                frameIndex = this.getNextInt();

                token = this.getNextToken();
                if (token != "{")
                    this.sendUnknownKeywordError();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    data = new FrameData();
                    data.components = new Array(this._numAnimatedComponents);

                    for (var i = 0; i < this._numAnimatedComponents; ++i)
                        data.components[i] = this.getNextNumber();

                    this._frameData[frameIndex] = data;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5AnimParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Puts back the last read character into the data stream.
            */
            MD5AnimParser.prototype.putBack = function () {
                this._parseIndex--;
                this._charLineIndex--;
                this._reachedEOF = this._parseIndex >= this._textData.length;
            };

            /**
            * Gets the next token in the data stream.
            */
            MD5AnimParser.prototype.getNextToken = function () {
                var ch;
                var token = "";

                while (!this._reachedEOF) {
                    ch = this.getNextChar();
                    if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                        if (token != MD5AnimParser.COMMENT_TOKEN)
                            this.skipWhiteSpace();
                        if (token != "")
                            return token;
                    } else
                        token += ch;

                    if (token == MD5AnimParser.COMMENT_TOKEN)
                        return token;
                }

                return token;
            };

            /**
            * Skips all whitespace in the data stream.
            */
            MD5AnimParser.prototype.skipWhiteSpace = function () {
                var ch;

                do
                    ch = this.getNextChar(); while(ch == "\n" || ch == " " || ch == "\r" || ch == "\t");

                this.putBack();
            };

            /**
            * Skips to the next line.
            */
            MD5AnimParser.prototype.ignoreLine = function () {
                var ch;
                while (!this._reachedEOF && ch != "\n")
                    ch = this.getNextChar();
            };

            /**
            * Retrieves the next single character in the data stream.
            */
            MD5AnimParser.prototype.getNextChar = function () {
                var ch = this._textData.charAt(this._parseIndex++);

                if (ch == "\n") {
                    ++this._line;
                    this._charLineIndex = 0;
                } else if (ch != "\r")
                    ++this._charLineIndex;

                if (this._parseIndex == this._textData.length)
                    this._reachedEOF = true;

                return ch;
            };

            /**
            * Retrieves the next integer in the data stream.
            */
            MD5AnimParser.prototype.getNextInt = function () {
                var i = parseInt(this.getNextToken());
                if (isNaN(i))
                    this.sendParseError("int type");
                return i;
            };

            /**
            * Retrieves the next floating point number in the data stream.
            */
            MD5AnimParser.prototype.getNextNumber = function () {
                var f = parseFloat(this.getNextToken());
                if (isNaN(f))
                    this.sendParseError("float type");
                return f;
            };

            /**
            * Retrieves the next 3d vector in the data stream.
            */
            MD5AnimParser.prototype.parseVector3D = function () {
                var vec = new Vector3D();
                var ch = this.getNextToken();

                if (ch != "(")
                    this.sendParseError("(");
                vec.x = this.getNextNumber();
                vec.y = this.getNextNumber();
                vec.z = this.getNextNumber();

                if (this.getNextToken() != ")")
                    this.sendParseError(")");

                return vec;
            };

            /**
            * Retrieves the next quaternion in the data stream.
            */
            MD5AnimParser.prototype.parseQuaternion = function () {
                var quat = new Quaternion();
                var ch = this.getNextToken();

                if (ch != "(")
                    this.sendParseError("(");
                quat.x = this.getNextNumber();
                quat.y = this.getNextNumber();
                quat.z = this.getNextNumber();

                // quat supposed to be unit length
                var t = 1 - (quat.x * quat.x) - (quat.y * quat.y) - (quat.z * quat.z);
                quat.w = t < 0 ? 0 : -Math.sqrt(t);

                if (this.getNextToken() != ")")
                    this.sendParseError(")");

                return quat;
            };

            /**
            * Parses the command line data.
            */
            MD5AnimParser.prototype.parseCMD = function () {
                // just ignore the command line property
                this.parseLiteralstring();
            };

            /**
            * Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
            * by double quotes.
            */
            MD5AnimParser.prototype.parseLiteralstring = function () {
                this.skipWhiteSpace();

                var ch = this.getNextChar();
                var str = "";

                if (ch != "\"")
                    this.sendParseError("\"");

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    ch = this.getNextChar();
                    if (ch != "\"")
                        str += ch;
                } while(ch != "\"");

                return str;
            };

            /**
            * Throws an end-of-file error when a premature end of file was encountered.
            */
            MD5AnimParser.prototype.sendEOFError = function () {
                throw new Error("Unexpected end of file");
            };

            /**
            * Throws an error when an unexpected token was encountered.
            * @param expected The token type that was actually expected.
            */
            MD5AnimParser.prototype.sendParseError = function (expected) {
                throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
            };

            /**
            * Throws an error when an unknown keyword was encountered.
            */
            MD5AnimParser.prototype.sendUnknownKeywordError = function () {
                throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
            };
            MD5AnimParser.VERSION_TOKEN = "MD5Version";
            MD5AnimParser.COMMAND_LINE_TOKEN = "commandline";
            MD5AnimParser.NUM_FRAMES_TOKEN = "numFrames";
            MD5AnimParser.NUM_JOINTS_TOKEN = "numJoints";
            MD5AnimParser.FRAME_RATE_TOKEN = "frameRate";
            MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN = "numAnimatedComponents";

            MD5AnimParser.HIERARCHY_TOKEN = "hierarchy";
            MD5AnimParser.BOUNDS_TOKEN = "bounds";
            MD5AnimParser.BASE_FRAME_TOKEN = "baseframe";
            MD5AnimParser.FRAME_TOKEN = "frame";

            MD5AnimParser.COMMENT_TOKEN = "//";
            return MD5AnimParser;
        })(parsers.ParserBase);
        parsers.MD5AnimParser = MD5AnimParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

// value objects
var HierarchyData = (function () {
    function HierarchyData() {
    }
    HierarchyData.prototype.HierarchyData = function () {
    };
    return HierarchyData;
})();

var BoundsData = (function () {
    function BoundsData() {
    }
    BoundsData.prototype.BoundsData = function () {
    };
    return BoundsData;
})();

var BaseFrameData = (function () {
    function BaseFrameData() {
    }
    BaseFrameData.prototype.BaseFrameData = function () {
    };
    return BaseFrameData;
})();

var FrameData = (function () {
    function FrameData() {
    }
    FrameData.prototype.FrameData = function () {
    };
    return FrameData;
})();
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (parsers) {
        var SkeletonAnimationSet = away.animators.SkeletonAnimationSet;
        var Skeleton = away.animators.Skeleton;
        var SkeletonJoint = away.animators.SkeletonJoint;
        var Geometry = away.base.Geometry;
        var TriangleSubGeometry = away.base.TriangleSubGeometry;

        var Quaternion = away.geom.Quaternion;
        var Vector3D = away.geom.Vector3D;
        var Mesh = away.entities.Mesh;
        var URLLoaderDataFormat = away.net.URLLoaderDataFormat;

        // todo: create animation system, parse skeleton
        /**
        * MD5MeshParser provides a parser for the md5mesh data type, providing the geometry of the md5 format.
        *
        * todo: optimize
        */
        var MD5MeshParser = (function (_super) {
            __extends(MD5MeshParser, _super);
            /**
            * Creates a new MD5MeshParser object.
            */
            function MD5MeshParser(additionalRotationAxis, additionalRotationRadians) {
                if (typeof additionalRotationAxis === "undefined") { additionalRotationAxis = null; }
                if (typeof additionalRotationRadians === "undefined") { additionalRotationRadians = 0; }
                _super.call(this, URLLoaderDataFormat.TEXT);
                this._parseIndex = 0;
                this._line = 0;
                this._charLineIndex = 0;
                this._rotationQuat = new Quaternion();

                this._rotationQuat.fromAxisAngle(Vector3D.X_AXIS, -Math.PI * .5);

                if (additionalRotationAxis) {
                    var quat = new Quaternion();
                    quat.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
                    this._rotationQuat.multiply(this._rotationQuat, quat);
                }
            }
            /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            MD5MeshParser.supportsType = function (extension) {
                extension = extension.toLowerCase();
                return extension == "md5mesh";
            };

            /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            MD5MeshParser.supportsData = function (data) {
                return false;
            };

            /**
            * @inheritDoc
            */
            MD5MeshParser.prototype._pProceedParsing = function () {
                var token;

                if (!this._startedParsing) {
                    this._textData = this._pGetTextData();
                    this._startedParsing = true;
                }

                while (this._pHasTime()) {
                    token = this.getNextToken();
                    switch (token) {
                        case MD5MeshParser.COMMENT_TOKEN:
                            this.ignoreLine();
                            break;
                        case MD5MeshParser.VERSION_TOKEN:
                            this._version = this.getNextInt();
                            if (this._version != 10)
                                throw new Error("Unknown version number encountered!");
                            break;
                        case MD5MeshParser.COMMAND_LINE_TOKEN:
                            this.parseCMD();
                            break;
                        case MD5MeshParser.NUM_JOINTS_TOKEN:
                            this._numJoints = this.getNextInt();
                            this._bindPoses = new Array(this._numJoints);
                            break;
                        case MD5MeshParser.NUM_MESHES_TOKEN:
                            this._numMeshes = this.getNextInt();
                            break;
                        case MD5MeshParser.JOINTS_TOKEN:
                            this.parseJoints();
                            break;
                        case MD5MeshParser.MESH_TOKEN:
                            this.parseMesh();
                            break;
                        default:
                            if (!this._reachedEOF)
                                this.sendUnknownKeywordError();
                    }

                    if (this._reachedEOF) {
                        this.calculateMaxJointCount();
                        this._animationSet = new SkeletonAnimationSet(this._maxJointCount);

                        this._mesh = new Mesh(new Geometry(), null);
                        this._geometry = this._mesh.geometry;

                        for (var i = 0; i < this._meshData.length; ++i)
                            this._geometry.addSubGeometry(this.translateGeom(this._meshData[i].vertexData, this._meshData[i].weightData, this._meshData[i].indices));

                        //_geometry.animation = _animation;
                        //					_mesh.animationController = _animationController;
                        //add to the content property
                        this._pContent.addChild(this._mesh);

                        this._pFinalizeAsset(this._geometry);
                        this._pFinalizeAsset(this._mesh);
                        this._pFinalizeAsset(this._skeleton);
                        this._pFinalizeAsset(this._animationSet);
                        return parsers.ParserBase.PARSING_DONE;
                    }
                }
                return parsers.ParserBase.MORE_TO_PARSE;
            };

            MD5MeshParser.prototype._pStartParsing = function (frameLimit) {
                _super.prototype._pStartParsing.call(this, frameLimit);

                //create a content object for Loaders
                this._pContent = new away.containers.DisplayObjectContainer();
            };

            MD5MeshParser.prototype.calculateMaxJointCount = function () {
                this._maxJointCount = 0;

                var numMeshData = this._meshData.length;
                for (var i = 0; i < numMeshData; ++i) {
                    var meshData = this._meshData[i];
                    var vertexData = meshData.vertexData;
                    var numVerts = vertexData.length;

                    for (var j = 0; j < numVerts; ++j) {
                        var zeroWeights = this.countZeroWeightJoints(vertexData[j], meshData.weightData);
                        var totalJoints = vertexData[j].countWeight - zeroWeights;
                        if (totalJoints > this._maxJointCount)
                            this._maxJointCount = totalJoints;
                    }
                }
            };

            MD5MeshParser.prototype.countZeroWeightJoints = function (vertex, weights) {
                var start = vertex.startWeight;
                var end = vertex.startWeight + vertex.countWeight;
                var count = 0;
                var weight;

                for (var i = start; i < end; ++i) {
                    weight = weights[i].bias;
                    if (weight == 0)
                        ++count;
                }

                return count;
            };

            /**
            * Parses the skeleton's joints.
            */
            MD5MeshParser.prototype.parseJoints = function () {
                var ch;
                var joint;
                var pos;
                var quat;
                var i = 0;
                var token = this.getNextToken();

                if (token != "{")
                    this.sendUnknownKeywordError();

                this._skeleton = new Skeleton();

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    joint = new SkeletonJoint();
                    joint.name = this.parseLiteralstring();
                    joint.parentIndex = this.getNextInt();
                    pos = this.parseVector3D();
                    pos = this._rotationQuat.rotatePoint(pos);
                    quat = this.parseQuaternion();

                    // todo: check if this is correct, or maybe we want to actually store it as quats?
                    this._bindPoses[i] = quat.toMatrix3D();
                    this._bindPoses[i].appendTranslation(pos.x, pos.y, pos.z);
                    var inv = this._bindPoses[i].clone();
                    inv.invert();
                    joint.inverseBindPose = inv.rawData;

                    this._skeleton.joints[i++] = joint;

                    ch = this.getNextChar();

                    if (ch == "/") {
                        this.putBack();
                        ch = this.getNextToken();
                        if (ch == MD5MeshParser.COMMENT_TOKEN)
                            this.ignoreLine();
                        ch = this.getNextChar();
                    }

                    if (ch != "}")
                        this.putBack();
                } while(ch != "}");
            };

            /**
            * Puts back the last read character into the data stream.
            */
            MD5MeshParser.prototype.putBack = function () {
                this._parseIndex--;
                this._charLineIndex--;
                this._reachedEOF = this._parseIndex >= this._textData.length;
            };

            /**
            * Parses the mesh geometry.
            */
            MD5MeshParser.prototype.parseMesh = function () {
                var token = this.getNextToken();
                var ch;
                var vertexData;
                var weights;
                var indices;

                if (token != "{")
                    this.sendUnknownKeywordError();

                if (this._shaders == null)
                    this._shaders = new Array();

                while (ch != "}") {
                    ch = this.getNextToken();
                    switch (ch) {
                        case MD5MeshParser.COMMENT_TOKEN:
                            this.ignoreLine();
                            break;
                        case MD5MeshParser.MESH_SHADER_TOKEN:
                            this._shaders.push(this.parseLiteralstring());
                            break;
                        case MD5MeshParser.MESH_NUM_VERTS_TOKEN:
                            vertexData = new Array(this.getNextInt());
                            break;
                        case MD5MeshParser.MESH_NUM_TRIS_TOKEN:
                            indices = new Array(this.getNextInt() * 3);
                            break;
                        case MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN:
                            weights = new Array(this.getNextInt());
                            break;
                        case MD5MeshParser.MESH_VERT_TOKEN:
                            this.parseVertex(vertexData);
                            break;
                        case MD5MeshParser.MESH_TRI_TOKEN:
                            this.parseTri(indices);
                            break;
                        case MD5MeshParser.MESH_WEIGHT_TOKEN:
                            this.parseJoint(weights);
                            break;
                    }
                }

                if (this._meshData == null)
                    this._meshData = new Array();

                var i = this._meshData.length;
                this._meshData[i] = new MeshData();
                this._meshData[i].vertexData = vertexData;
                this._meshData[i].weightData = weights;
                this._meshData[i].indices = indices;
            };

            /**
            * Converts the mesh data to a SkinnedSub instance.
            * @param vertexData The mesh's vertices.
            * @param weights The joint weights per vertex.
            * @param indices The indices for the faces.
            * @return A SubGeometry instance containing all geometrical data for the current mesh.
            */
            MD5MeshParser.prototype.translateGeom = function (vertexData, weights, indices /*uint*/ ) {
                var len = vertexData.length;
                var v1, v2, v3;
                var vertex;
                var weight;
                var bindPose;
                var pos;
                var subGeom = new TriangleSubGeometry(true);
                var uvs = new Array(len * 2);
                var vertices = new Array(len * 3);
                var jointIndices = new Array(len * this._maxJointCount);
                var jointWeights = new Array(len * this._maxJointCount);
                var l = 0;
                var nonZeroWeights;

                for (var i = 0; i < len; ++i) {
                    vertex = vertexData[i];
                    v1 = vertex.index * 3;
                    v2 = v1 + 1;
                    v3 = v1 + 2;
                    vertices[v1] = vertices[v2] = vertices[v3] = 0;

                    nonZeroWeights = 0;
                    for (var j = 0; j < vertex.countWeight; ++j) {
                        weight = weights[vertex.startWeight + j];
                        if (weight.bias > 0) {
                            bindPose = this._bindPoses[weight.joint];
                            pos = bindPose.transformVector(weight.pos);
                            vertices[v1] += pos.x * weight.bias;
                            vertices[v2] += pos.y * weight.bias;
                            vertices[v3] += pos.z * weight.bias;

                            // indices need to be multiplied by 3 (amount of matrix registers)
                            jointIndices[l] = weight.joint * 3;
                            jointWeights[l++] = weight.bias;
                            ++nonZeroWeights;
                        }
                    }

                    for (j = nonZeroWeights; j < this._maxJointCount; ++j) {
                        jointIndices[l] = 0;
                        jointWeights[l++] = 0;
                    }

                    v1 = vertex.index << 1;
                    uvs[v1++] = vertex.s;
                    uvs[v1] = vertex.t;
                }

                subGeom.jointsPerVertex = this._maxJointCount;
                subGeom.updateIndices(indices);
                subGeom.updatePositions(vertices);
                subGeom.updateUVs(uvs);
                subGeom.updateJointIndices(jointIndices);
                subGeom.updateJointWeights(jointWeights);

                // cause explicit updates
                subGeom.vertexNormals;
                subGeom.vertexTangents;

                // turn auto updates off because they may be animated and set explicitly
                subGeom.autoDeriveTangents = false;
                subGeom.autoDeriveNormals = false;

                return subGeom;
            };

            /**
            * Retrieve the next triplet of vertex indices that form a face.
            * @param indices The index list in which to store the read data.
            */
            MD5MeshParser.prototype.parseTri = function (indices /*uint*/ ) {
                var index = this.getNextInt() * 3;
                indices[index] = this.getNextInt();
                indices[index + 1] = this.getNextInt();
                indices[index + 2] = this.getNextInt();
            };

            /**
            * Reads a new joint data set for a single joint.
            * @param weights the target list to contain the weight data.
            */
            MD5MeshParser.prototype.parseJoint = function (weights) {
                var weight = new JointData();
                weight.index = this.getNextInt();
                weight.joint = this.getNextInt();
                weight.bias = this.getNextNumber();
                weight.pos = this.parseVector3D();
                weights[weight.index] = weight;
            };

            /**
            * Reads the data for a single vertex.
            * @param vertexData The list to contain the vertex data.
            */
            MD5MeshParser.prototype.parseVertex = function (vertexData) {
                var vertex = new VertexData();
                vertex.index = this.getNextInt();
                this.parseUV(vertex);
                vertex.startWeight = this.getNextInt();
                vertex.countWeight = this.getNextInt();

                //			if (vertex.countWeight > _maxJointCount) _maxJointCount = vertex.countWeight;
                vertexData[vertex.index] = vertex;
            };

            /**
            * Reads the next uv coordinate.
            * @param vertexData The vertexData to contain the UV coordinates.
            */
            MD5MeshParser.prototype.parseUV = function (vertexData) {
                var ch = this.getNextToken();
                if (ch != "(")
                    this.sendParseError("(");
                vertexData.s = this.getNextNumber();
                vertexData.t = this.getNextNumber();

                if (this.getNextToken() != ")")
                    this.sendParseError(")");
            };

            /**
            * Gets the next token in the data stream.
            */
            MD5MeshParser.prototype.getNextToken = function () {
                var ch;
                var token = "";

                while (!this._reachedEOF) {
                    ch = this.getNextChar();
                    if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                        if (token != MD5MeshParser.COMMENT_TOKEN)
                            this.skipWhiteSpace();
                        if (token != "")
                            return token;
                    } else
                        token += ch;

                    if (token == MD5MeshParser.COMMENT_TOKEN)
                        return token;
                }

                return token;
            };

            /**
            * Skips all whitespace in the data stream.
            */
            MD5MeshParser.prototype.skipWhiteSpace = function () {
                var ch;

                do
                    ch = this.getNextChar(); while(ch == "\n" || ch == " " || ch == "\r" || ch == "\t");

                this.putBack();
            };

            /**
            * Skips to the next line.
            */
            MD5MeshParser.prototype.ignoreLine = function () {
                var ch;
                while (!this._reachedEOF && ch != "\n")
                    ch = this.getNextChar();
            };

            /**
            * Retrieves the next single character in the data stream.
            */
            MD5MeshParser.prototype.getNextChar = function () {
                var ch = this._textData.charAt(this._parseIndex++);

                if (ch == "\n") {
                    ++this._line;
                    this._charLineIndex = 0;
                } else if (ch != "\r")
                    ++this._charLineIndex;

                if (this._parseIndex >= this._textData.length)
                    this._reachedEOF = true;

                return ch;
            };

            /**
            * Retrieves the next integer in the data stream.
            */
            MD5MeshParser.prototype.getNextInt = function () {
                var i = parseInt(this.getNextToken());
                if (isNaN(i))
                    this.sendParseError("int type");
                return i;
            };

            /**
            * Retrieves the next floating point number in the data stream.
            */
            MD5MeshParser.prototype.getNextNumber = function () {
                var f = parseFloat(this.getNextToken());
                if (isNaN(f))
                    this.sendParseError("float type");
                return f;
            };

            /**
            * Retrieves the next 3d vector in the data stream.
            */
            MD5MeshParser.prototype.parseVector3D = function () {
                var vec = new Vector3D();
                var ch = this.getNextToken();

                if (ch != "(")
                    this.sendParseError("(");
                vec.x = -this.getNextNumber();
                vec.y = this.getNextNumber();
                vec.z = this.getNextNumber();

                if (this.getNextToken() != ")")
                    this.sendParseError(")");

                return vec;
            };

            /**
            * Retrieves the next quaternion in the data stream.
            */
            MD5MeshParser.prototype.parseQuaternion = function () {
                var quat = new Quaternion();
                var ch = this.getNextToken();

                if (ch != "(")
                    this.sendParseError("(");
                quat.x = this.getNextNumber();
                quat.y = -this.getNextNumber();
                quat.z = -this.getNextNumber();

                // quat supposed to be unit length
                var t = 1 - quat.x * quat.x - quat.y * quat.y - quat.z * quat.z;
                quat.w = t < 0 ? 0 : -Math.sqrt(t);

                if (this.getNextToken() != ")")
                    this.sendParseError(")");

                var rotQuat = new Quaternion();
                rotQuat.multiply(this._rotationQuat, quat);
                return rotQuat;
            };

            /**
            * Parses the command line data.
            */
            MD5MeshParser.prototype.parseCMD = function () {
                // just ignore the command line property
                this.parseLiteralstring();
            };

            /**
            * Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
            * by double quotes.
            */
            MD5MeshParser.prototype.parseLiteralstring = function () {
                this.skipWhiteSpace();

                var ch = this.getNextChar();
                var str = "";

                if (ch != "\"")
                    this.sendParseError("\"");

                do {
                    if (this._reachedEOF)
                        this.sendEOFError();
                    ch = this.getNextChar();
                    if (ch != "\"")
                        str += ch;
                } while(ch != "\"");

                return str;
            };

            /**
            * Throws an end-of-file error when a premature end of file was encountered.
            */
            MD5MeshParser.prototype.sendEOFError = function () {
                throw new Error("Unexpected end of file");
            };

            /**
            * Throws an error when an unexpected token was encountered.
            * @param expected The token type that was actually expected.
            */
            MD5MeshParser.prototype.sendParseError = function (expected) {
                throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
            };

            /**
            * Throws an error when an unknown keyword was encountered.
            */
            MD5MeshParser.prototype.sendUnknownKeywordError = function () {
                throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
            };
            MD5MeshParser.VERSION_TOKEN = "MD5Version";
            MD5MeshParser.COMMAND_LINE_TOKEN = "commandline";
            MD5MeshParser.NUM_JOINTS_TOKEN = "numJoints";
            MD5MeshParser.NUM_MESHES_TOKEN = "numMeshes";
            MD5MeshParser.COMMENT_TOKEN = "//";
            MD5MeshParser.JOINTS_TOKEN = "joints";
            MD5MeshParser.MESH_TOKEN = "mesh";

            MD5MeshParser.MESH_SHADER_TOKEN = "shader";
            MD5MeshParser.MESH_NUM_VERTS_TOKEN = "numverts";
            MD5MeshParser.MESH_VERT_TOKEN = "vert";
            MD5MeshParser.MESH_NUM_TRIS_TOKEN = "numtris";
            MD5MeshParser.MESH_TRI_TOKEN = "tri";
            MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN = "numweights";
            MD5MeshParser.MESH_WEIGHT_TOKEN = "weight";
            return MD5MeshParser;
        })(parsers.ParserBase);
        parsers.MD5MeshParser = MD5MeshParser;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));

var VertexData = (function () {
    function VertexData() {
    }
    return VertexData;
})();

var JointData = (function () {
    function JointData() {
    }
    return JointData;
})();

var MeshData = (function () {
    function MeshData() {
    }
    return MeshData;
})();
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    (function (parsers) {
        var Parsers = (function () {
            function Parsers() {
            }
            /**
            * Short-hand function to enable all bundled parsers for auto-detection. In practice,
            * this is the same as invoking enableParsers(Parsers.ALL_BUNDLED) on any of the
            * loader classes SingleFileLoader, AssetLoader, AssetLibrary or Loader3D.
            *
            * See notes about file size in the documentation for the ALL_BUNDLED constant.
            *
            * @see away.parsers.parsers.Parsers.ALL_BUNDLED
            */
            Parsers.enableAllBundled = function () {
                away.net.AssetLoader.enableParsers(this.ALL_BUNDLED);
            };
            Parsers.ALL_BUNDLED = Array(away.parsers.AWDParser, away.parsers.Max3DSParser, away.parsers.MD2Parser, away.parsers.OBJParser);
            return Parsers;
        })();
        parsers.Parsers = Parsers;
    })(away.parsers || (away.parsers = {}));
    var parsers = away.parsers;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (commands) {
        var Geometry = away.base.Geometry;
        var TriangleSubGeometry = away.base.TriangleSubGeometry;
        var Matrix3DUtils = away.geom.Matrix3DUtils;
        var Mesh = away.entities.Mesh;

        /**
        *  Class Merge merges two or more static meshes into one.<code>Merge</code>
        */
        var Merge = (function () {
            /**
            * @param    keepMaterial    [optional]    Determines if the merged object uses the recevier mesh material information or keeps its source material(s). Defaults to false.
            * If false and receiver object has multiple materials, the last material found in receiver submeshes is applied to the merged submesh(es).
            * @param    disposeSources  [optional]    Determines if the mesh and geometry source(s) used for the merging are disposed. Defaults to false.
            * If true, only receiver geometry and resulting mesh are kept in  memory.
            * @param    objectSpace     [optional]    Determines if source mesh(es) is/are merged using objectSpace or worldspace. Defaults to false.
            */
            function Merge(keepMaterial, disposeSources, objectSpace) {
                if (typeof keepMaterial === "undefined") { keepMaterial = false; }
                if (typeof disposeSources === "undefined") { disposeSources = false; }
                if (typeof objectSpace === "undefined") { objectSpace = false; }
                this._keepMaterial = keepMaterial;
                this._disposeSources = disposeSources;
                this._objectSpace = objectSpace;
            }

            Object.defineProperty(Merge.prototype, "disposeSources", {
                get: function () {
                    return this._disposeSources;
                },
                /**
                * Determines if the mesh and geometry source(s) used for the merging are disposed. Defaults to false.
                */
                set: function (b) {
                    this._disposeSources = b;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Merge.prototype, "keepMaterial", {
                get: function () {
                    return this._keepMaterial;
                },
                /**
                * Determines if the material source(s) used for the merging are disposed. Defaults to false.
                */
                set: function (b) {
                    this._keepMaterial = b;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Merge.prototype, "objectSpace", {
                get: function () {
                    return this._objectSpace;
                },
                /**
                * Determines if source mesh(es) is/are merged using objectSpace or worldspace. Defaults to false.
                */
                set: function (b) {
                    this._objectSpace = b;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Merges all the children of a container into a single Mesh. If no Mesh object is found, method returns the receiver without modification.
            *
            * @param    receiver           The Mesh to receive the merged contents of the container.
            * @param    objectContainer    The DisplayObjectContainer holding the meshes to be mergd.
            *
            * @return The merged Mesh instance.
            */
            Merge.prototype.applyToContainer = function (receiver, objectContainer) {
                this.reset();

                //collect container meshes
                this.parseContainer(receiver, objectContainer);

                //collect receiver
                this.collect(receiver, false);

                //merge to receiver
                this.merge(receiver, this._disposeSources);
            };

            /**
            * Merges all the meshes found in the Array&lt;Mesh&gt; into a single Mesh.
            *
            * @param    receiver    The Mesh to receive the merged contents of the meshes.
            * @param    meshes      A series of Meshes to be merged with the reciever mesh.
            */
            Merge.prototype.applyToMeshes = function (receiver, meshes) {
                this.reset();

                if (!meshes.length)
                    return;

                for (var i = 0; i < meshes.length; i++)
                    if (meshes[i] != receiver)
                        this.collect(meshes[i], this._disposeSources);

                //collect receiver
                this.collect(receiver, false);

                //merge to receiver
                this.merge(receiver, this._disposeSources);
            };

            /**
            *  Merges 2 meshes into one. It is recommand to use apply when 2 meshes are to be merged. If more need to be merged, use either applyToMeshes or applyToContainer methods.
            *
            * @param    receiver    The Mesh to receive the merged contents of both meshes.
            * @param    mesh        The Mesh to be merged with the receiver mesh
            */
            Merge.prototype.apply = function (receiver, mesh) {
                this.reset();

                //collect mesh
                this.collect(mesh, this._disposeSources);

                //collect receiver
                this.collect(receiver, false);

                //merge to receiver
                this.merge(receiver, this._disposeSources);
            };

            Merge.prototype.reset = function () {
                this._toDispose = new Array();
                this._geomVOs = new Array();
            };

            Merge.prototype.merge = function (destMesh, dispose) {
                var i;
                var subIdx;
                var oldGeom;
                var destGeom;
                var useSubMaterials;

                oldGeom = destMesh.geometry;
                destGeom = destMesh.geometry = new Geometry();
                subIdx = destMesh.subMeshes.length;

                // Only apply materials directly to sub-meshes if necessary,
                // i.e. if there is more than one material available.
                useSubMaterials = (this._geomVOs.length > 1);

                for (i = 0; i < this._geomVOs.length; i++) {
                    var s;
                    var data;
                    var sub = new TriangleSubGeometry(true);
                    sub.autoDeriveNormals = false;
                    sub.autoDeriveTangents = false;

                    data = this._geomVOs[i];
                    sub.updateIndices(data.indices);
                    sub.updatePositions(data.vertices);
                    sub.updateVertexNormals(data.normals);
                    sub.updateVertexTangents(data.tangents);
                    sub.updateUVs(data.uvs);

                    destGeom.addSubGeometry(sub);

                    if (this._keepMaterial && useSubMaterials)
                        destMesh.subMeshes[subIdx].material = data.material;
                }

                if (this._keepMaterial && !useSubMaterials && this._geomVOs.length)
                    destMesh.material = this._geomVOs[0].material;

                if (dispose) {
                    var m;
                    var len = this._toDispose.length;
                    for (var i; i < len; i++) {
                        m = this._toDispose[i];
                        m.geometry.dispose();
                        m.dispose();
                    }

                    //dispose of the original receiver geometry
                    oldGeom.dispose();
                }

                this._toDispose = null;
            };

            Merge.prototype.collect = function (mesh, dispose) {
                if (mesh.geometry) {
                    var subIdx;
                    var subGeometries = mesh.geometry.subGeometries;
                    var calc;
                    for (subIdx = 0; subIdx < subGeometries.length; subIdx++) {
                        var i;
                        var len;
                        var iIdx, vIdx, nIdx, tIdx, uIdx;
                        var indexOffset;
                        var subGeom;
                        var vo;
                        var vertices;
                        var normals;
                        var tangents;
                        var pd, nd, td, ud;

                        subGeom = subGeometries[subIdx];
                        pd = subGeom.positions;
                        nd = subGeom.vertexNormals;
                        td = subGeom.vertexTangents;
                        ud = subGeom.uvs;

                        // Get (or create) a VO for this material
                        vo = this.getSubGeomData(mesh.subMeshes[subIdx].material || mesh.material);

                        // Vertices and normals are copied to temporary vectors, to be transformed
                        // before concatenated onto those of the data. This is unnecessary if no
                        // transformation will be performed, i.e. for object space merging.
                        vertices = (this._objectSpace) ? vo.vertices : new Array();
                        normals = (this._objectSpace) ? vo.normals : new Array();
                        tangents = (this._objectSpace) ? vo.tangents : new Array();

                        // Copy over vertex attributes
                        vIdx = vertices.length;
                        nIdx = normals.length;
                        tIdx = tangents.length;
                        uIdx = vo.uvs.length;
                        len = subGeom.numVertices;
                        for (i = 0; i < len; i++) {
                            calc = i * 3;

                            // Position
                            vertices[vIdx++] = pd[calc];
                            vertices[vIdx++] = pd[calc + 1];
                            vertices[vIdx++] = pd[calc + 2];

                            // Normal
                            normals[nIdx++] = nd[calc];
                            normals[nIdx++] = nd[calc + 1];
                            normals[nIdx++] = nd[calc + 2];

                            // Tangent
                            tangents[tIdx++] = td[calc];
                            tangents[tIdx++] = td[calc + 1];
                            tangents[tIdx++] = td[calc + 2];

                            // UV
                            vo.uvs[uIdx++] = ud[i * 2];
                            vo.uvs[uIdx++] = ud[i * 2 + 1];
                        }

                        // Copy over triangle indices
                        indexOffset = (!this._objectSpace) ? vo.vertices.length / 3 : 0;
                        iIdx = vo.indices.length;
                        len = subGeom.numTriangles;
                        for (i = 0; i < len; i++) {
                            calc = i * 3;
                            vo.indices[iIdx++] = subGeom.indices[calc] + indexOffset;
                            vo.indices[iIdx++] = subGeom.indices[calc + 1] + indexOffset;
                            vo.indices[iIdx++] = subGeom.indices[calc + 2] + indexOffset;
                        }

                        if (!this._objectSpace) {
                            mesh.sceneTransform.transformVectors(vertices, vertices);
                            Matrix3DUtils.deltaTransformVectors(mesh.sceneTransform, normals, normals);
                            Matrix3DUtils.deltaTransformVectors(mesh.sceneTransform, tangents, tangents);

                            // Copy vertex data from temporary (transformed) vectors
                            vIdx = vo.vertices.length;
                            nIdx = vo.normals.length;
                            tIdx = vo.tangents.length;
                            len = vertices.length;
                            for (i = 0; i < len; i++) {
                                vo.vertices[vIdx++] = vertices[i];
                                vo.normals[nIdx++] = normals[i];
                                vo.tangents[tIdx++] = tangents[i];
                            }
                        }
                    }

                    if (dispose)
                        this._toDispose.push(mesh);
                }
            };

            Merge.prototype.getSubGeomData = function (material) {
                var data;

                if (this._keepMaterial) {
                    var i;
                    var len;

                    len = this._geomVOs.length;
                    for (i = 0; i < len; i++) {
                        if (this._geomVOs[i].material == material) {
                            data = this._geomVOs[i];
                            break;
                        }
                    }
                } else if (this._geomVOs.length) {
                    // If materials are not to be kept, all data can be
                    // put into a single VO, so return that one.
                    data = this._geomVOs[0];
                }

                // No data (for this material) found, create new.
                if (!data) {
                    data = new GeometryVO();
                    data.vertices = new Array();
                    data.normals = new Array();
                    data.tangents = new Array();
                    data.uvs = new Array();
                    data.indices = new Array();
                    data.material = material;

                    this._geomVOs.push(data);
                }

                return data;
            };

            Merge.prototype.parseContainer = function (receiver, object) {
                var child;
                var i;

                if (object instanceof Mesh && object != receiver)
                    this.collect(object, this._disposeSources);

                for (i = 0; i < object.numChildren; ++i) {
                    child = object.getChildAt(i);
                    this.parseContainer(receiver, child);
                }
            };
            return Merge;
        })();
        commands.Merge = Merge;
    })(away.commands || (away.commands = {}));
    var commands = away.commands;
})(away || (away = {}));

var GeometryVO = (function () {
    function GeometryVO() {
    }
    return GeometryVO;
})();
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (tools) {
        /**
        * ...
        */
        var ParticleGeometryTransform = (function () {
            function ParticleGeometryTransform() {
            }


            Object.defineProperty(ParticleGeometryTransform.prototype, "UVTransform", {
                get: function () {
                    return this._defaultUVTransform;
                },
                set: function (value) {
                    this._defaultUVTransform = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleGeometryTransform.prototype, "vertexTransform", {
                get: function () {
                    return this._defaultVertexTransform;
                },
                set: function (value) {
                    this._defaultVertexTransform = value;
                    this._defaultInvVertexTransform = value.clone();
                    this._defaultInvVertexTransform.invert();
                    this._defaultInvVertexTransform.transpose();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParticleGeometryTransform.prototype, "invVertexTransform", {
                get: function () {
                    return this._defaultInvVertexTransform;
                },
                enumerable: true,
                configurable: true
            });
            return ParticleGeometryTransform;
        })();
        tools.ParticleGeometryTransform = ParticleGeometryTransform;
    })(away.tools || (away.tools = {}));
    var tools = away.tools;
})(away || (away = {}));
///<reference path="../../_definitions.ts"/>
var away;
(function (away) {
    (function (tools) {
        var ParticleData = away.animators.ParticleData;
        var ParticleGeometry = away.base.ParticleGeometry;

        var TriangleSubGeometry = away.base.TriangleSubGeometry;

        var Point = away.geom.Point;
        var Vector3D = away.geom.Vector3D;

        /**
        * ...
        */
        var ParticleGeometryHelper = (function () {
            function ParticleGeometryHelper() {
            }
            ParticleGeometryHelper.generateGeometry = function (geometries, transforms) {
                if (typeof transforms === "undefined") { transforms = null; }
                var indicesVector = new Array();
                var positionsVector = new Array();
                var normalsVector = new Array();
                var tangentsVector = new Array();
                var uvsVector = new Array();
                var vertexCounters = new Array();
                var particles = new Array();
                var subGeometries = new Array();
                var numParticles = geometries.length;

                var sourceSubGeometries;
                var sourceSubGeometry;
                var numSubGeometries;
                var indices;
                var positions;
                var normals;
                var tangents;
                var uvs;
                var vertexCounter;
                var subGeometry;
                var i;
                var j;
                var sub2SubMap = new Array();

                var tempVertex = new Vector3D;
                var tempNormal = new Vector3D;
                var tempTangents = new Vector3D;
                var tempUV = new Point;

                for (i = 0; i < numParticles; i++) {
                    sourceSubGeometries = geometries[i].subGeometries;
                    numSubGeometries = sourceSubGeometries.length;
                    for (var srcIndex = 0; srcIndex < numSubGeometries; srcIndex++) {
                        //create a different particle subgeometry group for each source subgeometry in a particle.
                        if (sub2SubMap.length <= srcIndex) {
                            sub2SubMap.push(subGeometries.length);
                            indicesVector.push(new Array());
                            positionsVector.push(new Array());
                            normalsVector.push(new Array());
                            tangentsVector.push(new Array());
                            uvsVector.push(new Array());
                            subGeometries.push(new TriangleSubGeometry(true));
                            vertexCounters.push(0);
                        }

                        sourceSubGeometry = sourceSubGeometries[srcIndex];

                        //add a new particle subgeometry if this source subgeometry will take us over the maxvertex limit
                        if (sourceSubGeometry.numVertices + vertexCounters[sub2SubMap[srcIndex]] > ParticleGeometryHelper.MAX_VERTEX) {
                            //update submap and add new subgeom vectors
                            sub2SubMap[srcIndex] = subGeometries.length;
                            indicesVector.push(new Array());
                            positionsVector.push(new Array());
                            normalsVector.push(new Array());
                            tangentsVector.push(new Array());
                            uvsVector.push(new Array());
                            subGeometries.push(new TriangleSubGeometry(true));
                            vertexCounters.push(0);
                        }

                        j = sub2SubMap[srcIndex];

                        //select the correct vector
                        indices = indicesVector[j];
                        positions = positionsVector[j];
                        normals = normalsVector[j];
                        tangents = tangentsVector[j];
                        uvs = uvsVector[j];
                        vertexCounter = vertexCounters[j];
                        subGeometry = subGeometries[j];

                        var particleData = new ParticleData();
                        particleData.numVertices = sourceSubGeometry.numVertices;
                        particleData.startVertexIndex = vertexCounter;
                        particleData.particleIndex = i;
                        particleData.subGeometry = subGeometry;
                        particles.push(particleData);

                        vertexCounters[j] += sourceSubGeometry.numVertices;

                        var k;
                        var tempLen;
                        var compact = sourceSubGeometry;
                        var product;
                        var sourcePositions;
                        var sourceNormals;
                        var sourceTangents;
                        var sourceUVs;

                        if (compact) {
                            tempLen = compact.numVertices;
                            compact.numTriangles;
                            sourcePositions = compact.positions;
                            sourceNormals = compact.vertexNormals;
                            sourceTangents = compact.vertexTangents;
                            sourceUVs = compact.uvs;

                            if (transforms) {
                                var particleGeometryTransform = transforms[i];
                                var vertexTransform = particleGeometryTransform.vertexTransform;
                                var invVertexTransform = particleGeometryTransform.invVertexTransform;
                                var UVTransform = particleGeometryTransform.UVTransform;

                                for (k = 0; k < tempLen; k++) {
                                    /*
                                    * 0 - 2: vertex position X, Y, Z
                                    * 3 - 5: normal X, Y, Z
                                    * 6 - 8: tangent X, Y, Z
                                    * 9 - 10: U V
                                    * 11 - 12: Secondary U V*/
                                    product = k * 3;
                                    tempVertex.x = sourcePositions[product];
                                    tempVertex.y = sourcePositions[product + 1];
                                    tempVertex.z = sourcePositions[product + 2];
                                    tempNormal.x = sourceNormals[product];
                                    tempNormal.y = sourceNormals[product + 1];
                                    tempNormal.z = sourceNormals[product + 2];
                                    tempTangents.x = sourceTangents[product];
                                    tempTangents.y = sourceTangents[product + 1];
                                    tempTangents.z = sourceTangents[product + 2];
                                    tempUV.x = sourceUVs[k * 2];
                                    tempUV.y = sourceUVs[k * 2 + 1];
                                    if (vertexTransform) {
                                        tempVertex = vertexTransform.transformVector(tempVertex);
                                        tempNormal = invVertexTransform.deltaTransformVector(tempNormal);
                                        tempTangents = invVertexTransform.deltaTransformVector(tempNormal);
                                    }
                                    if (UVTransform)
                                        tempUV = UVTransform.transformPoint(tempUV);

                                    //this is faster than that only push one data
                                    sourcePositions.push(tempVertex.x, tempVertex.y, tempVertex.z);
                                    sourceNormals.push(tempNormal.x, tempNormal.y, tempNormal.z);
                                    sourceTangents.push(tempTangents.x, tempTangents.y, tempTangents.z);
                                    sourceUVs.push(tempUV.x, tempUV.y);
                                }
                            } else {
                                for (k = 0; k < tempLen; k++) {
                                    product = k * 3;

                                    //this is faster than that only push one data
                                    positions.push(sourcePositions[product], sourcePositions[product + 1], sourcePositions[product + 2]);
                                    normals.push(sourceNormals[product], sourceNormals[product + 1], sourceNormals[product + 2]);
                                    tangents.push(sourceTangents[product], sourceTangents[product + 1], sourceTangents[product + 2]);
                                    uvs.push(sourceUVs[k * 2], sourceUVs[k * 2 + 1]);
                                }
                            }
                        } else {
                            //Todo
                        }

                        var sourceIndices = sourceSubGeometry.indices;
                        tempLen = sourceSubGeometry.numTriangles;
                        for (k = 0; k < tempLen; k++) {
                            product = k * 3;
                            indices.push(sourceIndices[product] + vertexCounter, sourceIndices[product + 1] + vertexCounter, sourceIndices[product + 2] + vertexCounter);
                        }
                    }
                }

                var particleGeometry = new ParticleGeometry();
                particleGeometry.particles = particles;
                particleGeometry.numParticles = numParticles;

                numParticles = subGeometries.length;
                for (i = 0; i < numParticles; i++) {
                    subGeometry = subGeometries[i];
                    subGeometry.autoDeriveNormals = false;
                    subGeometry.autoDeriveTangents = false;
                    subGeometry.updateIndices(indicesVector[i]);
                    subGeometry.updatePositions(positionsVector[i]);
                    subGeometry.updateVertexNormals(normalsVector[i]);
                    subGeometry.updateVertexTangents(tangentsVector[i]);
                    subGeometry.updateUVs(uvsVector[i]);
                    particleGeometry.addSubGeometry(subGeometry);
                }

                return particleGeometry;
            };
            ParticleGeometryHelper.MAX_VERTEX = 65535;
            return ParticleGeometryHelper;
        })();
        tools.ParticleGeometryHelper = ParticleGeometryHelper;
    })(away.tools || (away.tools = {}));
    var tools = away.tools;
})(away || (away = {}));
/**********************************************************************************************************************************************************************************************************
* This file contains a reference to all the classes used in the project.
********************************************************************************************************************************************************************************************************
*
* The TypeScript compiler exports classes in a non deterministic manner, as the extend functionality copies the prototype chain
* of one object onto another during initialisation and load (to create extensible functionality), the non deterministic nature of the
* compiler can result in an extend operation referencing a class that is undefined and not yet loaded - which throw an JavaScript error.
*
* This file provides the compiler with a strict order in which to export the TypeScript classes to mitigate undefined extend errors
*
* @see https://typescript.codeplex.com/workitem/1356 @see https://typescript.codeplex.com/workitem/913
*
*********************************************************************************************************************************************************************************************************/
///<reference path="../../libs/ref/js.d.ts"/>
///<reference path="../../libs/awayjs-core.next.d.ts"/>
///<reference path="../../libs/stagegl-context.next.d.ts"/>
///<reference path="errors/AnimationSetError.ts"/>
///<reference path="events/LightEvent.ts" />
///<reference path="events/AnimationStateEvent.ts" />
///<reference path="events/AnimatorEvent.ts" />
///<reference path="events/ShadingMethodEvent.ts"/>
///<reference path="core/base/ParticleGeometry.ts"/>
///<reference path="core/pool/RenderableBase.ts"/>
///<reference path="core/pool/BillboardRenderable.ts"/>
///<reference path="core/pool/LineSubMeshRenderable.ts"/>
///<reference path="core/pool/SkyboxRenderable.ts"/>
///<reference path="core/pool/TriangleSubMeshRenderable.ts"/>
///<reference path="core/traverse/EntityCollector.ts" />
///<reference path="core/traverse/ShadowCasterCollector.ts" />
///<reference path="core/partition/DirectionalLightNode.ts" />
///<reference path="core/partition/LightProbeNode.ts" />
///<reference path="core/partition/PointLightNode.ts" />
///<reference path="core/pick/PickingColliderBase.ts" />
///<reference path="core/pick/JSPickingCollider.ts" />
///<reference path="core/pick/ShaderPicker.ts" />
///<reference path="core/render/RendererBase.ts"/>
///<reference path="core/render/DepthRenderer.ts"/>
///<reference path="core/render/DefaultRenderer.ts"/>
///<reference path="core/render/Filter3DRenderer.ts"/>
///<reference path="materials/utils/DefaultMaterialManager.ts"/>
///<reference path="filters/tasks/Filter3DTaskBase.ts"/>
///<reference path="filters/Filter3DBase.ts"/>
///<reference path="lights/LightBase.ts"/>
///<reference path="lights/LightProbe.ts"/>
///<reference path="lights/PointLight.ts"/>
///<reference path="lights/DirectionalLight.ts"/>
///<reference path="lights/shadowmaps/ShadowMapperBase.ts"/>
///<reference path="lights/shadowmaps/CubeMapShadowMapper.ts"/>
///<reference path="lights/shadowmaps/DirectionalShadowMapper.ts"/>
///<reference path="lights/shadowmaps/CascadeShadowMapper.ts"/>
///<reference path="lights/shadowmaps/NearDirectionalShadowMapper.ts"/>
///<reference path="materials/passes/MaterialPassBase.ts"/>
///<reference path="materials/passes/CompiledPass.ts"/>
///<reference path="materials/passes/SuperShaderPass.ts"/>
///<reference path="materials/passes/DepthMapPass.ts"/>
///<reference path="materials/passes/DistanceMapPass.ts"/>
///<reference path="materials/passes/LightingPass.ts"/>
///<reference path="materials/passes/ShadowCasterPass.ts"/>
///<reference path="materials/passes/SingleObjectDepthPass.ts"/>
///<reference path="materials/passes/SegmentPass.ts"/>
///<reference path="materials/passes/SkyboxPass.ts"/>
///<reference path="materials/methods/MethodVO.ts"/>
///<reference path="materials/methods/MethodVOSet.ts"/>
///<reference path="materials/methods/ShadingMethodBase.ts"/>
///<reference path="materials/methods/LightingMethodBase.ts"/>
///<reference path="materials/methods/ShadowMapMethodBase.ts"/>
///<reference path="materials/methods/ShaderMethodSetup.ts"/>
///<reference path="materials/methods/AmbientBasicMethod.ts"/>
///<reference path="materials/methods/AmbientEnvMapMethod.ts"/>
///<reference path="materials/methods/DiffuseBasicMethod.ts"/>
///<reference path="materials/methods/DiffuseCompositeMethod.ts"/>
///<reference path="materials/methods/DiffuseCelMethod.ts"/>
///<reference path="materials/methods/DiffuseDepthMethod.ts"/>
///<reference path="materials/methods/DiffuseGradientMethod.ts"/>
///<reference path="materials/methods/DiffuseLightMapMethod.ts"/>
///<reference path="materials/methods/DiffuseSubSurfaceMethod.ts"/>
///<reference path="materials/methods/DiffuseWrapMethod.ts"/>
///<reference path="materials/methods/EffectMethodBase.ts"/>
///<reference path="materials/methods/EffectAlphaMaskMethod.ts"/>
///<reference path="materials/methods/EffectColorMatrixMethod.ts"/>
///<reference path="materials/methods/EffectColorTransformMethod.ts"/>
///<reference path="materials/methods/EffectEnvMapMethod.ts"/>
///<reference path="materials/methods/EffectFogMethod.ts"/>
///<reference path="materials/methods/EffectFresnelEnvMapMethod.ts"/>
///<reference path="materials/methods/EffectLightMapMethod.ts"/>
///<reference path="materials/methods/EffectRefractionEnvMapMethod.ts"/>
///<reference path="materials/methods/EffectRimLightMethod.ts"/>
///<reference path="materials/methods/NormalBasicMethod.ts"/>
///<reference path="materials/methods/NormalHeightMapMethod.ts"/>
///<reference path="materials/methods/NormalSimpleWaterMethod.ts"/>
///<reference path="materials/methods/ShadowMethodBase.ts"/>
///<reference path="materials/methods/ShadowCascadeMethod.ts"/>
///<reference path="materials/methods/ShadowDitheredMethod.ts"/>
///<reference path="materials/methods/ShadowFilteredMethod.ts"/>
///<reference path="materials/methods/ShadowHardMethod.ts"/>
///<reference path="materials/methods/ShadowNearMethod.ts"/>
///<reference path="materials/methods/ShadowSoftMethod.ts"/>
///<reference path="materials/methods/SpecularBasicMethod.ts"/>
///<reference path="materials/methods/SpecularCompositeMethod.ts"/>
///<reference path="materials/methods/SpecularAnisotropicMethod.ts"/>
///<reference path="materials/methods/SpecularCelMethod.ts"/>
///<reference path="materials/methods/SpecularFresnelMethod.ts"/>
///<reference path="materials/methods/SpecularPhongMethod.ts"/>
///<reference path="materials/lightpickers/LightPickerBase.ts"/>
///<reference path="materials/lightpickers/StaticLightPicker.ts"/>
///<reference path="materials/compilation/ShaderRegisterCache.ts"/>
///<reference path="materials/compilation/ShaderRegisterElement.ts"/>
///<reference path="materials/compilation/ShaderRegisterData.ts"/>
///<reference path="materials/compilation/MethodDependencyCounter.ts"/>
///<reference path="materials/compilation/RegisterPool.ts"/>
///<reference path="materials/compilation/ShaderRegisterCache.ts"/>
///<reference path="materials/compilation/ShaderCompiler.ts"/>
///<reference path="materials/compilation/SuperShaderCompiler.ts"/>
///<reference path="materials/LightSources.ts"/>
///<reference path="materials/MaterialBase.ts"/>
///<reference path="materials/SinglePassMaterialBase.ts"/>
///<reference path="materials/MultiPassMaterialBase.ts"/>
///<reference path="materials/TextureMultiPassMaterial.ts"/>
///<reference path="materials/ColorMultiPassMaterial.ts"/>
///<reference path="materials/TextureMaterial.ts"/>
///<reference path="materials/ColorMaterial.ts"/>
///<reference path="materials/compilation/LightingShaderCompiler.ts"/>
///<reference path="materials/SegmentMaterial.ts"/>
///<reference path="materials/SkyboxMaterial.ts"/>
///<reference path="utils/PerspectiveMatrix3D.ts"/>
///<reference path="animators/data/AnimationRegisterCache.ts"/>
///<reference path="animators/data/AnimationSubGeometry.ts"/>
///<reference path="animators/data/ColorSegmentPoint.ts"/>
///<reference path="animators/data/JointPose.ts"/>
///<reference path="animators/data/ParticleAnimationData.ts"/>
///<reference path="animators/data/ParticleData.ts"/>
///<reference path="animators/data/ParticleProperties.ts"/>
///<reference path="animators/data/ParticlePropertiesMode.ts"/>
///<reference path="animators/data/Skeleton.ts"/>
///<reference path="animators/data/VertexAnimationMode.ts"/>
///<reference path="animators/data/SkeletonJoint.ts"/>
///<reference path="animators/data/SkeletonPose.ts"/>
///<reference path="animators/data/VertexAnimationMode.ts"/>
///<reference path="animators/nodes/AnimationClipNodeBase.ts"/>
///<reference path="animators/nodes/ParticleNodeBase.ts"/>
///<reference path="animators/nodes/ParticleAccelerationNode.ts"/>
///<reference path="animators/nodes/ParticleBezierCurveNode.ts"/>
///<reference path="animators/nodes/ParticleBillboardNode.ts"/>
///<reference path="animators/nodes/ParticleColorNode.ts"/>
///<reference path="animators/nodes/ParticleFollowNode.ts"/>
///<reference path="animators/nodes/ParticleInitialColorNode.ts"/>
///<reference path="animators/nodes/ParticleOrbitNode.ts"/>
///<reference path="animators/nodes/ParticleOscillatorNode.ts"/>
///<reference path="animators/nodes/ParticlePositionNode.ts"/>
///<reference path="animators/nodes/ParticleRotateToHeadingNode.ts"/>
///<reference path="animators/nodes/ParticleRotateToPositionNode.ts"/>
///<reference path="animators/nodes/ParticleRotationalVelocityNode.ts"/>
///<reference path="animators/nodes/ParticleScaleNode.ts"/>
///<reference path="animators/nodes/ParticleSegmentedColorNode.ts"/>
///<reference path="animators/nodes/ParticleSpriteSheetNode.ts"/>
///<reference path="animators/nodes/ParticleTimeNode.ts"/>
///<reference path="animators/nodes/ParticleUVNode.ts"/>
///<reference path="animators/nodes/ParticleVelocityNode.ts"/>
///<reference path="animators/nodes/SkeletonBinaryLERPNode.ts"/>
///<reference path="animators/nodes/SkeletonClipNode.ts"/>
///<reference path="animators/nodes/SkeletonDifferenceNode.ts"/>
///<reference path="animators/nodes/SkeletonDirectionalNode.ts"/>
///<reference path="animators/nodes/SkeletonNaryLERPNode.ts"/>
///<reference path="animators/nodes/VertexClipNode.ts"/>
///<reference path="animators/states/IAnimationState.ts"/>
///<reference path="animators/states/ISkeletonAnimationState.ts"/>
///<reference path="animators/states/IVertexAnimationState.ts"/>
///<reference path="animators/states/AnimationStateBase.ts"/>
///<reference path="animators/states/ParticleStateBase.ts"/>
///<reference path="animators/states/ParticleAccelerationState.ts"/>
///<reference path="animators/states/ParticleBezierCurveState.ts"/>
///<reference path="animators/states/ParticleBillboardState.ts"/>
///<reference path="animators/states/ParticleColorState.ts"/>
///<reference path="animators/states/ParticleFollowState.ts"/>
///<reference path="animators/states/ParticleInitialColorState.ts"/>
///<reference path="animators/states/ParticleOrbitState.ts"/>
///<reference path="animators/states/ParticleOscillatorState.ts"/>
///<reference path="animators/states/ParticlePositionState.ts"/>
///<reference path="animators/states/ParticleRotateToHeadingState.ts"/>
///<reference path="animators/states/ParticleRotateToPositionState.ts"/>
///<reference path="animators/states/ParticleRotationalVelocityState.ts"/>
///<reference path="animators/states/ParticleScaleState.ts"/>
///<reference path="animators/states/ParticleSegmentedColorState.ts"/>
///<reference path="animators/states/ParticleSpriteSheetState.ts"/>
///<reference path="animators/states/ParticleTimeState.ts"/>
///<reference path="animators/states/ParticleUVState.ts"/>
///<reference path="animators/states/ParticleVelocityState.ts"/>
///<reference path="animators/states/AnimationClipState.ts"/>
///<reference path="animators/states/SkeletonBinaryLERPState.ts"/>
///<reference path="animators/states/SkeletonClipState.ts"/>
///<reference path="animators/states/SkeletonDifferenceState.ts"/>
///<reference path="animators/states/SkeletonDirectionalState.ts"/>
///<reference path="animators/states/SkeletonNaryLERPState.ts"/>
///<reference path="animators/states/VertexClipState.ts"/>
///<reference path="animators/transitions/IAnimationTransition.ts"/>
///<reference path="animators/transitions/CrossfadeTransition.ts"/>
///<reference path="animators/transitions/CrossfadeTransitionNode.ts"/>
///<reference path="animators/transitions/CrossfadeTransitionState.ts"/>
///<reference path="animators/AnimationSetBase.ts"/>
///<reference path="animators/AnimatorBase.ts"/>
///<reference path="animators/ParticleAnimationSet.ts"/>
///<reference path="animators/ParticleAnimator.ts"/>
///<reference path="animators/SkeletonAnimator.ts"/>
///<reference path="animators/SkeletonAnimationSet.ts"/>
///<reference path="animators/VertexAnimationSet.ts"/>
///<reference path="animators/VertexAnimator.ts"/>
///<reference path="parsers/OBJParser.ts"/>
///<reference path="parsers/AWDParser.ts"/>
///<reference path="parsers/Max3DSParser.ts"/>
///<reference path="parsers/MD2Parser.ts"/>
///<reference path="parsers/MD5AnimParser.ts"/>
///<reference path="parsers/MD5MeshParser.ts"/>
///<reference path="parsers/Parsers.ts"/>
///<reference path="tools/commands/Merge.ts"/>
///<reference path="tools/data/ParticleGeometryTransform.ts"/>
///<reference path="tools/helpers/ParticleGeometryHelper.ts"/>
///<reference path="away/_definitions.ts"/>
away.Debug.THROW_ERRORS = false;
away.Debug.LOG_PI_ERRORS = false;

var away;
(function (away) {
    var StageGLRenderer = (function (_super) {
        __extends(StageGLRenderer, _super);
        function StageGLRenderer() {
            _super.call(this);
        }
        return StageGLRenderer;
    })(away.events.EventDispatcher);
    away.StageGLRenderer = StageGLRenderer;
})(away || (away = {}));
//# sourceMappingURL=stagegl-renderer.next.js.map
